
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Provider
 * 
 */
export type Provider = $Result.DefaultSelection<Prisma.$ProviderPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model ProductBranch
 * 
 */
export type ProductBranch = $Result.DefaultSelection<Prisma.$ProductBranchPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model SaleHeader
 * 
 */
export type SaleHeader = $Result.DefaultSelection<Prisma.$SaleHeaderPayload>
/**
 * Model SaleDetail
 * 
 */
export type SaleDetail = $Result.DefaultSelection<Prisma.$SaleDetailPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model CreditPayment
 * 
 */
export type CreditPayment = $Result.DefaultSelection<Prisma.$CreditPaymentPayload>
/**
 * Model EmployeeShift
 * 
 */
export type EmployeeShift = $Result.DefaultSelection<Prisma.$EmployeeShiftPayload>
/**
 * Model CashCount
 * 
 */
export type CashCount = $Result.DefaultSelection<Prisma.$CashCountPayload>
/**
 * Model CashMovement
 * 
 */
export type CashMovement = $Result.DefaultSelection<Prisma.$CashMovementPayload>
/**
 * Model InventoryAdjustment
 * 
 */
export type InventoryAdjustment = $Result.DefaultSelection<Prisma.$InventoryAdjustmentPayload>
/**
 * Model SystemLog
 * 
 */
export type SystemLog = $Result.DefaultSelection<Prisma.$SystemLogPayload>
/**
 * Model StockTransfer
 * 
 */
export type StockTransfer = $Result.DefaultSelection<Prisma.$StockTransferPayload>
/**
 * Model StockTransferDetail
 * 
 */
export type StockTransferDetail = $Result.DefaultSelection<Prisma.$StockTransferDetailPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.provider`: Exposes CRUD operations for the **Provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.provider.findMany()
    * ```
    */
  get provider(): Prisma.ProviderDelegate<ExtArgs>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs>;

  /**
   * `prisma.productBranch`: Exposes CRUD operations for the **ProductBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductBranches
    * const productBranches = await prisma.productBranch.findMany()
    * ```
    */
  get productBranch(): Prisma.ProductBranchDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.saleHeader`: Exposes CRUD operations for the **SaleHeader** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleHeaders
    * const saleHeaders = await prisma.saleHeader.findMany()
    * ```
    */
  get saleHeader(): Prisma.SaleHeaderDelegate<ExtArgs>;

  /**
   * `prisma.saleDetail`: Exposes CRUD operations for the **SaleDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleDetails
    * const saleDetails = await prisma.saleDetail.findMany()
    * ```
    */
  get saleDetail(): Prisma.SaleDetailDelegate<ExtArgs>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs>;

  /**
   * `prisma.creditPayment`: Exposes CRUD operations for the **CreditPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditPayments
    * const creditPayments = await prisma.creditPayment.findMany()
    * ```
    */
  get creditPayment(): Prisma.CreditPaymentDelegate<ExtArgs>;

  /**
   * `prisma.employeeShift`: Exposes CRUD operations for the **EmployeeShift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeShifts
    * const employeeShifts = await prisma.employeeShift.findMany()
    * ```
    */
  get employeeShift(): Prisma.EmployeeShiftDelegate<ExtArgs>;

  /**
   * `prisma.cashCount`: Exposes CRUD operations for the **CashCount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashCounts
    * const cashCounts = await prisma.cashCount.findMany()
    * ```
    */
  get cashCount(): Prisma.CashCountDelegate<ExtArgs>;

  /**
   * `prisma.cashMovement`: Exposes CRUD operations for the **CashMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashMovements
    * const cashMovements = await prisma.cashMovement.findMany()
    * ```
    */
  get cashMovement(): Prisma.CashMovementDelegate<ExtArgs>;

  /**
   * `prisma.inventoryAdjustment`: Exposes CRUD operations for the **InventoryAdjustment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryAdjustments
    * const inventoryAdjustments = await prisma.inventoryAdjustment.findMany()
    * ```
    */
  get inventoryAdjustment(): Prisma.InventoryAdjustmentDelegate<ExtArgs>;

  /**
   * `prisma.systemLog`: Exposes CRUD operations for the **SystemLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemLogs
    * const systemLogs = await prisma.systemLog.findMany()
    * ```
    */
  get systemLog(): Prisma.SystemLogDelegate<ExtArgs>;

  /**
   * `prisma.stockTransfer`: Exposes CRUD operations for the **StockTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockTransfers
    * const stockTransfers = await prisma.stockTransfer.findMany()
    * ```
    */
  get stockTransfer(): Prisma.StockTransferDelegate<ExtArgs>;

  /**
   * `prisma.stockTransferDetail`: Exposes CRUD operations for the **StockTransferDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockTransferDetails
    * const stockTransferDetails = await prisma.stockTransferDetail.findMany()
    * ```
    */
  get stockTransferDetail(): Prisma.StockTransferDetailDelegate<ExtArgs>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.10.2
   * Query Engine version: 5a9203d0590c951969e85a7d07215503f4672eb9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Product: 'Product',
    Category: 'Category',
    Provider: 'Provider',
    Branch: 'Branch',
    ProductBranch: 'ProductBranch',
    Customer: 'Customer',
    SaleHeader: 'SaleHeader',
    SaleDetail: 'SaleDetail',
    Expense: 'Expense',
    Purchase: 'Purchase',
    CreditPayment: 'CreditPayment',
    EmployeeShift: 'EmployeeShift',
    CashCount: 'CashCount',
    CashMovement: 'CashMovement',
    InventoryAdjustment: 'InventoryAdjustment',
    SystemLog: 'SystemLog',
    StockTransfer: 'StockTransfer',
    StockTransferDetail: 'StockTransferDetail',
    SystemSetting: 'SystemSetting'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'product' | 'category' | 'provider' | 'branch' | 'productBranch' | 'customer' | 'saleHeader' | 'saleDetail' | 'expense' | 'purchase' | 'creditPayment' | 'employeeShift' | 'cashCount' | 'cashMovement' | 'inventoryAdjustment' | 'systemLog' | 'stockTransfer' | 'stockTransferDetail' | 'systemSetting'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Provider: {
        payload: Prisma.$ProviderPayload<ExtArgs>
        fields: Prisma.ProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findFirst: {
            args: Prisma.ProviderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findMany: {
            args: Prisma.ProviderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          create: {
            args: Prisma.ProviderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          delete: {
            args: Prisma.ProviderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          update: {
            args: Prisma.ProviderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          deleteMany: {
            args: Prisma.ProviderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProviderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          aggregate: {
            args: Prisma.ProviderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProvider>
          }
          groupBy: {
            args: Prisma.ProviderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderCountArgs<ExtArgs>,
            result: $Utils.Optional<ProviderCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>,
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      ProductBranch: {
        payload: Prisma.$ProductBranchPayload<ExtArgs>
        fields: Prisma.ProductBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductBranchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductBranchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductBranchPayload>
          }
          findFirst: {
            args: Prisma.ProductBranchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductBranchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductBranchPayload>
          }
          findMany: {
            args: Prisma.ProductBranchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductBranchPayload>[]
          }
          create: {
            args: Prisma.ProductBranchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductBranchPayload>
          }
          delete: {
            args: Prisma.ProductBranchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductBranchPayload>
          }
          update: {
            args: Prisma.ProductBranchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductBranchPayload>
          }
          deleteMany: {
            args: Prisma.ProductBranchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductBranchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductBranchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductBranchPayload>
          }
          aggregate: {
            args: Prisma.ProductBranchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductBranch>
          }
          groupBy: {
            args: Prisma.ProductBranchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductBranchCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductBranchCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      SaleHeader: {
        payload: Prisma.$SaleHeaderPayload<ExtArgs>
        fields: Prisma.SaleHeaderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleHeaderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleHeaderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleHeaderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleHeaderPayload>
          }
          findFirst: {
            args: Prisma.SaleHeaderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleHeaderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleHeaderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleHeaderPayload>
          }
          findMany: {
            args: Prisma.SaleHeaderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleHeaderPayload>[]
          }
          create: {
            args: Prisma.SaleHeaderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleHeaderPayload>
          }
          delete: {
            args: Prisma.SaleHeaderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleHeaderPayload>
          }
          update: {
            args: Prisma.SaleHeaderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleHeaderPayload>
          }
          deleteMany: {
            args: Prisma.SaleHeaderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SaleHeaderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SaleHeaderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleHeaderPayload>
          }
          aggregate: {
            args: Prisma.SaleHeaderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSaleHeader>
          }
          groupBy: {
            args: Prisma.SaleHeaderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SaleHeaderGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleHeaderCountArgs<ExtArgs>,
            result: $Utils.Optional<SaleHeaderCountAggregateOutputType> | number
          }
        }
      }
      SaleDetail: {
        payload: Prisma.$SaleDetailPayload<ExtArgs>
        fields: Prisma.SaleDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleDetailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleDetailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleDetailPayload>
          }
          findFirst: {
            args: Prisma.SaleDetailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleDetailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleDetailPayload>
          }
          findMany: {
            args: Prisma.SaleDetailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleDetailPayload>[]
          }
          create: {
            args: Prisma.SaleDetailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleDetailPayload>
          }
          delete: {
            args: Prisma.SaleDetailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleDetailPayload>
          }
          update: {
            args: Prisma.SaleDetailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleDetailPayload>
          }
          deleteMany: {
            args: Prisma.SaleDetailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SaleDetailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SaleDetailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SaleDetailPayload>
          }
          aggregate: {
            args: Prisma.SaleDetailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSaleDetail>
          }
          groupBy: {
            args: Prisma.SaleDetailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SaleDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleDetailCountArgs<ExtArgs>,
            result: $Utils.Optional<SaleDetailCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>,
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      CreditPayment: {
        payload: Prisma.$CreditPaymentPayload<ExtArgs>
        fields: Prisma.CreditPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditPaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CreditPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditPaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CreditPaymentPayload>
          }
          findFirst: {
            args: Prisma.CreditPaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CreditPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditPaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CreditPaymentPayload>
          }
          findMany: {
            args: Prisma.CreditPaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CreditPaymentPayload>[]
          }
          create: {
            args: Prisma.CreditPaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CreditPaymentPayload>
          }
          delete: {
            args: Prisma.CreditPaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CreditPaymentPayload>
          }
          update: {
            args: Prisma.CreditPaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CreditPaymentPayload>
          }
          deleteMany: {
            args: Prisma.CreditPaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CreditPaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CreditPaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CreditPaymentPayload>
          }
          aggregate: {
            args: Prisma.CreditPaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCreditPayment>
          }
          groupBy: {
            args: Prisma.CreditPaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CreditPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditPaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<CreditPaymentCountAggregateOutputType> | number
          }
        }
      }
      EmployeeShift: {
        payload: Prisma.$EmployeeShiftPayload<ExtArgs>
        fields: Prisma.EmployeeShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeShiftFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeShiftFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          findFirst: {
            args: Prisma.EmployeeShiftFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeShiftFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          findMany: {
            args: Prisma.EmployeeShiftFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>[]
          }
          create: {
            args: Prisma.EmployeeShiftCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          delete: {
            args: Prisma.EmployeeShiftDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          update: {
            args: Prisma.EmployeeShiftUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeShiftDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeShiftUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeShiftUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          aggregate: {
            args: Prisma.EmployeeShiftAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmployeeShift>
          }
          groupBy: {
            args: Prisma.EmployeeShiftGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmployeeShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeShiftCountArgs<ExtArgs>,
            result: $Utils.Optional<EmployeeShiftCountAggregateOutputType> | number
          }
        }
      }
      CashCount: {
        payload: Prisma.$CashCountPayload<ExtArgs>
        fields: Prisma.CashCountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashCountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashCountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashCountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashCountPayload>
          }
          findFirst: {
            args: Prisma.CashCountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashCountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashCountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashCountPayload>
          }
          findMany: {
            args: Prisma.CashCountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashCountPayload>[]
          }
          create: {
            args: Prisma.CashCountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashCountPayload>
          }
          delete: {
            args: Prisma.CashCountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashCountPayload>
          }
          update: {
            args: Prisma.CashCountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashCountPayload>
          }
          deleteMany: {
            args: Prisma.CashCountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CashCountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CashCountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashCountPayload>
          }
          aggregate: {
            args: Prisma.CashCountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCashCount>
          }
          groupBy: {
            args: Prisma.CashCountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CashCountGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashCountCountArgs<ExtArgs>,
            result: $Utils.Optional<CashCountCountAggregateOutputType> | number
          }
        }
      }
      CashMovement: {
        payload: Prisma.$CashMovementPayload<ExtArgs>
        fields: Prisma.CashMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashMovementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashMovementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>
          }
          findFirst: {
            args: Prisma.CashMovementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashMovementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>
          }
          findMany: {
            args: Prisma.CashMovementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>[]
          }
          create: {
            args: Prisma.CashMovementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>
          }
          delete: {
            args: Prisma.CashMovementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>
          }
          update: {
            args: Prisma.CashMovementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>
          }
          deleteMany: {
            args: Prisma.CashMovementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CashMovementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CashMovementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>
          }
          aggregate: {
            args: Prisma.CashMovementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCashMovement>
          }
          groupBy: {
            args: Prisma.CashMovementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CashMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashMovementCountArgs<ExtArgs>,
            result: $Utils.Optional<CashMovementCountAggregateOutputType> | number
          }
        }
      }
      InventoryAdjustment: {
        payload: Prisma.$InventoryAdjustmentPayload<ExtArgs>
        fields: Prisma.InventoryAdjustmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryAdjustmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryAdjustmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>
          }
          findFirst: {
            args: Prisma.InventoryAdjustmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryAdjustmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>
          }
          findMany: {
            args: Prisma.InventoryAdjustmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>[]
          }
          create: {
            args: Prisma.InventoryAdjustmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>
          }
          delete: {
            args: Prisma.InventoryAdjustmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>
          }
          update: {
            args: Prisma.InventoryAdjustmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>
          }
          deleteMany: {
            args: Prisma.InventoryAdjustmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryAdjustmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InventoryAdjustmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>
          }
          aggregate: {
            args: Prisma.InventoryAdjustmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInventoryAdjustment>
          }
          groupBy: {
            args: Prisma.InventoryAdjustmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InventoryAdjustmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryAdjustmentCountArgs<ExtArgs>,
            result: $Utils.Optional<InventoryAdjustmentCountAggregateOutputType> | number
          }
        }
      }
      SystemLog: {
        payload: Prisma.$SystemLogPayload<ExtArgs>
        fields: Prisma.SystemLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findFirst: {
            args: Prisma.SystemLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findMany: {
            args: Prisma.SystemLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          create: {
            args: Prisma.SystemLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          delete: {
            args: Prisma.SystemLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          update: {
            args: Prisma.SystemLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          deleteMany: {
            args: Prisma.SystemLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SystemLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SystemLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          aggregate: {
            args: Prisma.SystemLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSystemLog>
          }
          groupBy: {
            args: Prisma.SystemLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SystemLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemLogCountArgs<ExtArgs>,
            result: $Utils.Optional<SystemLogCountAggregateOutputType> | number
          }
        }
      }
      StockTransfer: {
        payload: Prisma.$StockTransferPayload<ExtArgs>
        fields: Prisma.StockTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockTransferFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockTransferFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          findFirst: {
            args: Prisma.StockTransferFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockTransferFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          findMany: {
            args: Prisma.StockTransferFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>[]
          }
          create: {
            args: Prisma.StockTransferCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          delete: {
            args: Prisma.StockTransferDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          update: {
            args: Prisma.StockTransferUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          deleteMany: {
            args: Prisma.StockTransferDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockTransferUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockTransferUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          aggregate: {
            args: Prisma.StockTransferAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockTransfer>
          }
          groupBy: {
            args: Prisma.StockTransferGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockTransferCountArgs<ExtArgs>,
            result: $Utils.Optional<StockTransferCountAggregateOutputType> | number
          }
        }
      }
      StockTransferDetail: {
        payload: Prisma.$StockTransferDetailPayload<ExtArgs>
        fields: Prisma.StockTransferDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockTransferDetailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockTransferDetailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferDetailPayload>
          }
          findFirst: {
            args: Prisma.StockTransferDetailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockTransferDetailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferDetailPayload>
          }
          findMany: {
            args: Prisma.StockTransferDetailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferDetailPayload>[]
          }
          create: {
            args: Prisma.StockTransferDetailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferDetailPayload>
          }
          delete: {
            args: Prisma.StockTransferDetailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferDetailPayload>
          }
          update: {
            args: Prisma.StockTransferDetailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferDetailPayload>
          }
          deleteMany: {
            args: Prisma.StockTransferDetailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockTransferDetailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockTransferDetailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockTransferDetailPayload>
          }
          aggregate: {
            args: Prisma.StockTransferDetailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockTransferDetail>
          }
          groupBy: {
            args: Prisma.StockTransferDetailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockTransferDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockTransferDetailCountArgs<ExtArgs>,
            result: $Utils.Optional<StockTransferDetailCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>,
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.DriverAdapter | null
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    shifts: number
    sales: number
    inventoryAdjustments: number
    systemLogs: number
    cashMovements: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | UserCountOutputTypeCountShiftsArgs
    sales?: boolean | UserCountOutputTypeCountSalesArgs
    inventoryAdjustments?: boolean | UserCountOutputTypeCountInventoryAdjustmentsArgs
    systemLogs?: boolean | UserCountOutputTypeCountSystemLogsArgs
    cashMovements?: boolean | UserCountOutputTypeCountCashMovementsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeShiftWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleHeaderWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAdjustmentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSystemLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCashMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashMovementWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    inventory: number
    saleDetails: number
    adjustments: number
    transferDetails: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | ProductCountOutputTypeCountInventoryArgs
    saleDetails?: boolean | ProductCountOutputTypeCountSaleDetailsArgs
    adjustments?: boolean | ProductCountOutputTypeCountAdjustmentsArgs
    transferDetails?: boolean | ProductCountOutputTypeCountTransferDetailsArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBranchWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSaleDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleDetailWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAdjustmentWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTransferDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferDetailWhereInput
  }



  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Count Type ProviderCountOutputType
   */

  export type ProviderCountOutputType = {
    products: number
    purchases: number
  }

  export type ProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProviderCountOutputTypeCountProductsArgs
    purchases?: boolean | ProviderCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCountOutputType
     */
    select?: ProviderCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }



  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    inventory: number
    sales: number
    expenses: number
    purchases: number
    cashMovements: number
    customers: number
    users: number
    sentTransfers: number
    receivedTransfers: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | BranchCountOutputTypeCountInventoryArgs
    sales?: boolean | BranchCountOutputTypeCountSalesArgs
    expenses?: boolean | BranchCountOutputTypeCountExpensesArgs
    purchases?: boolean | BranchCountOutputTypeCountPurchasesArgs
    cashMovements?: boolean | BranchCountOutputTypeCountCashMovementsArgs
    customers?: boolean | BranchCountOutputTypeCountCustomersArgs
    users?: boolean | BranchCountOutputTypeCountUsersArgs
    sentTransfers?: boolean | BranchCountOutputTypeCountSentTransfersArgs
    receivedTransfers?: boolean | BranchCountOutputTypeCountReceivedTransfersArgs
  }

  // Custom InputTypes

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBranchWhereInput
  }


  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleHeaderWhereInput
  }


  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }


  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }


  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountCashMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashMovementWhereInput
  }


  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }


  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSentTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferWhereInput
  }


  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountReceivedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferWhereInput
  }



  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    sales: number
    creditPayments: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | CustomerCountOutputTypeCountSalesArgs
    creditPayments?: boolean | CustomerCountOutputTypeCountCreditPaymentsArgs
  }

  // Custom InputTypes

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleHeaderWhereInput
  }


  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCreditPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditPaymentWhereInput
  }



  /**
   * Count Type SaleHeaderCountOutputType
   */

  export type SaleHeaderCountOutputType = {
    details: number
    creditPayment: number
  }

  export type SaleHeaderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | SaleHeaderCountOutputTypeCountDetailsArgs
    creditPayment?: boolean | SaleHeaderCountOutputTypeCountCreditPaymentArgs
  }

  // Custom InputTypes

  /**
   * SaleHeaderCountOutputType without action
   */
  export type SaleHeaderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeaderCountOutputType
     */
    select?: SaleHeaderCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SaleHeaderCountOutputType without action
   */
  export type SaleHeaderCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleDetailWhereInput
  }


  /**
   * SaleHeaderCountOutputType without action
   */
  export type SaleHeaderCountOutputTypeCountCreditPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditPaymentWhereInput
  }



  /**
   * Count Type EmployeeShiftCountOutputType
   */

  export type EmployeeShiftCountOutputType = {
    cashCounts: number
    sales: number
  }

  export type EmployeeShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashCounts?: boolean | EmployeeShiftCountOutputTypeCountCashCountsArgs
    sales?: boolean | EmployeeShiftCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes

  /**
   * EmployeeShiftCountOutputType without action
   */
  export type EmployeeShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShiftCountOutputType
     */
    select?: EmployeeShiftCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EmployeeShiftCountOutputType without action
   */
  export type EmployeeShiftCountOutputTypeCountCashCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashCountWhereInput
  }


  /**
   * EmployeeShiftCountOutputType without action
   */
  export type EmployeeShiftCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleHeaderWhereInput
  }



  /**
   * Count Type StockTransferCountOutputType
   */

  export type StockTransferCountOutputType = {
    details: number
  }

  export type StockTransferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | StockTransferCountOutputTypeCountDetailsArgs
  }

  // Custom InputTypes

  /**
   * StockTransferCountOutputType without action
   */
  export type StockTransferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferCountOutputType
     */
    select?: StockTransferCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StockTransferCountOutputType without action
   */
  export type StockTransferCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferDetailWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    permissions: string | null
    createdAt: Date | null
    updatedAt: Date | null
    branchId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    permissions: string | null
    createdAt: Date | null
    updatedAt: Date | null
    branchId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    permissions: number
    createdAt: number
    updatedAt: number
    branchId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    branchId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    branchId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    branchId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    role: string
    permissions: string | null
    createdAt: Date
    updatedAt: Date
    branchId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branchId?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
    shifts?: boolean | User$shiftsArgs<ExtArgs>
    sales?: boolean | User$salesArgs<ExtArgs>
    inventoryAdjustments?: boolean | User$inventoryAdjustmentsArgs<ExtArgs>
    systemLogs?: boolean | User$systemLogsArgs<ExtArgs>
    cashMovements?: boolean | User$cashMovementsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branchId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
    shifts?: boolean | User$shiftsArgs<ExtArgs>
    sales?: boolean | User$salesArgs<ExtArgs>
    inventoryAdjustments?: boolean | User$inventoryAdjustmentsArgs<ExtArgs>
    systemLogs?: boolean | User$systemLogsArgs<ExtArgs>
    cashMovements?: boolean | User$cashMovementsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      shifts: Prisma.$EmployeeShiftPayload<ExtArgs>[]
      sales: Prisma.$SaleHeaderPayload<ExtArgs>[]
      inventoryAdjustments: Prisma.$InventoryAdjustmentPayload<ExtArgs>[]
      systemLogs: Prisma.$SystemLogPayload<ExtArgs>[]
      cashMovements: Prisma.$CashMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      role: string
      permissions: string | null
      createdAt: Date
      updatedAt: Date
      branchId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    shifts<T extends User$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, User$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, 'findMany'> | Null>;

    sales<T extends User$salesArgs<ExtArgs> = {}>(args?: Subset<T, User$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'findMany'> | Null>;

    inventoryAdjustments<T extends User$inventoryAdjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryAdjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    systemLogs<T extends User$systemLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$systemLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, 'findMany'> | Null>;

    cashMovements<T extends User$cashMovementsArgs<ExtArgs> = {}>(args?: Subset<T, User$cashMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly permissions: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly branchId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }


  /**
   * User.shifts
   */
  export type User$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    where?: EmployeeShiftWhereInput
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    cursor?: EmployeeShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }


  /**
   * User.sales
   */
  export type User$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    where?: SaleHeaderWhereInput
    orderBy?: SaleHeaderOrderByWithRelationInput | SaleHeaderOrderByWithRelationInput[]
    cursor?: SaleHeaderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleHeaderScalarFieldEnum | SaleHeaderScalarFieldEnum[]
  }


  /**
   * User.inventoryAdjustments
   */
  export type User$inventoryAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    where?: InventoryAdjustmentWhereInput
    orderBy?: InventoryAdjustmentOrderByWithRelationInput | InventoryAdjustmentOrderByWithRelationInput[]
    cursor?: InventoryAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryAdjustmentScalarFieldEnum | InventoryAdjustmentScalarFieldEnum[]
  }


  /**
   * User.systemLogs
   */
  export type User$systemLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SystemLogInclude<ExtArgs> | null
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    cursor?: SystemLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }


  /**
   * User.cashMovements
   */
  export type User$cashMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashMovementInclude<ExtArgs> | null
    where?: CashMovementWhereInput
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    cursor?: CashMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashMovementScalarFieldEnum | CashMovementScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    cost: Decimal | null
    priceRetail: Decimal | null
    priceWholesale: Decimal | null
    minStock: Decimal | null
  }

  export type ProductSumAggregateOutputType = {
    cost: Decimal | null
    priceRetail: Decimal | null
    priceWholesale: Decimal | null
    minStock: Decimal | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    cost: Decimal | null
    priceRetail: Decimal | null
    priceWholesale: Decimal | null
    unit: string | null
    isActive: boolean | null
    minStock: Decimal | null
    expiresAt: Date | null
    providerId: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    cost: Decimal | null
    priceRetail: Decimal | null
    priceWholesale: Decimal | null
    unit: string | null
    isActive: boolean | null
    minStock: Decimal | null
    expiresAt: Date | null
    providerId: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    code: number
    cost: number
    priceRetail: number
    priceWholesale: number
    unit: number
    isActive: number
    minStock: number
    expiresAt: number
    providerId: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    cost?: true
    priceRetail?: true
    priceWholesale?: true
    minStock?: true
  }

  export type ProductSumAggregateInputType = {
    cost?: true
    priceRetail?: true
    priceWholesale?: true
    minStock?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    cost?: true
    priceRetail?: true
    priceWholesale?: true
    unit?: true
    isActive?: true
    minStock?: true
    expiresAt?: true
    providerId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    cost?: true
    priceRetail?: true
    priceWholesale?: true
    unit?: true
    isActive?: true
    minStock?: true
    expiresAt?: true
    providerId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    cost?: true
    priceRetail?: true
    priceWholesale?: true
    unit?: true
    isActive?: true
    minStock?: true
    expiresAt?: true
    providerId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    code: string | null
    cost: Decimal | null
    priceRetail: Decimal | null
    priceWholesale: Decimal | null
    unit: string
    isActive: boolean
    minStock: Decimal | null
    expiresAt: Date | null
    providerId: string | null
    categoryId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    cost?: boolean
    priceRetail?: boolean
    priceWholesale?: boolean
    unit?: boolean
    isActive?: boolean
    minStock?: boolean
    expiresAt?: boolean
    providerId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | Product$providerArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    inventory?: boolean | Product$inventoryArgs<ExtArgs>
    saleDetails?: boolean | Product$saleDetailsArgs<ExtArgs>
    adjustments?: boolean | Product$adjustmentsArgs<ExtArgs>
    transferDetails?: boolean | Product$transferDetailsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    cost?: boolean
    priceRetail?: boolean
    priceWholesale?: boolean
    unit?: boolean
    isActive?: boolean
    minStock?: boolean
    expiresAt?: boolean
    providerId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | Product$providerArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    inventory?: boolean | Product$inventoryArgs<ExtArgs>
    saleDetails?: boolean | Product$saleDetailsArgs<ExtArgs>
    adjustments?: boolean | Product$adjustmentsArgs<ExtArgs>
    transferDetails?: boolean | Product$transferDetailsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs> | null
      inventory: Prisma.$ProductBranchPayload<ExtArgs>[]
      saleDetails: Prisma.$SaleDetailPayload<ExtArgs>[]
      adjustments: Prisma.$InventoryAdjustmentPayload<ExtArgs>[]
      transferDetails: Prisma.$StockTransferDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      cost: Prisma.Decimal | null
      priceRetail: Prisma.Decimal | null
      priceWholesale: Prisma.Decimal | null
      unit: string
      isActive: boolean
      minStock: Prisma.Decimal | null
      expiresAt: Date | null
      providerId: string | null
      categoryId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }


  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    provider<T extends Product$providerArgs<ExtArgs> = {}>(args?: Subset<T, Product$providerArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    inventory<T extends Product$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBranchPayload<ExtArgs>, T, 'findMany'> | Null>;

    saleDetails<T extends Product$saleDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Product$saleDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleDetailPayload<ExtArgs>, T, 'findMany'> | Null>;

    adjustments<T extends Product$adjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, Product$adjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    transferDetails<T extends Product$transferDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Product$transferDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferDetailPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly code: FieldRef<"Product", 'String'>
    readonly cost: FieldRef<"Product", 'Decimal'>
    readonly priceRetail: FieldRef<"Product", 'Decimal'>
    readonly priceWholesale: FieldRef<"Product", 'Decimal'>
    readonly unit: FieldRef<"Product", 'String'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly minStock: FieldRef<"Product", 'Decimal'>
    readonly expiresAt: FieldRef<"Product", 'DateTime'>
    readonly providerId: FieldRef<"Product", 'String'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }


  /**
   * Product.provider
   */
  export type Product$providerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    where?: ProviderWhereInput
  }


  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }


  /**
   * Product.inventory
   */
  export type Product$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBranch
     */
    select?: ProductBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductBranchInclude<ExtArgs> | null
    where?: ProductBranchWhereInput
    orderBy?: ProductBranchOrderByWithRelationInput | ProductBranchOrderByWithRelationInput[]
    cursor?: ProductBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductBranchScalarFieldEnum | ProductBranchScalarFieldEnum[]
  }


  /**
   * Product.saleDetails
   */
  export type Product$saleDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDetail
     */
    select?: SaleDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleDetailInclude<ExtArgs> | null
    where?: SaleDetailWhereInput
    orderBy?: SaleDetailOrderByWithRelationInput | SaleDetailOrderByWithRelationInput[]
    cursor?: SaleDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleDetailScalarFieldEnum | SaleDetailScalarFieldEnum[]
  }


  /**
   * Product.adjustments
   */
  export type Product$adjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    where?: InventoryAdjustmentWhereInput
    orderBy?: InventoryAdjustmentOrderByWithRelationInput | InventoryAdjustmentOrderByWithRelationInput[]
    cursor?: InventoryAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryAdjustmentScalarFieldEnum | InventoryAdjustmentScalarFieldEnum[]
  }


  /**
   * Product.transferDetails
   */
  export type Product$transferDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferDetail
     */
    select?: StockTransferDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferDetailInclude<ExtArgs> | null
    where?: StockTransferDetailWhereInput
    orderBy?: StockTransferDetailOrderByWithRelationInput | StockTransferDetailOrderByWithRelationInput[]
    cursor?: StockTransferDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransferDetailScalarFieldEnum | StockTransferDetailScalarFieldEnum[]
  }


  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
  }



  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }


  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }


  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
  }



  /**
   * Model Provider
   */

  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  export type ProviderMinAggregateOutputType = {
    id: string | null
    name: string | null
    contact: string | null
    phone: string | null
    email: string | null
    rfc: string | null
    address: string | null
  }

  export type ProviderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contact: string | null
    phone: string | null
    email: string | null
    rfc: string | null
    address: string | null
  }

  export type ProviderCountAggregateOutputType = {
    id: number
    name: number
    contact: number
    phone: number
    email: number
    rfc: number
    address: number
    _all: number
  }


  export type ProviderMinAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    phone?: true
    email?: true
    rfc?: true
    address?: true
  }

  export type ProviderMaxAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    phone?: true
    email?: true
    rfc?: true
    address?: true
  }

  export type ProviderCountAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    phone?: true
    email?: true
    rfc?: true
    address?: true
    _all?: true
  }

  export type ProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provider to aggregate.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderMaxAggregateInputType
  }

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>
  }




  export type ProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
    orderBy?: ProviderOrderByWithAggregationInput | ProviderOrderByWithAggregationInput[]
    by: ProviderScalarFieldEnum[] | ProviderScalarFieldEnum
    having?: ProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCountAggregateInputType | true
    _min?: ProviderMinAggregateInputType
    _max?: ProviderMaxAggregateInputType
  }

  export type ProviderGroupByOutputType = {
    id: string
    name: string
    contact: string | null
    phone: string | null
    email: string | null
    rfc: string | null
    address: string | null
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  type GetProviderGroupByPayload<T extends ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
        }
      >
    >


  export type ProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    phone?: boolean
    email?: boolean
    rfc?: boolean
    address?: boolean
    products?: boolean | Provider$productsArgs<ExtArgs>
    purchases?: boolean | Provider$purchasesArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectScalar = {
    id?: boolean
    name?: boolean
    contact?: boolean
    phone?: boolean
    email?: boolean
    rfc?: boolean
    address?: boolean
  }

  export type ProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Provider$productsArgs<ExtArgs>
    purchases?: boolean | Provider$purchasesArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Provider"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contact: string | null
      phone: string | null
      email: string | null
      rfc: string | null
      address: string | null
    }, ExtArgs["result"]["provider"]>
    composites: {}
  }


  type ProviderGetPayload<S extends boolean | null | undefined | ProviderDefaultArgs> = $Result.GetResult<Prisma.$ProviderPayload, S>

  type ProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProviderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProviderCountAggregateInputType | true
    }

  export interface ProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provider'], meta: { name: 'Provider' } }
    /**
     * Find zero or one Provider that matches the filter.
     * @param {ProviderFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProviderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderFindUniqueArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Provider that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProviderFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProviderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProviderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderFindFirstArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Provider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProviderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerWithIdOnly = await prisma.provider.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProviderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Provider.
     * @param {ProviderCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     * 
    **/
    create<T extends ProviderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderCreateArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Provider.
     * @param {ProviderDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     * 
    **/
    delete<T extends ProviderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderDeleteArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Provider.
     * @param {ProviderUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProviderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUpdateArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Providers.
     * @param {ProviderDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProviderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProviderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Provider.
     * @param {ProviderUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
    **/
    upsert<T extends ProviderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUpsertArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProviderCountArgs>(
      args?: Subset<T, ProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAggregateArgs>(args: Subset<T, ProviderAggregateArgs>): Prisma.PrismaPromise<GetProviderAggregateType<T>>

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderGroupByArgs['orderBy'] }
        : { orderBy?: ProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Provider model
   */
  readonly fields: ProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    products<T extends Provider$productsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    purchases<T extends Provider$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Provider$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Provider model
   */ 
  interface ProviderFieldRefs {
    readonly id: FieldRef<"Provider", 'String'>
    readonly name: FieldRef<"Provider", 'String'>
    readonly contact: FieldRef<"Provider", 'String'>
    readonly phone: FieldRef<"Provider", 'String'>
    readonly email: FieldRef<"Provider", 'String'>
    readonly rfc: FieldRef<"Provider", 'String'>
    readonly address: FieldRef<"Provider", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Provider findUnique
   */
  export type ProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }


  /**
   * Provider findUniqueOrThrow
   */
  export type ProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }


  /**
   * Provider findFirst
   */
  export type ProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }


  /**
   * Provider findFirstOrThrow
   */
  export type ProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }


  /**
   * Provider findMany
   */
  export type ProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }


  /**
   * Provider create
   */
  export type ProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a Provider.
     */
    data: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
  }


  /**
   * Provider update
   */
  export type ProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a Provider.
     */
    data: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
    /**
     * Choose, which Provider to update.
     */
    where: ProviderWhereUniqueInput
  }


  /**
   * Provider updateMany
   */
  export type ProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
  }


  /**
   * Provider upsert
   */
  export type ProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the Provider to update in case it exists.
     */
    where: ProviderWhereUniqueInput
    /**
     * In case the Provider found by the `where` argument doesn't exist, create a new Provider with this data.
     */
    create: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
    /**
     * In case the Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
  }


  /**
   * Provider delete
   */
  export type ProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter which Provider to delete.
     */
    where: ProviderWhereUniqueInput
  }


  /**
   * Provider deleteMany
   */
  export type ProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to delete
     */
    where?: ProviderWhereInput
  }


  /**
   * Provider.products
   */
  export type Provider$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Provider.purchases
   */
  export type Provider$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }


  /**
   * Provider without action
   */
  export type ProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
  }



  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
  }

  export type BranchMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    _all: number
  }


  export type BranchMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: string
    name: string
    address: string | null
    phone: string | null
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    inventory?: boolean | Branch$inventoryArgs<ExtArgs>
    sales?: boolean | Branch$salesArgs<ExtArgs>
    expenses?: boolean | Branch$expensesArgs<ExtArgs>
    purchases?: boolean | Branch$purchasesArgs<ExtArgs>
    cashMovements?: boolean | Branch$cashMovementsArgs<ExtArgs>
    customers?: boolean | Branch$customersArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    sentTransfers?: boolean | Branch$sentTransfersArgs<ExtArgs>
    receivedTransfers?: boolean | Branch$receivedTransfersArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
  }

  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | Branch$inventoryArgs<ExtArgs>
    sales?: boolean | Branch$salesArgs<ExtArgs>
    expenses?: boolean | Branch$expensesArgs<ExtArgs>
    purchases?: boolean | Branch$purchasesArgs<ExtArgs>
    cashMovements?: boolean | Branch$cashMovementsArgs<ExtArgs>
    customers?: boolean | Branch$customersArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    sentTransfers?: boolean | Branch$sentTransfersArgs<ExtArgs>
    receivedTransfers?: boolean | Branch$receivedTransfersArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      inventory: Prisma.$ProductBranchPayload<ExtArgs>[]
      sales: Prisma.$SaleHeaderPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      cashMovements: Prisma.$CashMovementPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      sentTransfers: Prisma.$StockTransferPayload<ExtArgs>[]
      receivedTransfers: Prisma.$StockTransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      phone: string | null
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }


  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BranchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Branch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BranchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BranchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
    **/
    create<T extends BranchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BranchCreateArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
    **/
    delete<T extends BranchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BranchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BranchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BranchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
    **/
    upsert<T extends BranchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    inventory<T extends Branch$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Branch$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBranchPayload<ExtArgs>, T, 'findMany'> | Null>;

    sales<T extends Branch$salesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'findMany'> | Null>;

    expenses<T extends Branch$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'findMany'> | Null>;

    purchases<T extends Branch$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, 'findMany'> | Null>;

    cashMovements<T extends Branch$cashMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$cashMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, 'findMany'> | Null>;

    customers<T extends Branch$customersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findMany'> | Null>;

    users<T extends Branch$usersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    sentTransfers<T extends Branch$sentTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$sentTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, 'findMany'> | Null>;

    receivedTransfers<T extends Branch$receivedTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$receivedTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Branch model
   */ 
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'String'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly phone: FieldRef<"Branch", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }


  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }


  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }


  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }


  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }


  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }


  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }


  /**
   * Branch.inventory
   */
  export type Branch$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBranch
     */
    select?: ProductBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductBranchInclude<ExtArgs> | null
    where?: ProductBranchWhereInput
    orderBy?: ProductBranchOrderByWithRelationInput | ProductBranchOrderByWithRelationInput[]
    cursor?: ProductBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductBranchScalarFieldEnum | ProductBranchScalarFieldEnum[]
  }


  /**
   * Branch.sales
   */
  export type Branch$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    where?: SaleHeaderWhereInput
    orderBy?: SaleHeaderOrderByWithRelationInput | SaleHeaderOrderByWithRelationInput[]
    cursor?: SaleHeaderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleHeaderScalarFieldEnum | SaleHeaderScalarFieldEnum[]
  }


  /**
   * Branch.expenses
   */
  export type Branch$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }


  /**
   * Branch.purchases
   */
  export type Branch$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }


  /**
   * Branch.cashMovements
   */
  export type Branch$cashMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashMovementInclude<ExtArgs> | null
    where?: CashMovementWhereInput
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    cursor?: CashMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashMovementScalarFieldEnum | CashMovementScalarFieldEnum[]
  }


  /**
   * Branch.customers
   */
  export type Branch$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }


  /**
   * Branch.users
   */
  export type Branch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * Branch.sentTransfers
   */
  export type Branch$sentTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferInclude<ExtArgs> | null
    where?: StockTransferWhereInput
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    cursor?: StockTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }


  /**
   * Branch.receivedTransfers
   */
  export type Branch$receivedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferInclude<ExtArgs> | null
    where?: StockTransferWhereInput
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    cursor?: StockTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }


  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
  }



  /**
   * Model ProductBranch
   */

  export type AggregateProductBranch = {
    _count: ProductBranchCountAggregateOutputType | null
    _avg: ProductBranchAvgAggregateOutputType | null
    _sum: ProductBranchSumAggregateOutputType | null
    _min: ProductBranchMinAggregateOutputType | null
    _max: ProductBranchMaxAggregateOutputType | null
  }

  export type ProductBranchAvgAggregateOutputType = {
    quantity: Decimal | null
  }

  export type ProductBranchSumAggregateOutputType = {
    quantity: Decimal | null
  }

  export type ProductBranchMinAggregateOutputType = {
    id: string | null
    productId: string | null
    branchId: string | null
    quantity: Decimal | null
  }

  export type ProductBranchMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    branchId: string | null
    quantity: Decimal | null
  }

  export type ProductBranchCountAggregateOutputType = {
    id: number
    productId: number
    branchId: number
    quantity: number
    _all: number
  }


  export type ProductBranchAvgAggregateInputType = {
    quantity?: true
  }

  export type ProductBranchSumAggregateInputType = {
    quantity?: true
  }

  export type ProductBranchMinAggregateInputType = {
    id?: true
    productId?: true
    branchId?: true
    quantity?: true
  }

  export type ProductBranchMaxAggregateInputType = {
    id?: true
    productId?: true
    branchId?: true
    quantity?: true
  }

  export type ProductBranchCountAggregateInputType = {
    id?: true
    productId?: true
    branchId?: true
    quantity?: true
    _all?: true
  }

  export type ProductBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductBranch to aggregate.
     */
    where?: ProductBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBranches to fetch.
     */
    orderBy?: ProductBranchOrderByWithRelationInput | ProductBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductBranches
    **/
    _count?: true | ProductBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductBranchMaxAggregateInputType
  }

  export type GetProductBranchAggregateType<T extends ProductBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateProductBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductBranch[P]>
      : GetScalarType<T[P], AggregateProductBranch[P]>
  }




  export type ProductBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBranchWhereInput
    orderBy?: ProductBranchOrderByWithAggregationInput | ProductBranchOrderByWithAggregationInput[]
    by: ProductBranchScalarFieldEnum[] | ProductBranchScalarFieldEnum
    having?: ProductBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductBranchCountAggregateInputType | true
    _avg?: ProductBranchAvgAggregateInputType
    _sum?: ProductBranchSumAggregateInputType
    _min?: ProductBranchMinAggregateInputType
    _max?: ProductBranchMaxAggregateInputType
  }

  export type ProductBranchGroupByOutputType = {
    id: string
    productId: string
    branchId: string
    quantity: Decimal
    _count: ProductBranchCountAggregateOutputType | null
    _avg: ProductBranchAvgAggregateOutputType | null
    _sum: ProductBranchSumAggregateOutputType | null
    _min: ProductBranchMinAggregateOutputType | null
    _max: ProductBranchMaxAggregateOutputType | null
  }

  type GetProductBranchGroupByPayload<T extends ProductBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductBranchGroupByOutputType[P]>
            : GetScalarType<T[P], ProductBranchGroupByOutputType[P]>
        }
      >
    >


  export type ProductBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    branchId?: boolean
    quantity?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productBranch"]>

  export type ProductBranchSelectScalar = {
    id?: boolean
    productId?: boolean
    branchId?: boolean
    quantity?: boolean
  }

  export type ProductBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }


  export type $ProductBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductBranch"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      branchId: string
      quantity: Prisma.Decimal
    }, ExtArgs["result"]["productBranch"]>
    composites: {}
  }


  type ProductBranchGetPayload<S extends boolean | null | undefined | ProductBranchDefaultArgs> = $Result.GetResult<Prisma.$ProductBranchPayload, S>

  type ProductBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductBranchCountAggregateInputType | true
    }

  export interface ProductBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductBranch'], meta: { name: 'ProductBranch' } }
    /**
     * Find zero or one ProductBranch that matches the filter.
     * @param {ProductBranchFindUniqueArgs} args - Arguments to find a ProductBranch
     * @example
     * // Get one ProductBranch
     * const productBranch = await prisma.productBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductBranchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductBranchFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductBranchClient<$Result.GetResult<Prisma.$ProductBranchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProductBranch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductBranchFindUniqueOrThrowArgs} args - Arguments to find a ProductBranch
     * @example
     * // Get one ProductBranch
     * const productBranch = await prisma.productBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductBranchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductBranchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductBranchClient<$Result.GetResult<Prisma.$ProductBranchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProductBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBranchFindFirstArgs} args - Arguments to find a ProductBranch
     * @example
     * // Get one ProductBranch
     * const productBranch = await prisma.productBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductBranchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductBranchFindFirstArgs<ExtArgs>>
    ): Prisma__ProductBranchClient<$Result.GetResult<Prisma.$ProductBranchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProductBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBranchFindFirstOrThrowArgs} args - Arguments to find a ProductBranch
     * @example
     * // Get one ProductBranch
     * const productBranch = await prisma.productBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductBranchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductBranchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductBranchClient<$Result.GetResult<Prisma.$ProductBranchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProductBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBranchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductBranches
     * const productBranches = await prisma.productBranch.findMany()
     * 
     * // Get first 10 ProductBranches
     * const productBranches = await prisma.productBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productBranchWithIdOnly = await prisma.productBranch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductBranchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductBranchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBranchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProductBranch.
     * @param {ProductBranchCreateArgs} args - Arguments to create a ProductBranch.
     * @example
     * // Create one ProductBranch
     * const ProductBranch = await prisma.productBranch.create({
     *   data: {
     *     // ... data to create a ProductBranch
     *   }
     * })
     * 
    **/
    create<T extends ProductBranchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductBranchCreateArgs<ExtArgs>>
    ): Prisma__ProductBranchClient<$Result.GetResult<Prisma.$ProductBranchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a ProductBranch.
     * @param {ProductBranchDeleteArgs} args - Arguments to delete one ProductBranch.
     * @example
     * // Delete one ProductBranch
     * const ProductBranch = await prisma.productBranch.delete({
     *   where: {
     *     // ... filter to delete one ProductBranch
     *   }
     * })
     * 
    **/
    delete<T extends ProductBranchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductBranchDeleteArgs<ExtArgs>>
    ): Prisma__ProductBranchClient<$Result.GetResult<Prisma.$ProductBranchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProductBranch.
     * @param {ProductBranchUpdateArgs} args - Arguments to update one ProductBranch.
     * @example
     * // Update one ProductBranch
     * const productBranch = await prisma.productBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductBranchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductBranchUpdateArgs<ExtArgs>>
    ): Prisma__ProductBranchClient<$Result.GetResult<Prisma.$ProductBranchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProductBranches.
     * @param {ProductBranchDeleteManyArgs} args - Arguments to filter ProductBranches to delete.
     * @example
     * // Delete a few ProductBranches
     * const { count } = await prisma.productBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductBranchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductBranchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductBranches
     * const productBranch = await prisma.productBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductBranchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductBranchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductBranch.
     * @param {ProductBranchUpsertArgs} args - Arguments to update or create a ProductBranch.
     * @example
     * // Update or create a ProductBranch
     * const productBranch = await prisma.productBranch.upsert({
     *   create: {
     *     // ... data to create a ProductBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductBranch we want to update
     *   }
     * })
    **/
    upsert<T extends ProductBranchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductBranchUpsertArgs<ExtArgs>>
    ): Prisma__ProductBranchClient<$Result.GetResult<Prisma.$ProductBranchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProductBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBranchCountArgs} args - Arguments to filter ProductBranches to count.
     * @example
     * // Count the number of ProductBranches
     * const count = await prisma.productBranch.count({
     *   where: {
     *     // ... the filter for the ProductBranches we want to count
     *   }
     * })
    **/
    count<T extends ProductBranchCountArgs>(
      args?: Subset<T, ProductBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductBranchAggregateArgs>(args: Subset<T, ProductBranchAggregateArgs>): Prisma.PrismaPromise<GetProductBranchAggregateType<T>>

    /**
     * Group by ProductBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductBranchGroupByArgs['orderBy'] }
        : { orderBy?: ProductBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductBranch model
   */
  readonly fields: ProductBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProductBranch model
   */ 
  interface ProductBranchFieldRefs {
    readonly id: FieldRef<"ProductBranch", 'String'>
    readonly productId: FieldRef<"ProductBranch", 'String'>
    readonly branchId: FieldRef<"ProductBranch", 'String'>
    readonly quantity: FieldRef<"ProductBranch", 'Decimal'>
  }
    

  // Custom InputTypes

  /**
   * ProductBranch findUnique
   */
  export type ProductBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBranch
     */
    select?: ProductBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBranch to fetch.
     */
    where: ProductBranchWhereUniqueInput
  }


  /**
   * ProductBranch findUniqueOrThrow
   */
  export type ProductBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBranch
     */
    select?: ProductBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBranch to fetch.
     */
    where: ProductBranchWhereUniqueInput
  }


  /**
   * ProductBranch findFirst
   */
  export type ProductBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBranch
     */
    select?: ProductBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBranch to fetch.
     */
    where?: ProductBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBranches to fetch.
     */
    orderBy?: ProductBranchOrderByWithRelationInput | ProductBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductBranches.
     */
    cursor?: ProductBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductBranches.
     */
    distinct?: ProductBranchScalarFieldEnum | ProductBranchScalarFieldEnum[]
  }


  /**
   * ProductBranch findFirstOrThrow
   */
  export type ProductBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBranch
     */
    select?: ProductBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBranch to fetch.
     */
    where?: ProductBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBranches to fetch.
     */
    orderBy?: ProductBranchOrderByWithRelationInput | ProductBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductBranches.
     */
    cursor?: ProductBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductBranches.
     */
    distinct?: ProductBranchScalarFieldEnum | ProductBranchScalarFieldEnum[]
  }


  /**
   * ProductBranch findMany
   */
  export type ProductBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBranch
     */
    select?: ProductBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBranches to fetch.
     */
    where?: ProductBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBranches to fetch.
     */
    orderBy?: ProductBranchOrderByWithRelationInput | ProductBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductBranches.
     */
    cursor?: ProductBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBranches.
     */
    skip?: number
    distinct?: ProductBranchScalarFieldEnum | ProductBranchScalarFieldEnum[]
  }


  /**
   * ProductBranch create
   */
  export type ProductBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBranch
     */
    select?: ProductBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductBranch.
     */
    data: XOR<ProductBranchCreateInput, ProductBranchUncheckedCreateInput>
  }


  /**
   * ProductBranch update
   */
  export type ProductBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBranch
     */
    select?: ProductBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductBranch.
     */
    data: XOR<ProductBranchUpdateInput, ProductBranchUncheckedUpdateInput>
    /**
     * Choose, which ProductBranch to update.
     */
    where: ProductBranchWhereUniqueInput
  }


  /**
   * ProductBranch updateMany
   */
  export type ProductBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductBranches.
     */
    data: XOR<ProductBranchUpdateManyMutationInput, ProductBranchUncheckedUpdateManyInput>
    /**
     * Filter which ProductBranches to update
     */
    where?: ProductBranchWhereInput
  }


  /**
   * ProductBranch upsert
   */
  export type ProductBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBranch
     */
    select?: ProductBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductBranch to update in case it exists.
     */
    where: ProductBranchWhereUniqueInput
    /**
     * In case the ProductBranch found by the `where` argument doesn't exist, create a new ProductBranch with this data.
     */
    create: XOR<ProductBranchCreateInput, ProductBranchUncheckedCreateInput>
    /**
     * In case the ProductBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductBranchUpdateInput, ProductBranchUncheckedUpdateInput>
  }


  /**
   * ProductBranch delete
   */
  export type ProductBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBranch
     */
    select?: ProductBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductBranchInclude<ExtArgs> | null
    /**
     * Filter which ProductBranch to delete.
     */
    where: ProductBranchWhereUniqueInput
  }


  /**
   * ProductBranch deleteMany
   */
  export type ProductBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductBranches to delete
     */
    where?: ProductBranchWhereInput
  }


  /**
   * ProductBranch without action
   */
  export type ProductBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBranch
     */
    select?: ProductBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductBranchInclude<ExtArgs> | null
  }



  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    creditLimit: Decimal | null
    currentBalance: Decimal | null
  }

  export type CustomerSumAggregateOutputType = {
    creditLimit: Decimal | null
    currentBalance: Decimal | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    rfc: string | null
    taxRegime: string | null
    address: string | null
    zipCode: string | null
    creditLimit: Decimal | null
    currentBalance: Decimal | null
    branchId: string | null
    createdAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    rfc: string | null
    taxRegime: string | null
    address: string | null
    zipCode: string | null
    creditLimit: Decimal | null
    currentBalance: Decimal | null
    branchId: string | null
    createdAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    email: number
    rfc: number
    taxRegime: number
    address: number
    zipCode: number
    creditLimit: number
    currentBalance: number
    branchId: number
    createdAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    creditLimit?: true
    currentBalance?: true
  }

  export type CustomerSumAggregateInputType = {
    creditLimit?: true
    currentBalance?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    rfc?: true
    taxRegime?: true
    address?: true
    zipCode?: true
    creditLimit?: true
    currentBalance?: true
    branchId?: true
    createdAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    rfc?: true
    taxRegime?: true
    address?: true
    zipCode?: true
    creditLimit?: true
    currentBalance?: true
    branchId?: true
    createdAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    rfc?: true
    taxRegime?: true
    address?: true
    zipCode?: true
    creditLimit?: true
    currentBalance?: true
    branchId?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    phone: string | null
    email: string | null
    rfc: string | null
    taxRegime: string | null
    address: string | null
    zipCode: string | null
    creditLimit: Decimal
    currentBalance: Decimal
    branchId: string | null
    createdAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    rfc?: boolean
    taxRegime?: boolean
    address?: boolean
    zipCode?: boolean
    creditLimit?: boolean
    currentBalance?: boolean
    branchId?: boolean
    createdAt?: boolean
    branch?: boolean | Customer$branchArgs<ExtArgs>
    sales?: boolean | Customer$salesArgs<ExtArgs>
    creditPayments?: boolean | Customer$creditPaymentsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    rfc?: boolean
    taxRegime?: boolean
    address?: boolean
    zipCode?: boolean
    creditLimit?: boolean
    currentBalance?: boolean
    branchId?: boolean
    createdAt?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Customer$branchArgs<ExtArgs>
    sales?: boolean | Customer$salesArgs<ExtArgs>
    creditPayments?: boolean | Customer$creditPaymentsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      sales: Prisma.$SaleHeaderPayload<ExtArgs>[]
      creditPayments: Prisma.$CreditPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string | null
      email: string | null
      rfc: string | null
      taxRegime: string | null
      address: string | null
      zipCode: string | null
      creditLimit: Prisma.Decimal
      currentBalance: Prisma.Decimal
      branchId: string | null
      createdAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }


  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends CustomerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    branch<T extends Customer$branchArgs<ExtArgs> = {}>(args?: Subset<T, Customer$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    sales<T extends Customer$salesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'findMany'> | Null>;

    creditPayments<T extends Customer$creditPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$creditPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly rfc: FieldRef<"Customer", 'String'>
    readonly taxRegime: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly zipCode: FieldRef<"Customer", 'String'>
    readonly creditLimit: FieldRef<"Customer", 'Decimal'>
    readonly currentBalance: FieldRef<"Customer", 'Decimal'>
    readonly branchId: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }


  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }


  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }


  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }


  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }


  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }


  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }


  /**
   * Customer.branch
   */
  export type Customer$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }


  /**
   * Customer.sales
   */
  export type Customer$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    where?: SaleHeaderWhereInput
    orderBy?: SaleHeaderOrderByWithRelationInput | SaleHeaderOrderByWithRelationInput[]
    cursor?: SaleHeaderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleHeaderScalarFieldEnum | SaleHeaderScalarFieldEnum[]
  }


  /**
   * Customer.creditPayments
   */
  export type Customer$creditPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPayment
     */
    select?: CreditPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditPaymentInclude<ExtArgs> | null
    where?: CreditPaymentWhereInput
    orderBy?: CreditPaymentOrderByWithRelationInput | CreditPaymentOrderByWithRelationInput[]
    cursor?: CreditPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditPaymentScalarFieldEnum | CreditPaymentScalarFieldEnum[]
  }


  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
  }



  /**
   * Model SaleHeader
   */

  export type AggregateSaleHeader = {
    _count: SaleHeaderCountAggregateOutputType | null
    _avg: SaleHeaderAvgAggregateOutputType | null
    _sum: SaleHeaderSumAggregateOutputType | null
    _min: SaleHeaderMinAggregateOutputType | null
    _max: SaleHeaderMaxAggregateOutputType | null
  }

  export type SaleHeaderAvgAggregateOutputType = {
    total: Decimal | null
  }

  export type SaleHeaderSumAggregateOutputType = {
    total: Decimal | null
  }

  export type SaleHeaderMinAggregateOutputType = {
    id: string | null
    date: Date | null
    total: Decimal | null
    paymentMethod: string | null
    status: string | null
    branchId: string | null
    userId: string | null
    shiftId: string | null
    customerId: string | null
  }

  export type SaleHeaderMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    total: Decimal | null
    paymentMethod: string | null
    status: string | null
    branchId: string | null
    userId: string | null
    shiftId: string | null
    customerId: string | null
  }

  export type SaleHeaderCountAggregateOutputType = {
    id: number
    date: number
    total: number
    paymentMethod: number
    status: number
    branchId: number
    userId: number
    shiftId: number
    customerId: number
    _all: number
  }


  export type SaleHeaderAvgAggregateInputType = {
    total?: true
  }

  export type SaleHeaderSumAggregateInputType = {
    total?: true
  }

  export type SaleHeaderMinAggregateInputType = {
    id?: true
    date?: true
    total?: true
    paymentMethod?: true
    status?: true
    branchId?: true
    userId?: true
    shiftId?: true
    customerId?: true
  }

  export type SaleHeaderMaxAggregateInputType = {
    id?: true
    date?: true
    total?: true
    paymentMethod?: true
    status?: true
    branchId?: true
    userId?: true
    shiftId?: true
    customerId?: true
  }

  export type SaleHeaderCountAggregateInputType = {
    id?: true
    date?: true
    total?: true
    paymentMethod?: true
    status?: true
    branchId?: true
    userId?: true
    shiftId?: true
    customerId?: true
    _all?: true
  }

  export type SaleHeaderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleHeader to aggregate.
     */
    where?: SaleHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleHeaders to fetch.
     */
    orderBy?: SaleHeaderOrderByWithRelationInput | SaleHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleHeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleHeaders
    **/
    _count?: true | SaleHeaderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleHeaderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleHeaderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleHeaderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleHeaderMaxAggregateInputType
  }

  export type GetSaleHeaderAggregateType<T extends SaleHeaderAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleHeader]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleHeader[P]>
      : GetScalarType<T[P], AggregateSaleHeader[P]>
  }




  export type SaleHeaderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleHeaderWhereInput
    orderBy?: SaleHeaderOrderByWithAggregationInput | SaleHeaderOrderByWithAggregationInput[]
    by: SaleHeaderScalarFieldEnum[] | SaleHeaderScalarFieldEnum
    having?: SaleHeaderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleHeaderCountAggregateInputType | true
    _avg?: SaleHeaderAvgAggregateInputType
    _sum?: SaleHeaderSumAggregateInputType
    _min?: SaleHeaderMinAggregateInputType
    _max?: SaleHeaderMaxAggregateInputType
  }

  export type SaleHeaderGroupByOutputType = {
    id: string
    date: Date
    total: Decimal
    paymentMethod: string
    status: string
    branchId: string
    userId: string | null
    shiftId: string | null
    customerId: string | null
    _count: SaleHeaderCountAggregateOutputType | null
    _avg: SaleHeaderAvgAggregateOutputType | null
    _sum: SaleHeaderSumAggregateOutputType | null
    _min: SaleHeaderMinAggregateOutputType | null
    _max: SaleHeaderMaxAggregateOutputType | null
  }

  type GetSaleHeaderGroupByPayload<T extends SaleHeaderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleHeaderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleHeaderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleHeaderGroupByOutputType[P]>
            : GetScalarType<T[P], SaleHeaderGroupByOutputType[P]>
        }
      >
    >


  export type SaleHeaderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    total?: boolean
    paymentMethod?: boolean
    status?: boolean
    branchId?: boolean
    userId?: boolean
    shiftId?: boolean
    customerId?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    user?: boolean | SaleHeader$userArgs<ExtArgs>
    shift?: boolean | SaleHeader$shiftArgs<ExtArgs>
    customer?: boolean | SaleHeader$customerArgs<ExtArgs>
    details?: boolean | SaleHeader$detailsArgs<ExtArgs>
    creditPayment?: boolean | SaleHeader$creditPaymentArgs<ExtArgs>
    _count?: boolean | SaleHeaderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleHeader"]>

  export type SaleHeaderSelectScalar = {
    id?: boolean
    date?: boolean
    total?: boolean
    paymentMethod?: boolean
    status?: boolean
    branchId?: boolean
    userId?: boolean
    shiftId?: boolean
    customerId?: boolean
  }

  export type SaleHeaderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    user?: boolean | SaleHeader$userArgs<ExtArgs>
    shift?: boolean | SaleHeader$shiftArgs<ExtArgs>
    customer?: boolean | SaleHeader$customerArgs<ExtArgs>
    details?: boolean | SaleHeader$detailsArgs<ExtArgs>
    creditPayment?: boolean | SaleHeader$creditPaymentArgs<ExtArgs>
    _count?: boolean | SaleHeaderCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SaleHeaderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleHeader"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      shift: Prisma.$EmployeeShiftPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      details: Prisma.$SaleDetailPayload<ExtArgs>[]
      creditPayment: Prisma.$CreditPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      total: Prisma.Decimal
      paymentMethod: string
      status: string
      branchId: string
      userId: string | null
      shiftId: string | null
      customerId: string | null
    }, ExtArgs["result"]["saleHeader"]>
    composites: {}
  }


  type SaleHeaderGetPayload<S extends boolean | null | undefined | SaleHeaderDefaultArgs> = $Result.GetResult<Prisma.$SaleHeaderPayload, S>

  type SaleHeaderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleHeaderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleHeaderCountAggregateInputType | true
    }

  export interface SaleHeaderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleHeader'], meta: { name: 'SaleHeader' } }
    /**
     * Find zero or one SaleHeader that matches the filter.
     * @param {SaleHeaderFindUniqueArgs} args - Arguments to find a SaleHeader
     * @example
     * // Get one SaleHeader
     * const saleHeader = await prisma.saleHeader.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SaleHeaderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SaleHeaderFindUniqueArgs<ExtArgs>>
    ): Prisma__SaleHeaderClient<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SaleHeader that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SaleHeaderFindUniqueOrThrowArgs} args - Arguments to find a SaleHeader
     * @example
     * // Get one SaleHeader
     * const saleHeader = await prisma.saleHeader.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SaleHeaderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleHeaderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SaleHeaderClient<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SaleHeader that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleHeaderFindFirstArgs} args - Arguments to find a SaleHeader
     * @example
     * // Get one SaleHeader
     * const saleHeader = await prisma.saleHeader.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SaleHeaderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleHeaderFindFirstArgs<ExtArgs>>
    ): Prisma__SaleHeaderClient<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SaleHeader that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleHeaderFindFirstOrThrowArgs} args - Arguments to find a SaleHeader
     * @example
     * // Get one SaleHeader
     * const saleHeader = await prisma.saleHeader.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SaleHeaderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleHeaderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SaleHeaderClient<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SaleHeaders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleHeaderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleHeaders
     * const saleHeaders = await prisma.saleHeader.findMany()
     * 
     * // Get first 10 SaleHeaders
     * const saleHeaders = await prisma.saleHeader.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleHeaderWithIdOnly = await prisma.saleHeader.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SaleHeaderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleHeaderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SaleHeader.
     * @param {SaleHeaderCreateArgs} args - Arguments to create a SaleHeader.
     * @example
     * // Create one SaleHeader
     * const SaleHeader = await prisma.saleHeader.create({
     *   data: {
     *     // ... data to create a SaleHeader
     *   }
     * })
     * 
    **/
    create<T extends SaleHeaderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SaleHeaderCreateArgs<ExtArgs>>
    ): Prisma__SaleHeaderClient<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a SaleHeader.
     * @param {SaleHeaderDeleteArgs} args - Arguments to delete one SaleHeader.
     * @example
     * // Delete one SaleHeader
     * const SaleHeader = await prisma.saleHeader.delete({
     *   where: {
     *     // ... filter to delete one SaleHeader
     *   }
     * })
     * 
    **/
    delete<T extends SaleHeaderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SaleHeaderDeleteArgs<ExtArgs>>
    ): Prisma__SaleHeaderClient<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SaleHeader.
     * @param {SaleHeaderUpdateArgs} args - Arguments to update one SaleHeader.
     * @example
     * // Update one SaleHeader
     * const saleHeader = await prisma.saleHeader.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SaleHeaderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SaleHeaderUpdateArgs<ExtArgs>>
    ): Prisma__SaleHeaderClient<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SaleHeaders.
     * @param {SaleHeaderDeleteManyArgs} args - Arguments to filter SaleHeaders to delete.
     * @example
     * // Delete a few SaleHeaders
     * const { count } = await prisma.saleHeader.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SaleHeaderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleHeaderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleHeaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleHeaderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleHeaders
     * const saleHeader = await prisma.saleHeader.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SaleHeaderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SaleHeaderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleHeader.
     * @param {SaleHeaderUpsertArgs} args - Arguments to update or create a SaleHeader.
     * @example
     * // Update or create a SaleHeader
     * const saleHeader = await prisma.saleHeader.upsert({
     *   create: {
     *     // ... data to create a SaleHeader
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleHeader we want to update
     *   }
     * })
    **/
    upsert<T extends SaleHeaderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SaleHeaderUpsertArgs<ExtArgs>>
    ): Prisma__SaleHeaderClient<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SaleHeaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleHeaderCountArgs} args - Arguments to filter SaleHeaders to count.
     * @example
     * // Count the number of SaleHeaders
     * const count = await prisma.saleHeader.count({
     *   where: {
     *     // ... the filter for the SaleHeaders we want to count
     *   }
     * })
    **/
    count<T extends SaleHeaderCountArgs>(
      args?: Subset<T, SaleHeaderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleHeaderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleHeader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleHeaderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleHeaderAggregateArgs>(args: Subset<T, SaleHeaderAggregateArgs>): Prisma.PrismaPromise<GetSaleHeaderAggregateType<T>>

    /**
     * Group by SaleHeader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleHeaderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleHeaderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleHeaderGroupByArgs['orderBy'] }
        : { orderBy?: SaleHeaderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleHeaderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleHeaderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleHeader model
   */
  readonly fields: SaleHeaderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleHeader.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleHeaderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends SaleHeader$userArgs<ExtArgs> = {}>(args?: Subset<T, SaleHeader$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    shift<T extends SaleHeader$shiftArgs<ExtArgs> = {}>(args?: Subset<T, SaleHeader$shiftArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    customer<T extends SaleHeader$customerArgs<ExtArgs> = {}>(args?: Subset<T, SaleHeader$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    details<T extends SaleHeader$detailsArgs<ExtArgs> = {}>(args?: Subset<T, SaleHeader$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleDetailPayload<ExtArgs>, T, 'findMany'> | Null>;

    creditPayment<T extends SaleHeader$creditPaymentArgs<ExtArgs> = {}>(args?: Subset<T, SaleHeader$creditPaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SaleHeader model
   */ 
  interface SaleHeaderFieldRefs {
    readonly id: FieldRef<"SaleHeader", 'String'>
    readonly date: FieldRef<"SaleHeader", 'DateTime'>
    readonly total: FieldRef<"SaleHeader", 'Decimal'>
    readonly paymentMethod: FieldRef<"SaleHeader", 'String'>
    readonly status: FieldRef<"SaleHeader", 'String'>
    readonly branchId: FieldRef<"SaleHeader", 'String'>
    readonly userId: FieldRef<"SaleHeader", 'String'>
    readonly shiftId: FieldRef<"SaleHeader", 'String'>
    readonly customerId: FieldRef<"SaleHeader", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SaleHeader findUnique
   */
  export type SaleHeaderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    /**
     * Filter, which SaleHeader to fetch.
     */
    where: SaleHeaderWhereUniqueInput
  }


  /**
   * SaleHeader findUniqueOrThrow
   */
  export type SaleHeaderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    /**
     * Filter, which SaleHeader to fetch.
     */
    where: SaleHeaderWhereUniqueInput
  }


  /**
   * SaleHeader findFirst
   */
  export type SaleHeaderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    /**
     * Filter, which SaleHeader to fetch.
     */
    where?: SaleHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleHeaders to fetch.
     */
    orderBy?: SaleHeaderOrderByWithRelationInput | SaleHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleHeaders.
     */
    cursor?: SaleHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleHeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleHeaders.
     */
    distinct?: SaleHeaderScalarFieldEnum | SaleHeaderScalarFieldEnum[]
  }


  /**
   * SaleHeader findFirstOrThrow
   */
  export type SaleHeaderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    /**
     * Filter, which SaleHeader to fetch.
     */
    where?: SaleHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleHeaders to fetch.
     */
    orderBy?: SaleHeaderOrderByWithRelationInput | SaleHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleHeaders.
     */
    cursor?: SaleHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleHeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleHeaders.
     */
    distinct?: SaleHeaderScalarFieldEnum | SaleHeaderScalarFieldEnum[]
  }


  /**
   * SaleHeader findMany
   */
  export type SaleHeaderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    /**
     * Filter, which SaleHeaders to fetch.
     */
    where?: SaleHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleHeaders to fetch.
     */
    orderBy?: SaleHeaderOrderByWithRelationInput | SaleHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleHeaders.
     */
    cursor?: SaleHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleHeaders.
     */
    skip?: number
    distinct?: SaleHeaderScalarFieldEnum | SaleHeaderScalarFieldEnum[]
  }


  /**
   * SaleHeader create
   */
  export type SaleHeaderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleHeader.
     */
    data: XOR<SaleHeaderCreateInput, SaleHeaderUncheckedCreateInput>
  }


  /**
   * SaleHeader update
   */
  export type SaleHeaderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleHeader.
     */
    data: XOR<SaleHeaderUpdateInput, SaleHeaderUncheckedUpdateInput>
    /**
     * Choose, which SaleHeader to update.
     */
    where: SaleHeaderWhereUniqueInput
  }


  /**
   * SaleHeader updateMany
   */
  export type SaleHeaderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleHeaders.
     */
    data: XOR<SaleHeaderUpdateManyMutationInput, SaleHeaderUncheckedUpdateManyInput>
    /**
     * Filter which SaleHeaders to update
     */
    where?: SaleHeaderWhereInput
  }


  /**
   * SaleHeader upsert
   */
  export type SaleHeaderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleHeader to update in case it exists.
     */
    where: SaleHeaderWhereUniqueInput
    /**
     * In case the SaleHeader found by the `where` argument doesn't exist, create a new SaleHeader with this data.
     */
    create: XOR<SaleHeaderCreateInput, SaleHeaderUncheckedCreateInput>
    /**
     * In case the SaleHeader was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleHeaderUpdateInput, SaleHeaderUncheckedUpdateInput>
  }


  /**
   * SaleHeader delete
   */
  export type SaleHeaderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    /**
     * Filter which SaleHeader to delete.
     */
    where: SaleHeaderWhereUniqueInput
  }


  /**
   * SaleHeader deleteMany
   */
  export type SaleHeaderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleHeaders to delete
     */
    where?: SaleHeaderWhereInput
  }


  /**
   * SaleHeader.user
   */
  export type SaleHeader$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * SaleHeader.shift
   */
  export type SaleHeader$shiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    where?: EmployeeShiftWhereInput
  }


  /**
   * SaleHeader.customer
   */
  export type SaleHeader$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }


  /**
   * SaleHeader.details
   */
  export type SaleHeader$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDetail
     */
    select?: SaleDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleDetailInclude<ExtArgs> | null
    where?: SaleDetailWhereInput
    orderBy?: SaleDetailOrderByWithRelationInput | SaleDetailOrderByWithRelationInput[]
    cursor?: SaleDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleDetailScalarFieldEnum | SaleDetailScalarFieldEnum[]
  }


  /**
   * SaleHeader.creditPayment
   */
  export type SaleHeader$creditPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPayment
     */
    select?: CreditPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditPaymentInclude<ExtArgs> | null
    where?: CreditPaymentWhereInput
    orderBy?: CreditPaymentOrderByWithRelationInput | CreditPaymentOrderByWithRelationInput[]
    cursor?: CreditPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditPaymentScalarFieldEnum | CreditPaymentScalarFieldEnum[]
  }


  /**
   * SaleHeader without action
   */
  export type SaleHeaderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
  }



  /**
   * Model SaleDetail
   */

  export type AggregateSaleDetail = {
    _count: SaleDetailCountAggregateOutputType | null
    _avg: SaleDetailAvgAggregateOutputType | null
    _sum: SaleDetailSumAggregateOutputType | null
    _min: SaleDetailMinAggregateOutputType | null
    _max: SaleDetailMaxAggregateOutputType | null
  }

  export type SaleDetailAvgAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    subtotal: Decimal | null
  }

  export type SaleDetailSumAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    subtotal: Decimal | null
  }

  export type SaleDetailMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    productId: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    subtotal: Decimal | null
  }

  export type SaleDetailMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    productId: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    subtotal: Decimal | null
  }

  export type SaleDetailCountAggregateOutputType = {
    id: number
    saleId: number
    productId: number
    quantity: number
    unitPrice: number
    subtotal: number
    _all: number
  }


  export type SaleDetailAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type SaleDetailSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type SaleDetailMinAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type SaleDetailMaxAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type SaleDetailCountAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    _all?: true
  }

  export type SaleDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleDetail to aggregate.
     */
    where?: SaleDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleDetails to fetch.
     */
    orderBy?: SaleDetailOrderByWithRelationInput | SaleDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleDetails
    **/
    _count?: true | SaleDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleDetailMaxAggregateInputType
  }

  export type GetSaleDetailAggregateType<T extends SaleDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleDetail[P]>
      : GetScalarType<T[P], AggregateSaleDetail[P]>
  }




  export type SaleDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleDetailWhereInput
    orderBy?: SaleDetailOrderByWithAggregationInput | SaleDetailOrderByWithAggregationInput[]
    by: SaleDetailScalarFieldEnum[] | SaleDetailScalarFieldEnum
    having?: SaleDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleDetailCountAggregateInputType | true
    _avg?: SaleDetailAvgAggregateInputType
    _sum?: SaleDetailSumAggregateInputType
    _min?: SaleDetailMinAggregateInputType
    _max?: SaleDetailMaxAggregateInputType
  }

  export type SaleDetailGroupByOutputType = {
    id: string
    saleId: string
    productId: string
    quantity: Decimal
    unitPrice: Decimal
    subtotal: Decimal
    _count: SaleDetailCountAggregateOutputType | null
    _avg: SaleDetailAvgAggregateOutputType | null
    _sum: SaleDetailSumAggregateOutputType | null
    _min: SaleDetailMinAggregateOutputType | null
    _max: SaleDetailMaxAggregateOutputType | null
  }

  type GetSaleDetailGroupByPayload<T extends SaleDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleDetailGroupByOutputType[P]>
            : GetScalarType<T[P], SaleDetailGroupByOutputType[P]>
        }
      >
    >


  export type SaleDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    sale?: boolean | SaleHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleDetail"]>

  export type SaleDetailSelectScalar = {
    id?: boolean
    saleId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
  }

  export type SaleDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }


  export type $SaleDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleDetail"
    objects: {
      sale: Prisma.$SaleHeaderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      productId: string
      quantity: Prisma.Decimal
      unitPrice: Prisma.Decimal
      subtotal: Prisma.Decimal
    }, ExtArgs["result"]["saleDetail"]>
    composites: {}
  }


  type SaleDetailGetPayload<S extends boolean | null | undefined | SaleDetailDefaultArgs> = $Result.GetResult<Prisma.$SaleDetailPayload, S>

  type SaleDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleDetailCountAggregateInputType | true
    }

  export interface SaleDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleDetail'], meta: { name: 'SaleDetail' } }
    /**
     * Find zero or one SaleDetail that matches the filter.
     * @param {SaleDetailFindUniqueArgs} args - Arguments to find a SaleDetail
     * @example
     * // Get one SaleDetail
     * const saleDetail = await prisma.saleDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SaleDetailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SaleDetailFindUniqueArgs<ExtArgs>>
    ): Prisma__SaleDetailClient<$Result.GetResult<Prisma.$SaleDetailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SaleDetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SaleDetailFindUniqueOrThrowArgs} args - Arguments to find a SaleDetail
     * @example
     * // Get one SaleDetail
     * const saleDetail = await prisma.saleDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SaleDetailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleDetailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SaleDetailClient<$Result.GetResult<Prisma.$SaleDetailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SaleDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDetailFindFirstArgs} args - Arguments to find a SaleDetail
     * @example
     * // Get one SaleDetail
     * const saleDetail = await prisma.saleDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SaleDetailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleDetailFindFirstArgs<ExtArgs>>
    ): Prisma__SaleDetailClient<$Result.GetResult<Prisma.$SaleDetailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SaleDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDetailFindFirstOrThrowArgs} args - Arguments to find a SaleDetail
     * @example
     * // Get one SaleDetail
     * const saleDetail = await prisma.saleDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SaleDetailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleDetailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SaleDetailClient<$Result.GetResult<Prisma.$SaleDetailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SaleDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleDetails
     * const saleDetails = await prisma.saleDetail.findMany()
     * 
     * // Get first 10 SaleDetails
     * const saleDetails = await prisma.saleDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleDetailWithIdOnly = await prisma.saleDetail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SaleDetailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleDetailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleDetailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SaleDetail.
     * @param {SaleDetailCreateArgs} args - Arguments to create a SaleDetail.
     * @example
     * // Create one SaleDetail
     * const SaleDetail = await prisma.saleDetail.create({
     *   data: {
     *     // ... data to create a SaleDetail
     *   }
     * })
     * 
    **/
    create<T extends SaleDetailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SaleDetailCreateArgs<ExtArgs>>
    ): Prisma__SaleDetailClient<$Result.GetResult<Prisma.$SaleDetailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a SaleDetail.
     * @param {SaleDetailDeleteArgs} args - Arguments to delete one SaleDetail.
     * @example
     * // Delete one SaleDetail
     * const SaleDetail = await prisma.saleDetail.delete({
     *   where: {
     *     // ... filter to delete one SaleDetail
     *   }
     * })
     * 
    **/
    delete<T extends SaleDetailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SaleDetailDeleteArgs<ExtArgs>>
    ): Prisma__SaleDetailClient<$Result.GetResult<Prisma.$SaleDetailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SaleDetail.
     * @param {SaleDetailUpdateArgs} args - Arguments to update one SaleDetail.
     * @example
     * // Update one SaleDetail
     * const saleDetail = await prisma.saleDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SaleDetailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SaleDetailUpdateArgs<ExtArgs>>
    ): Prisma__SaleDetailClient<$Result.GetResult<Prisma.$SaleDetailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SaleDetails.
     * @param {SaleDetailDeleteManyArgs} args - Arguments to filter SaleDetails to delete.
     * @example
     * // Delete a few SaleDetails
     * const { count } = await prisma.saleDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SaleDetailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleDetailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleDetails
     * const saleDetail = await prisma.saleDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SaleDetailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SaleDetailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleDetail.
     * @param {SaleDetailUpsertArgs} args - Arguments to update or create a SaleDetail.
     * @example
     * // Update or create a SaleDetail
     * const saleDetail = await prisma.saleDetail.upsert({
     *   create: {
     *     // ... data to create a SaleDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleDetail we want to update
     *   }
     * })
    **/
    upsert<T extends SaleDetailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SaleDetailUpsertArgs<ExtArgs>>
    ): Prisma__SaleDetailClient<$Result.GetResult<Prisma.$SaleDetailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SaleDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDetailCountArgs} args - Arguments to filter SaleDetails to count.
     * @example
     * // Count the number of SaleDetails
     * const count = await prisma.saleDetail.count({
     *   where: {
     *     // ... the filter for the SaleDetails we want to count
     *   }
     * })
    **/
    count<T extends SaleDetailCountArgs>(
      args?: Subset<T, SaleDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleDetailAggregateArgs>(args: Subset<T, SaleDetailAggregateArgs>): Prisma.PrismaPromise<GetSaleDetailAggregateType<T>>

    /**
     * Group by SaleDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleDetailGroupByArgs['orderBy'] }
        : { orderBy?: SaleDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleDetail model
   */
  readonly fields: SaleDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sale<T extends SaleHeaderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleHeaderDefaultArgs<ExtArgs>>): Prisma__SaleHeaderClient<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SaleDetail model
   */ 
  interface SaleDetailFieldRefs {
    readonly id: FieldRef<"SaleDetail", 'String'>
    readonly saleId: FieldRef<"SaleDetail", 'String'>
    readonly productId: FieldRef<"SaleDetail", 'String'>
    readonly quantity: FieldRef<"SaleDetail", 'Decimal'>
    readonly unitPrice: FieldRef<"SaleDetail", 'Decimal'>
    readonly subtotal: FieldRef<"SaleDetail", 'Decimal'>
  }
    

  // Custom InputTypes

  /**
   * SaleDetail findUnique
   */
  export type SaleDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDetail
     */
    select?: SaleDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleDetailInclude<ExtArgs> | null
    /**
     * Filter, which SaleDetail to fetch.
     */
    where: SaleDetailWhereUniqueInput
  }


  /**
   * SaleDetail findUniqueOrThrow
   */
  export type SaleDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDetail
     */
    select?: SaleDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleDetailInclude<ExtArgs> | null
    /**
     * Filter, which SaleDetail to fetch.
     */
    where: SaleDetailWhereUniqueInput
  }


  /**
   * SaleDetail findFirst
   */
  export type SaleDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDetail
     */
    select?: SaleDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleDetailInclude<ExtArgs> | null
    /**
     * Filter, which SaleDetail to fetch.
     */
    where?: SaleDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleDetails to fetch.
     */
    orderBy?: SaleDetailOrderByWithRelationInput | SaleDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleDetails.
     */
    cursor?: SaleDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleDetails.
     */
    distinct?: SaleDetailScalarFieldEnum | SaleDetailScalarFieldEnum[]
  }


  /**
   * SaleDetail findFirstOrThrow
   */
  export type SaleDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDetail
     */
    select?: SaleDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleDetailInclude<ExtArgs> | null
    /**
     * Filter, which SaleDetail to fetch.
     */
    where?: SaleDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleDetails to fetch.
     */
    orderBy?: SaleDetailOrderByWithRelationInput | SaleDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleDetails.
     */
    cursor?: SaleDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleDetails.
     */
    distinct?: SaleDetailScalarFieldEnum | SaleDetailScalarFieldEnum[]
  }


  /**
   * SaleDetail findMany
   */
  export type SaleDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDetail
     */
    select?: SaleDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleDetailInclude<ExtArgs> | null
    /**
     * Filter, which SaleDetails to fetch.
     */
    where?: SaleDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleDetails to fetch.
     */
    orderBy?: SaleDetailOrderByWithRelationInput | SaleDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleDetails.
     */
    cursor?: SaleDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleDetails.
     */
    skip?: number
    distinct?: SaleDetailScalarFieldEnum | SaleDetailScalarFieldEnum[]
  }


  /**
   * SaleDetail create
   */
  export type SaleDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDetail
     */
    select?: SaleDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleDetail.
     */
    data: XOR<SaleDetailCreateInput, SaleDetailUncheckedCreateInput>
  }


  /**
   * SaleDetail update
   */
  export type SaleDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDetail
     */
    select?: SaleDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleDetail.
     */
    data: XOR<SaleDetailUpdateInput, SaleDetailUncheckedUpdateInput>
    /**
     * Choose, which SaleDetail to update.
     */
    where: SaleDetailWhereUniqueInput
  }


  /**
   * SaleDetail updateMany
   */
  export type SaleDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleDetails.
     */
    data: XOR<SaleDetailUpdateManyMutationInput, SaleDetailUncheckedUpdateManyInput>
    /**
     * Filter which SaleDetails to update
     */
    where?: SaleDetailWhereInput
  }


  /**
   * SaleDetail upsert
   */
  export type SaleDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDetail
     */
    select?: SaleDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleDetail to update in case it exists.
     */
    where: SaleDetailWhereUniqueInput
    /**
     * In case the SaleDetail found by the `where` argument doesn't exist, create a new SaleDetail with this data.
     */
    create: XOR<SaleDetailCreateInput, SaleDetailUncheckedCreateInput>
    /**
     * In case the SaleDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleDetailUpdateInput, SaleDetailUncheckedUpdateInput>
  }


  /**
   * SaleDetail delete
   */
  export type SaleDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDetail
     */
    select?: SaleDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleDetailInclude<ExtArgs> | null
    /**
     * Filter which SaleDetail to delete.
     */
    where: SaleDetailWhereUniqueInput
  }


  /**
   * SaleDetail deleteMany
   */
  export type SaleDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleDetails to delete
     */
    where?: SaleDetailWhereInput
  }


  /**
   * SaleDetail without action
   */
  export type SaleDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleDetail
     */
    select?: SaleDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleDetailInclude<ExtArgs> | null
  }



  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    date: Date | null
    amount: Decimal | null
    description: string | null
    category: string | null
    imageUrl: string | null
    branchId: string | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    amount: Decimal | null
    description: string | null
    category: string | null
    imageUrl: string | null
    branchId: string | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    date: number
    amount: number
    description: number
    category: number
    imageUrl: number
    branchId: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    description?: true
    category?: true
    imageUrl?: true
    branchId?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    description?: true
    category?: true
    imageUrl?: true
    branchId?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    description?: true
    category?: true
    imageUrl?: true
    branchId?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    date: Date
    amount: Decimal
    description: string
    category: string
    imageUrl: string | null
    branchId: string
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    amount?: boolean
    description?: boolean
    category?: boolean
    imageUrl?: boolean
    branchId?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    date?: boolean
    amount?: boolean
    description?: boolean
    category?: boolean
    imageUrl?: boolean
    branchId?: boolean
  }

  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }


  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      amount: Prisma.Decimal
      description: string
      category: string
      imageUrl: string | null
      branchId: string
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }


  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExpenseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Expense that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExpenseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExpenseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
    **/
    create<T extends ExpenseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
    **/
    delete<T extends ExpenseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExpenseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExpenseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExpenseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
    **/
    upsert<T extends ExpenseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Expense model
   */ 
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly amount: FieldRef<"Expense", 'Decimal'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly category: FieldRef<"Expense", 'String'>
    readonly imageUrl: FieldRef<"Expense", 'String'>
    readonly branchId: FieldRef<"Expense", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }


  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }


  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }


  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }


  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }


  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }


  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }


  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
  }


  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }


  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }


  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
  }


  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExpenseInclude<ExtArgs> | null
  }



  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    total: Decimal | null
  }

  export type PurchaseSumAggregateOutputType = {
    total: Decimal | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    date: Date | null
    total: Decimal | null
    status: string | null
    providerId: string | null
    branchId: string | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    total: Decimal | null
    status: string | null
    providerId: string | null
    branchId: string | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    date: number
    total: number
    status: number
    providerId: number
    branchId: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    total?: true
  }

  export type PurchaseSumAggregateInputType = {
    total?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    date?: true
    total?: true
    status?: true
    providerId?: true
    branchId?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    date?: true
    total?: true
    status?: true
    providerId?: true
    branchId?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    date?: true
    total?: true
    status?: true
    providerId?: true
    branchId?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    date: Date
    total: Decimal
    status: string
    providerId: string
    branchId: string
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    total?: boolean
    status?: boolean
    providerId?: boolean
    branchId?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    date?: boolean
    total?: boolean
    status?: boolean
    providerId?: boolean
    branchId?: boolean
  }

  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }


  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      total: Prisma.Decimal
      status: string
      providerId: string
      branchId: string
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }


  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PurchaseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>
    ): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Purchase that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PurchaseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>
    ): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PurchaseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
    **/
    create<T extends PurchaseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>
    ): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
    **/
    delete<T extends PurchaseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>
    ): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PurchaseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>
    ): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PurchaseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PurchaseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
    **/
    upsert<T extends PurchaseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>
    ): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Purchase model
   */ 
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly date: FieldRef<"Purchase", 'DateTime'>
    readonly total: FieldRef<"Purchase", 'Decimal'>
    readonly status: FieldRef<"Purchase", 'String'>
    readonly providerId: FieldRef<"Purchase", 'String'>
    readonly branchId: FieldRef<"Purchase", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }


  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }


  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }


  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }


  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }


  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }


  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }


  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
  }


  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }


  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }


  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
  }


  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseInclude<ExtArgs> | null
  }



  /**
   * Model CreditPayment
   */

  export type AggregateCreditPayment = {
    _count: CreditPaymentCountAggregateOutputType | null
    _avg: CreditPaymentAvgAggregateOutputType | null
    _sum: CreditPaymentSumAggregateOutputType | null
    _min: CreditPaymentMinAggregateOutputType | null
    _max: CreditPaymentMaxAggregateOutputType | null
  }

  export type CreditPaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type CreditPaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type CreditPaymentMinAggregateOutputType = {
    id: string | null
    date: Date | null
    amount: Decimal | null
    paymentMethod: string | null
    customerId: string | null
    saleId: string | null
  }

  export type CreditPaymentMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    amount: Decimal | null
    paymentMethod: string | null
    customerId: string | null
    saleId: string | null
  }

  export type CreditPaymentCountAggregateOutputType = {
    id: number
    date: number
    amount: number
    paymentMethod: number
    customerId: number
    saleId: number
    _all: number
  }


  export type CreditPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type CreditPaymentSumAggregateInputType = {
    amount?: true
  }

  export type CreditPaymentMinAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    paymentMethod?: true
    customerId?: true
    saleId?: true
  }

  export type CreditPaymentMaxAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    paymentMethod?: true
    customerId?: true
    saleId?: true
  }

  export type CreditPaymentCountAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    paymentMethod?: true
    customerId?: true
    saleId?: true
    _all?: true
  }

  export type CreditPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditPayment to aggregate.
     */
    where?: CreditPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPayments to fetch.
     */
    orderBy?: CreditPaymentOrderByWithRelationInput | CreditPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditPayments
    **/
    _count?: true | CreditPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditPaymentMaxAggregateInputType
  }

  export type GetCreditPaymentAggregateType<T extends CreditPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditPayment[P]>
      : GetScalarType<T[P], AggregateCreditPayment[P]>
  }




  export type CreditPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditPaymentWhereInput
    orderBy?: CreditPaymentOrderByWithAggregationInput | CreditPaymentOrderByWithAggregationInput[]
    by: CreditPaymentScalarFieldEnum[] | CreditPaymentScalarFieldEnum
    having?: CreditPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditPaymentCountAggregateInputType | true
    _avg?: CreditPaymentAvgAggregateInputType
    _sum?: CreditPaymentSumAggregateInputType
    _min?: CreditPaymentMinAggregateInputType
    _max?: CreditPaymentMaxAggregateInputType
  }

  export type CreditPaymentGroupByOutputType = {
    id: string
    date: Date
    amount: Decimal
    paymentMethod: string
    customerId: string
    saleId: string | null
    _count: CreditPaymentCountAggregateOutputType | null
    _avg: CreditPaymentAvgAggregateOutputType | null
    _sum: CreditPaymentSumAggregateOutputType | null
    _min: CreditPaymentMinAggregateOutputType | null
    _max: CreditPaymentMaxAggregateOutputType | null
  }

  type GetCreditPaymentGroupByPayload<T extends CreditPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], CreditPaymentGroupByOutputType[P]>
        }
      >
    >


  export type CreditPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    amount?: boolean
    paymentMethod?: boolean
    customerId?: boolean
    saleId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    sale?: boolean | CreditPayment$saleArgs<ExtArgs>
  }, ExtArgs["result"]["creditPayment"]>

  export type CreditPaymentSelectScalar = {
    id?: boolean
    date?: boolean
    amount?: boolean
    paymentMethod?: boolean
    customerId?: boolean
    saleId?: boolean
  }

  export type CreditPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    sale?: boolean | CreditPayment$saleArgs<ExtArgs>
  }


  export type $CreditPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditPayment"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      sale: Prisma.$SaleHeaderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      amount: Prisma.Decimal
      paymentMethod: string
      customerId: string
      saleId: string | null
    }, ExtArgs["result"]["creditPayment"]>
    composites: {}
  }


  type CreditPaymentGetPayload<S extends boolean | null | undefined | CreditPaymentDefaultArgs> = $Result.GetResult<Prisma.$CreditPaymentPayload, S>

  type CreditPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreditPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreditPaymentCountAggregateInputType | true
    }

  export interface CreditPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditPayment'], meta: { name: 'CreditPayment' } }
    /**
     * Find zero or one CreditPayment that matches the filter.
     * @param {CreditPaymentFindUniqueArgs} args - Arguments to find a CreditPayment
     * @example
     * // Get one CreditPayment
     * const creditPayment = await prisma.creditPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CreditPaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CreditPaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__CreditPaymentClient<$Result.GetResult<Prisma.$CreditPaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CreditPayment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CreditPaymentFindUniqueOrThrowArgs} args - Arguments to find a CreditPayment
     * @example
     * // Get one CreditPayment
     * const creditPayment = await prisma.creditPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CreditPaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CreditPaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CreditPaymentClient<$Result.GetResult<Prisma.$CreditPaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CreditPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPaymentFindFirstArgs} args - Arguments to find a CreditPayment
     * @example
     * // Get one CreditPayment
     * const creditPayment = await prisma.creditPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CreditPaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CreditPaymentFindFirstArgs<ExtArgs>>
    ): Prisma__CreditPaymentClient<$Result.GetResult<Prisma.$CreditPaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CreditPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPaymentFindFirstOrThrowArgs} args - Arguments to find a CreditPayment
     * @example
     * // Get one CreditPayment
     * const creditPayment = await prisma.creditPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CreditPaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CreditPaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CreditPaymentClient<$Result.GetResult<Prisma.$CreditPaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CreditPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditPayments
     * const creditPayments = await prisma.creditPayment.findMany()
     * 
     * // Get first 10 CreditPayments
     * const creditPayments = await prisma.creditPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditPaymentWithIdOnly = await prisma.creditPayment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CreditPaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CreditPaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CreditPayment.
     * @param {CreditPaymentCreateArgs} args - Arguments to create a CreditPayment.
     * @example
     * // Create one CreditPayment
     * const CreditPayment = await prisma.creditPayment.create({
     *   data: {
     *     // ... data to create a CreditPayment
     *   }
     * })
     * 
    **/
    create<T extends CreditPaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CreditPaymentCreateArgs<ExtArgs>>
    ): Prisma__CreditPaymentClient<$Result.GetResult<Prisma.$CreditPaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a CreditPayment.
     * @param {CreditPaymentDeleteArgs} args - Arguments to delete one CreditPayment.
     * @example
     * // Delete one CreditPayment
     * const CreditPayment = await prisma.creditPayment.delete({
     *   where: {
     *     // ... filter to delete one CreditPayment
     *   }
     * })
     * 
    **/
    delete<T extends CreditPaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CreditPaymentDeleteArgs<ExtArgs>>
    ): Prisma__CreditPaymentClient<$Result.GetResult<Prisma.$CreditPaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CreditPayment.
     * @param {CreditPaymentUpdateArgs} args - Arguments to update one CreditPayment.
     * @example
     * // Update one CreditPayment
     * const creditPayment = await prisma.creditPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CreditPaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CreditPaymentUpdateArgs<ExtArgs>>
    ): Prisma__CreditPaymentClient<$Result.GetResult<Prisma.$CreditPaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CreditPayments.
     * @param {CreditPaymentDeleteManyArgs} args - Arguments to filter CreditPayments to delete.
     * @example
     * // Delete a few CreditPayments
     * const { count } = await prisma.creditPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CreditPaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CreditPaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditPayments
     * const creditPayment = await prisma.creditPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CreditPaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CreditPaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CreditPayment.
     * @param {CreditPaymentUpsertArgs} args - Arguments to update or create a CreditPayment.
     * @example
     * // Update or create a CreditPayment
     * const creditPayment = await prisma.creditPayment.upsert({
     *   create: {
     *     // ... data to create a CreditPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditPayment we want to update
     *   }
     * })
    **/
    upsert<T extends CreditPaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CreditPaymentUpsertArgs<ExtArgs>>
    ): Prisma__CreditPaymentClient<$Result.GetResult<Prisma.$CreditPaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CreditPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPaymentCountArgs} args - Arguments to filter CreditPayments to count.
     * @example
     * // Count the number of CreditPayments
     * const count = await prisma.creditPayment.count({
     *   where: {
     *     // ... the filter for the CreditPayments we want to count
     *   }
     * })
    **/
    count<T extends CreditPaymentCountArgs>(
      args?: Subset<T, CreditPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditPaymentAggregateArgs>(args: Subset<T, CreditPaymentAggregateArgs>): Prisma.PrismaPromise<GetCreditPaymentAggregateType<T>>

    /**
     * Group by CreditPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditPaymentGroupByArgs['orderBy'] }
        : { orderBy?: CreditPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditPayment model
   */
  readonly fields: CreditPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sale<T extends CreditPayment$saleArgs<ExtArgs> = {}>(args?: Subset<T, CreditPayment$saleArgs<ExtArgs>>): Prisma__SaleHeaderClient<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CreditPayment model
   */ 
  interface CreditPaymentFieldRefs {
    readonly id: FieldRef<"CreditPayment", 'String'>
    readonly date: FieldRef<"CreditPayment", 'DateTime'>
    readonly amount: FieldRef<"CreditPayment", 'Decimal'>
    readonly paymentMethod: FieldRef<"CreditPayment", 'String'>
    readonly customerId: FieldRef<"CreditPayment", 'String'>
    readonly saleId: FieldRef<"CreditPayment", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CreditPayment findUnique
   */
  export type CreditPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPayment
     */
    select?: CreditPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CreditPayment to fetch.
     */
    where: CreditPaymentWhereUniqueInput
  }


  /**
   * CreditPayment findUniqueOrThrow
   */
  export type CreditPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPayment
     */
    select?: CreditPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CreditPayment to fetch.
     */
    where: CreditPaymentWhereUniqueInput
  }


  /**
   * CreditPayment findFirst
   */
  export type CreditPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPayment
     */
    select?: CreditPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CreditPayment to fetch.
     */
    where?: CreditPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPayments to fetch.
     */
    orderBy?: CreditPaymentOrderByWithRelationInput | CreditPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditPayments.
     */
    cursor?: CreditPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditPayments.
     */
    distinct?: CreditPaymentScalarFieldEnum | CreditPaymentScalarFieldEnum[]
  }


  /**
   * CreditPayment findFirstOrThrow
   */
  export type CreditPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPayment
     */
    select?: CreditPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CreditPayment to fetch.
     */
    where?: CreditPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPayments to fetch.
     */
    orderBy?: CreditPaymentOrderByWithRelationInput | CreditPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditPayments.
     */
    cursor?: CreditPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditPayments.
     */
    distinct?: CreditPaymentScalarFieldEnum | CreditPaymentScalarFieldEnum[]
  }


  /**
   * CreditPayment findMany
   */
  export type CreditPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPayment
     */
    select?: CreditPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CreditPayments to fetch.
     */
    where?: CreditPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPayments to fetch.
     */
    orderBy?: CreditPaymentOrderByWithRelationInput | CreditPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditPayments.
     */
    cursor?: CreditPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPayments.
     */
    skip?: number
    distinct?: CreditPaymentScalarFieldEnum | CreditPaymentScalarFieldEnum[]
  }


  /**
   * CreditPayment create
   */
  export type CreditPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPayment
     */
    select?: CreditPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditPayment.
     */
    data: XOR<CreditPaymentCreateInput, CreditPaymentUncheckedCreateInput>
  }


  /**
   * CreditPayment update
   */
  export type CreditPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPayment
     */
    select?: CreditPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditPayment.
     */
    data: XOR<CreditPaymentUpdateInput, CreditPaymentUncheckedUpdateInput>
    /**
     * Choose, which CreditPayment to update.
     */
    where: CreditPaymentWhereUniqueInput
  }


  /**
   * CreditPayment updateMany
   */
  export type CreditPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditPayments.
     */
    data: XOR<CreditPaymentUpdateManyMutationInput, CreditPaymentUncheckedUpdateManyInput>
    /**
     * Filter which CreditPayments to update
     */
    where?: CreditPaymentWhereInput
  }


  /**
   * CreditPayment upsert
   */
  export type CreditPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPayment
     */
    select?: CreditPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditPayment to update in case it exists.
     */
    where: CreditPaymentWhereUniqueInput
    /**
     * In case the CreditPayment found by the `where` argument doesn't exist, create a new CreditPayment with this data.
     */
    create: XOR<CreditPaymentCreateInput, CreditPaymentUncheckedCreateInput>
    /**
     * In case the CreditPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditPaymentUpdateInput, CreditPaymentUncheckedUpdateInput>
  }


  /**
   * CreditPayment delete
   */
  export type CreditPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPayment
     */
    select?: CreditPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditPaymentInclude<ExtArgs> | null
    /**
     * Filter which CreditPayment to delete.
     */
    where: CreditPaymentWhereUniqueInput
  }


  /**
   * CreditPayment deleteMany
   */
  export type CreditPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditPayments to delete
     */
    where?: CreditPaymentWhereInput
  }


  /**
   * CreditPayment.sale
   */
  export type CreditPayment$saleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    where?: SaleHeaderWhereInput
  }


  /**
   * CreditPayment without action
   */
  export type CreditPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPayment
     */
    select?: CreditPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditPaymentInclude<ExtArgs> | null
  }



  /**
   * Model EmployeeShift
   */

  export type AggregateEmployeeShift = {
    _count: EmployeeShiftCountAggregateOutputType | null
    _avg: EmployeeShiftAvgAggregateOutputType | null
    _sum: EmployeeShiftSumAggregateOutputType | null
    _min: EmployeeShiftMinAggregateOutputType | null
    _max: EmployeeShiftMaxAggregateOutputType | null
  }

  export type EmployeeShiftAvgAggregateOutputType = {
    initialCash: Decimal | null
    finalCashExpected: Decimal | null
    finalCashActual: Decimal | null
    difference: Decimal | null
  }

  export type EmployeeShiftSumAggregateOutputType = {
    initialCash: Decimal | null
    finalCashExpected: Decimal | null
    finalCashActual: Decimal | null
    difference: Decimal | null
  }

  export type EmployeeShiftMinAggregateOutputType = {
    id: string | null
    userId: string | null
    startTime: Date | null
    endTime: Date | null
    initialCash: Decimal | null
    finalCashExpected: Decimal | null
    finalCashActual: Decimal | null
    difference: Decimal | null
  }

  export type EmployeeShiftMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    startTime: Date | null
    endTime: Date | null
    initialCash: Decimal | null
    finalCashExpected: Decimal | null
    finalCashActual: Decimal | null
    difference: Decimal | null
  }

  export type EmployeeShiftCountAggregateOutputType = {
    id: number
    userId: number
    startTime: number
    endTime: number
    initialCash: number
    finalCashExpected: number
    finalCashActual: number
    difference: number
    _all: number
  }


  export type EmployeeShiftAvgAggregateInputType = {
    initialCash?: true
    finalCashExpected?: true
    finalCashActual?: true
    difference?: true
  }

  export type EmployeeShiftSumAggregateInputType = {
    initialCash?: true
    finalCashExpected?: true
    finalCashActual?: true
    difference?: true
  }

  export type EmployeeShiftMinAggregateInputType = {
    id?: true
    userId?: true
    startTime?: true
    endTime?: true
    initialCash?: true
    finalCashExpected?: true
    finalCashActual?: true
    difference?: true
  }

  export type EmployeeShiftMaxAggregateInputType = {
    id?: true
    userId?: true
    startTime?: true
    endTime?: true
    initialCash?: true
    finalCashExpected?: true
    finalCashActual?: true
    difference?: true
  }

  export type EmployeeShiftCountAggregateInputType = {
    id?: true
    userId?: true
    startTime?: true
    endTime?: true
    initialCash?: true
    finalCashExpected?: true
    finalCashActual?: true
    difference?: true
    _all?: true
  }

  export type EmployeeShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeShift to aggregate.
     */
    where?: EmployeeShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeShifts to fetch.
     */
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeShifts
    **/
    _count?: true | EmployeeShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeShiftMaxAggregateInputType
  }

  export type GetEmployeeShiftAggregateType<T extends EmployeeShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeShift[P]>
      : GetScalarType<T[P], AggregateEmployeeShift[P]>
  }




  export type EmployeeShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeShiftWhereInput
    orderBy?: EmployeeShiftOrderByWithAggregationInput | EmployeeShiftOrderByWithAggregationInput[]
    by: EmployeeShiftScalarFieldEnum[] | EmployeeShiftScalarFieldEnum
    having?: EmployeeShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeShiftCountAggregateInputType | true
    _avg?: EmployeeShiftAvgAggregateInputType
    _sum?: EmployeeShiftSumAggregateInputType
    _min?: EmployeeShiftMinAggregateInputType
    _max?: EmployeeShiftMaxAggregateInputType
  }

  export type EmployeeShiftGroupByOutputType = {
    id: string
    userId: string
    startTime: Date
    endTime: Date | null
    initialCash: Decimal
    finalCashExpected: Decimal | null
    finalCashActual: Decimal | null
    difference: Decimal | null
    _count: EmployeeShiftCountAggregateOutputType | null
    _avg: EmployeeShiftAvgAggregateOutputType | null
    _sum: EmployeeShiftSumAggregateOutputType | null
    _min: EmployeeShiftMinAggregateOutputType | null
    _max: EmployeeShiftMaxAggregateOutputType | null
  }

  type GetEmployeeShiftGroupByPayload<T extends EmployeeShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeShiftGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeShiftGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    initialCash?: boolean
    finalCashExpected?: boolean
    finalCashActual?: boolean
    difference?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cashCounts?: boolean | EmployeeShift$cashCountsArgs<ExtArgs>
    sales?: boolean | EmployeeShift$salesArgs<ExtArgs>
    _count?: boolean | EmployeeShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeShift"]>

  export type EmployeeShiftSelectScalar = {
    id?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    initialCash?: boolean
    finalCashExpected?: boolean
    finalCashActual?: boolean
    difference?: boolean
  }

  export type EmployeeShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cashCounts?: boolean | EmployeeShift$cashCountsArgs<ExtArgs>
    sales?: boolean | EmployeeShift$salesArgs<ExtArgs>
    _count?: boolean | EmployeeShiftCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EmployeeShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeShift"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      cashCounts: Prisma.$CashCountPayload<ExtArgs>[]
      sales: Prisma.$SaleHeaderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      startTime: Date
      endTime: Date | null
      initialCash: Prisma.Decimal
      finalCashExpected: Prisma.Decimal | null
      finalCashActual: Prisma.Decimal | null
      difference: Prisma.Decimal | null
    }, ExtArgs["result"]["employeeShift"]>
    composites: {}
  }


  type EmployeeShiftGetPayload<S extends boolean | null | undefined | EmployeeShiftDefaultArgs> = $Result.GetResult<Prisma.$EmployeeShiftPayload, S>

  type EmployeeShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeShiftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeShiftCountAggregateInputType | true
    }

  export interface EmployeeShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeShift'], meta: { name: 'EmployeeShift' } }
    /**
     * Find zero or one EmployeeShift that matches the filter.
     * @param {EmployeeShiftFindUniqueArgs} args - Arguments to find a EmployeeShift
     * @example
     * // Get one EmployeeShift
     * const employeeShift = await prisma.employeeShift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmployeeShiftFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmployeeShiftFindUniqueArgs<ExtArgs>>
    ): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmployeeShift that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmployeeShiftFindUniqueOrThrowArgs} args - Arguments to find a EmployeeShift
     * @example
     * // Get one EmployeeShift
     * const employeeShift = await prisma.employeeShift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmployeeShiftFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmployeeShiftFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmployeeShift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftFindFirstArgs} args - Arguments to find a EmployeeShift
     * @example
     * // Get one EmployeeShift
     * const employeeShift = await prisma.employeeShift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmployeeShiftFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmployeeShiftFindFirstArgs<ExtArgs>>
    ): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmployeeShift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftFindFirstOrThrowArgs} args - Arguments to find a EmployeeShift
     * @example
     * // Get one EmployeeShift
     * const employeeShift = await prisma.employeeShift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmployeeShiftFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmployeeShiftFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmployeeShifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeShifts
     * const employeeShifts = await prisma.employeeShift.findMany()
     * 
     * // Get first 10 EmployeeShifts
     * const employeeShifts = await prisma.employeeShift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeShiftWithIdOnly = await prisma.employeeShift.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmployeeShiftFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmployeeShiftFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmployeeShift.
     * @param {EmployeeShiftCreateArgs} args - Arguments to create a EmployeeShift.
     * @example
     * // Create one EmployeeShift
     * const EmployeeShift = await prisma.employeeShift.create({
     *   data: {
     *     // ... data to create a EmployeeShift
     *   }
     * })
     * 
    **/
    create<T extends EmployeeShiftCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmployeeShiftCreateArgs<ExtArgs>>
    ): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a EmployeeShift.
     * @param {EmployeeShiftDeleteArgs} args - Arguments to delete one EmployeeShift.
     * @example
     * // Delete one EmployeeShift
     * const EmployeeShift = await prisma.employeeShift.delete({
     *   where: {
     *     // ... filter to delete one EmployeeShift
     *   }
     * })
     * 
    **/
    delete<T extends EmployeeShiftDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmployeeShiftDeleteArgs<ExtArgs>>
    ): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmployeeShift.
     * @param {EmployeeShiftUpdateArgs} args - Arguments to update one EmployeeShift.
     * @example
     * // Update one EmployeeShift
     * const employeeShift = await prisma.employeeShift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmployeeShiftUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmployeeShiftUpdateArgs<ExtArgs>>
    ): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmployeeShifts.
     * @param {EmployeeShiftDeleteManyArgs} args - Arguments to filter EmployeeShifts to delete.
     * @example
     * // Delete a few EmployeeShifts
     * const { count } = await prisma.employeeShift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmployeeShiftDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmployeeShiftDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeShifts
     * const employeeShift = await prisma.employeeShift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmployeeShiftUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmployeeShiftUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeShift.
     * @param {EmployeeShiftUpsertArgs} args - Arguments to update or create a EmployeeShift.
     * @example
     * // Update or create a EmployeeShift
     * const employeeShift = await prisma.employeeShift.upsert({
     *   create: {
     *     // ... data to create a EmployeeShift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeShift we want to update
     *   }
     * })
    **/
    upsert<T extends EmployeeShiftUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmployeeShiftUpsertArgs<ExtArgs>>
    ): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmployeeShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftCountArgs} args - Arguments to filter EmployeeShifts to count.
     * @example
     * // Count the number of EmployeeShifts
     * const count = await prisma.employeeShift.count({
     *   where: {
     *     // ... the filter for the EmployeeShifts we want to count
     *   }
     * })
    **/
    count<T extends EmployeeShiftCountArgs>(
      args?: Subset<T, EmployeeShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeShiftAggregateArgs>(args: Subset<T, EmployeeShiftAggregateArgs>): Prisma.PrismaPromise<GetEmployeeShiftAggregateType<T>>

    /**
     * Group by EmployeeShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeShiftGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeShift model
   */
  readonly fields: EmployeeShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeShift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    cashCounts<T extends EmployeeShift$cashCountsArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeShift$cashCountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashCountPayload<ExtArgs>, T, 'findMany'> | Null>;

    sales<T extends EmployeeShift$salesArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeShift$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleHeaderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmployeeShift model
   */ 
  interface EmployeeShiftFieldRefs {
    readonly id: FieldRef<"EmployeeShift", 'String'>
    readonly userId: FieldRef<"EmployeeShift", 'String'>
    readonly startTime: FieldRef<"EmployeeShift", 'DateTime'>
    readonly endTime: FieldRef<"EmployeeShift", 'DateTime'>
    readonly initialCash: FieldRef<"EmployeeShift", 'Decimal'>
    readonly finalCashExpected: FieldRef<"EmployeeShift", 'Decimal'>
    readonly finalCashActual: FieldRef<"EmployeeShift", 'Decimal'>
    readonly difference: FieldRef<"EmployeeShift", 'Decimal'>
  }
    

  // Custom InputTypes

  /**
   * EmployeeShift findUnique
   */
  export type EmployeeShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShift to fetch.
     */
    where: EmployeeShiftWhereUniqueInput
  }


  /**
   * EmployeeShift findUniqueOrThrow
   */
  export type EmployeeShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShift to fetch.
     */
    where: EmployeeShiftWhereUniqueInput
  }


  /**
   * EmployeeShift findFirst
   */
  export type EmployeeShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShift to fetch.
     */
    where?: EmployeeShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeShifts to fetch.
     */
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeShifts.
     */
    cursor?: EmployeeShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeShifts.
     */
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }


  /**
   * EmployeeShift findFirstOrThrow
   */
  export type EmployeeShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShift to fetch.
     */
    where?: EmployeeShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeShifts to fetch.
     */
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeShifts.
     */
    cursor?: EmployeeShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeShifts.
     */
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }


  /**
   * EmployeeShift findMany
   */
  export type EmployeeShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShifts to fetch.
     */
    where?: EmployeeShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeShifts to fetch.
     */
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeShifts.
     */
    cursor?: EmployeeShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeShifts.
     */
    skip?: number
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }


  /**
   * EmployeeShift create
   */
  export type EmployeeShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeShift.
     */
    data: XOR<EmployeeShiftCreateInput, EmployeeShiftUncheckedCreateInput>
  }


  /**
   * EmployeeShift update
   */
  export type EmployeeShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeShift.
     */
    data: XOR<EmployeeShiftUpdateInput, EmployeeShiftUncheckedUpdateInput>
    /**
     * Choose, which EmployeeShift to update.
     */
    where: EmployeeShiftWhereUniqueInput
  }


  /**
   * EmployeeShift updateMany
   */
  export type EmployeeShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeShifts.
     */
    data: XOR<EmployeeShiftUpdateManyMutationInput, EmployeeShiftUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeShifts to update
     */
    where?: EmployeeShiftWhereInput
  }


  /**
   * EmployeeShift upsert
   */
  export type EmployeeShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeShift to update in case it exists.
     */
    where: EmployeeShiftWhereUniqueInput
    /**
     * In case the EmployeeShift found by the `where` argument doesn't exist, create a new EmployeeShift with this data.
     */
    create: XOR<EmployeeShiftCreateInput, EmployeeShiftUncheckedCreateInput>
    /**
     * In case the EmployeeShift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeShiftUpdateInput, EmployeeShiftUncheckedUpdateInput>
  }


  /**
   * EmployeeShift delete
   */
  export type EmployeeShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter which EmployeeShift to delete.
     */
    where: EmployeeShiftWhereUniqueInput
  }


  /**
   * EmployeeShift deleteMany
   */
  export type EmployeeShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeShifts to delete
     */
    where?: EmployeeShiftWhereInput
  }


  /**
   * EmployeeShift.cashCounts
   */
  export type EmployeeShift$cashCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCount
     */
    select?: CashCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashCountInclude<ExtArgs> | null
    where?: CashCountWhereInput
    orderBy?: CashCountOrderByWithRelationInput | CashCountOrderByWithRelationInput[]
    cursor?: CashCountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashCountScalarFieldEnum | CashCountScalarFieldEnum[]
  }


  /**
   * EmployeeShift.sales
   */
  export type EmployeeShift$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleHeader
     */
    select?: SaleHeaderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleHeaderInclude<ExtArgs> | null
    where?: SaleHeaderWhereInput
    orderBy?: SaleHeaderOrderByWithRelationInput | SaleHeaderOrderByWithRelationInput[]
    cursor?: SaleHeaderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleHeaderScalarFieldEnum | SaleHeaderScalarFieldEnum[]
  }


  /**
   * EmployeeShift without action
   */
  export type EmployeeShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
  }



  /**
   * Model CashCount
   */

  export type AggregateCashCount = {
    _count: CashCountCountAggregateOutputType | null
    _avg: CashCountAvgAggregateOutputType | null
    _sum: CashCountSumAggregateOutputType | null
    _min: CashCountMinAggregateOutputType | null
    _max: CashCountMaxAggregateOutputType | null
  }

  export type CashCountAvgAggregateOutputType = {
    denomination: Decimal | null
    quantity: number | null
  }

  export type CashCountSumAggregateOutputType = {
    denomination: Decimal | null
    quantity: number | null
  }

  export type CashCountMinAggregateOutputType = {
    id: string | null
    shiftId: string | null
    denomination: Decimal | null
    quantity: number | null
    type: string | null
  }

  export type CashCountMaxAggregateOutputType = {
    id: string | null
    shiftId: string | null
    denomination: Decimal | null
    quantity: number | null
    type: string | null
  }

  export type CashCountCountAggregateOutputType = {
    id: number
    shiftId: number
    denomination: number
    quantity: number
    type: number
    _all: number
  }


  export type CashCountAvgAggregateInputType = {
    denomination?: true
    quantity?: true
  }

  export type CashCountSumAggregateInputType = {
    denomination?: true
    quantity?: true
  }

  export type CashCountMinAggregateInputType = {
    id?: true
    shiftId?: true
    denomination?: true
    quantity?: true
    type?: true
  }

  export type CashCountMaxAggregateInputType = {
    id?: true
    shiftId?: true
    denomination?: true
    quantity?: true
    type?: true
  }

  export type CashCountCountAggregateInputType = {
    id?: true
    shiftId?: true
    denomination?: true
    quantity?: true
    type?: true
    _all?: true
  }

  export type CashCountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashCount to aggregate.
     */
    where?: CashCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashCounts to fetch.
     */
    orderBy?: CashCountOrderByWithRelationInput | CashCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashCounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashCounts
    **/
    _count?: true | CashCountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashCountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashCountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashCountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashCountMaxAggregateInputType
  }

  export type GetCashCountAggregateType<T extends CashCountAggregateArgs> = {
        [P in keyof T & keyof AggregateCashCount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashCount[P]>
      : GetScalarType<T[P], AggregateCashCount[P]>
  }




  export type CashCountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashCountWhereInput
    orderBy?: CashCountOrderByWithAggregationInput | CashCountOrderByWithAggregationInput[]
    by: CashCountScalarFieldEnum[] | CashCountScalarFieldEnum
    having?: CashCountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashCountCountAggregateInputType | true
    _avg?: CashCountAvgAggregateInputType
    _sum?: CashCountSumAggregateInputType
    _min?: CashCountMinAggregateInputType
    _max?: CashCountMaxAggregateInputType
  }

  export type CashCountGroupByOutputType = {
    id: string
    shiftId: string
    denomination: Decimal
    quantity: number
    type: string
    _count: CashCountCountAggregateOutputType | null
    _avg: CashCountAvgAggregateOutputType | null
    _sum: CashCountSumAggregateOutputType | null
    _min: CashCountMinAggregateOutputType | null
    _max: CashCountMaxAggregateOutputType | null
  }

  type GetCashCountGroupByPayload<T extends CashCountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashCountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashCountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashCountGroupByOutputType[P]>
            : GetScalarType<T[P], CashCountGroupByOutputType[P]>
        }
      >
    >


  export type CashCountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shiftId?: boolean
    denomination?: boolean
    quantity?: boolean
    type?: boolean
    shift?: boolean | EmployeeShiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashCount"]>

  export type CashCountSelectScalar = {
    id?: boolean
    shiftId?: boolean
    denomination?: boolean
    quantity?: boolean
    type?: boolean
  }

  export type CashCountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shift?: boolean | EmployeeShiftDefaultArgs<ExtArgs>
  }


  export type $CashCountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashCount"
    objects: {
      shift: Prisma.$EmployeeShiftPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shiftId: string
      denomination: Prisma.Decimal
      quantity: number
      type: string
    }, ExtArgs["result"]["cashCount"]>
    composites: {}
  }


  type CashCountGetPayload<S extends boolean | null | undefined | CashCountDefaultArgs> = $Result.GetResult<Prisma.$CashCountPayload, S>

  type CashCountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashCountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CashCountCountAggregateInputType | true
    }

  export interface CashCountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashCount'], meta: { name: 'CashCount' } }
    /**
     * Find zero or one CashCount that matches the filter.
     * @param {CashCountFindUniqueArgs} args - Arguments to find a CashCount
     * @example
     * // Get one CashCount
     * const cashCount = await prisma.cashCount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CashCountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CashCountFindUniqueArgs<ExtArgs>>
    ): Prisma__CashCountClient<$Result.GetResult<Prisma.$CashCountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CashCount that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CashCountFindUniqueOrThrowArgs} args - Arguments to find a CashCount
     * @example
     * // Get one CashCount
     * const cashCount = await prisma.cashCount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CashCountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CashCountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CashCountClient<$Result.GetResult<Prisma.$CashCountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CashCount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCountFindFirstArgs} args - Arguments to find a CashCount
     * @example
     * // Get one CashCount
     * const cashCount = await prisma.cashCount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CashCountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CashCountFindFirstArgs<ExtArgs>>
    ): Prisma__CashCountClient<$Result.GetResult<Prisma.$CashCountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CashCount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCountFindFirstOrThrowArgs} args - Arguments to find a CashCount
     * @example
     * // Get one CashCount
     * const cashCount = await prisma.cashCount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CashCountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CashCountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CashCountClient<$Result.GetResult<Prisma.$CashCountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CashCounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashCounts
     * const cashCounts = await prisma.cashCount.findMany()
     * 
     * // Get first 10 CashCounts
     * const cashCounts = await prisma.cashCount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashCountWithIdOnly = await prisma.cashCount.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CashCountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashCountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashCountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CashCount.
     * @param {CashCountCreateArgs} args - Arguments to create a CashCount.
     * @example
     * // Create one CashCount
     * const CashCount = await prisma.cashCount.create({
     *   data: {
     *     // ... data to create a CashCount
     *   }
     * })
     * 
    **/
    create<T extends CashCountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CashCountCreateArgs<ExtArgs>>
    ): Prisma__CashCountClient<$Result.GetResult<Prisma.$CashCountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a CashCount.
     * @param {CashCountDeleteArgs} args - Arguments to delete one CashCount.
     * @example
     * // Delete one CashCount
     * const CashCount = await prisma.cashCount.delete({
     *   where: {
     *     // ... filter to delete one CashCount
     *   }
     * })
     * 
    **/
    delete<T extends CashCountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CashCountDeleteArgs<ExtArgs>>
    ): Prisma__CashCountClient<$Result.GetResult<Prisma.$CashCountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CashCount.
     * @param {CashCountUpdateArgs} args - Arguments to update one CashCount.
     * @example
     * // Update one CashCount
     * const cashCount = await prisma.cashCount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CashCountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CashCountUpdateArgs<ExtArgs>>
    ): Prisma__CashCountClient<$Result.GetResult<Prisma.$CashCountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CashCounts.
     * @param {CashCountDeleteManyArgs} args - Arguments to filter CashCounts to delete.
     * @example
     * // Delete a few CashCounts
     * const { count } = await prisma.cashCount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CashCountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashCountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashCounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashCounts
     * const cashCount = await prisma.cashCount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CashCountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CashCountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashCount.
     * @param {CashCountUpsertArgs} args - Arguments to update or create a CashCount.
     * @example
     * // Update or create a CashCount
     * const cashCount = await prisma.cashCount.upsert({
     *   create: {
     *     // ... data to create a CashCount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashCount we want to update
     *   }
     * })
    **/
    upsert<T extends CashCountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CashCountUpsertArgs<ExtArgs>>
    ): Prisma__CashCountClient<$Result.GetResult<Prisma.$CashCountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CashCounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCountCountArgs} args - Arguments to filter CashCounts to count.
     * @example
     * // Count the number of CashCounts
     * const count = await prisma.cashCount.count({
     *   where: {
     *     // ... the filter for the CashCounts we want to count
     *   }
     * })
    **/
    count<T extends CashCountCountArgs>(
      args?: Subset<T, CashCountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashCountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashCount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashCountAggregateArgs>(args: Subset<T, CashCountAggregateArgs>): Prisma.PrismaPromise<GetCashCountAggregateType<T>>

    /**
     * Group by CashCount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashCountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashCountGroupByArgs['orderBy'] }
        : { orderBy?: CashCountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashCountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashCountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashCount model
   */
  readonly fields: CashCountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashCount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashCountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shift<T extends EmployeeShiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeShiftDefaultArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CashCount model
   */ 
  interface CashCountFieldRefs {
    readonly id: FieldRef<"CashCount", 'String'>
    readonly shiftId: FieldRef<"CashCount", 'String'>
    readonly denomination: FieldRef<"CashCount", 'Decimal'>
    readonly quantity: FieldRef<"CashCount", 'Int'>
    readonly type: FieldRef<"CashCount", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CashCount findUnique
   */
  export type CashCountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCount
     */
    select?: CashCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashCountInclude<ExtArgs> | null
    /**
     * Filter, which CashCount to fetch.
     */
    where: CashCountWhereUniqueInput
  }


  /**
   * CashCount findUniqueOrThrow
   */
  export type CashCountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCount
     */
    select?: CashCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashCountInclude<ExtArgs> | null
    /**
     * Filter, which CashCount to fetch.
     */
    where: CashCountWhereUniqueInput
  }


  /**
   * CashCount findFirst
   */
  export type CashCountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCount
     */
    select?: CashCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashCountInclude<ExtArgs> | null
    /**
     * Filter, which CashCount to fetch.
     */
    where?: CashCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashCounts to fetch.
     */
    orderBy?: CashCountOrderByWithRelationInput | CashCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashCounts.
     */
    cursor?: CashCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashCounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashCounts.
     */
    distinct?: CashCountScalarFieldEnum | CashCountScalarFieldEnum[]
  }


  /**
   * CashCount findFirstOrThrow
   */
  export type CashCountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCount
     */
    select?: CashCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashCountInclude<ExtArgs> | null
    /**
     * Filter, which CashCount to fetch.
     */
    where?: CashCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashCounts to fetch.
     */
    orderBy?: CashCountOrderByWithRelationInput | CashCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashCounts.
     */
    cursor?: CashCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashCounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashCounts.
     */
    distinct?: CashCountScalarFieldEnum | CashCountScalarFieldEnum[]
  }


  /**
   * CashCount findMany
   */
  export type CashCountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCount
     */
    select?: CashCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashCountInclude<ExtArgs> | null
    /**
     * Filter, which CashCounts to fetch.
     */
    where?: CashCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashCounts to fetch.
     */
    orderBy?: CashCountOrderByWithRelationInput | CashCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashCounts.
     */
    cursor?: CashCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashCounts.
     */
    skip?: number
    distinct?: CashCountScalarFieldEnum | CashCountScalarFieldEnum[]
  }


  /**
   * CashCount create
   */
  export type CashCountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCount
     */
    select?: CashCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashCountInclude<ExtArgs> | null
    /**
     * The data needed to create a CashCount.
     */
    data: XOR<CashCountCreateInput, CashCountUncheckedCreateInput>
  }


  /**
   * CashCount update
   */
  export type CashCountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCount
     */
    select?: CashCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashCountInclude<ExtArgs> | null
    /**
     * The data needed to update a CashCount.
     */
    data: XOR<CashCountUpdateInput, CashCountUncheckedUpdateInput>
    /**
     * Choose, which CashCount to update.
     */
    where: CashCountWhereUniqueInput
  }


  /**
   * CashCount updateMany
   */
  export type CashCountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashCounts.
     */
    data: XOR<CashCountUpdateManyMutationInput, CashCountUncheckedUpdateManyInput>
    /**
     * Filter which CashCounts to update
     */
    where?: CashCountWhereInput
  }


  /**
   * CashCount upsert
   */
  export type CashCountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCount
     */
    select?: CashCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashCountInclude<ExtArgs> | null
    /**
     * The filter to search for the CashCount to update in case it exists.
     */
    where: CashCountWhereUniqueInput
    /**
     * In case the CashCount found by the `where` argument doesn't exist, create a new CashCount with this data.
     */
    create: XOR<CashCountCreateInput, CashCountUncheckedCreateInput>
    /**
     * In case the CashCount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashCountUpdateInput, CashCountUncheckedUpdateInput>
  }


  /**
   * CashCount delete
   */
  export type CashCountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCount
     */
    select?: CashCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashCountInclude<ExtArgs> | null
    /**
     * Filter which CashCount to delete.
     */
    where: CashCountWhereUniqueInput
  }


  /**
   * CashCount deleteMany
   */
  export type CashCountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashCounts to delete
     */
    where?: CashCountWhereInput
  }


  /**
   * CashCount without action
   */
  export type CashCountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCount
     */
    select?: CashCountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashCountInclude<ExtArgs> | null
  }



  /**
   * Model CashMovement
   */

  export type AggregateCashMovement = {
    _count: CashMovementCountAggregateOutputType | null
    _avg: CashMovementAvgAggregateOutputType | null
    _sum: CashMovementSumAggregateOutputType | null
    _min: CashMovementMinAggregateOutputType | null
    _max: CashMovementMaxAggregateOutputType | null
  }

  export type CashMovementAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type CashMovementSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type CashMovementMinAggregateOutputType = {
    id: string | null
    type: string | null
    amount: Decimal | null
    reason: string | null
    date: Date | null
    userId: string | null
    branchId: string | null
  }

  export type CashMovementMaxAggregateOutputType = {
    id: string | null
    type: string | null
    amount: Decimal | null
    reason: string | null
    date: Date | null
    userId: string | null
    branchId: string | null
  }

  export type CashMovementCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    reason: number
    date: number
    userId: number
    branchId: number
    _all: number
  }


  export type CashMovementAvgAggregateInputType = {
    amount?: true
  }

  export type CashMovementSumAggregateInputType = {
    amount?: true
  }

  export type CashMovementMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    reason?: true
    date?: true
    userId?: true
    branchId?: true
  }

  export type CashMovementMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    reason?: true
    date?: true
    userId?: true
    branchId?: true
  }

  export type CashMovementCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    reason?: true
    date?: true
    userId?: true
    branchId?: true
    _all?: true
  }

  export type CashMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashMovement to aggregate.
     */
    where?: CashMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashMovements to fetch.
     */
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashMovements
    **/
    _count?: true | CashMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashMovementMaxAggregateInputType
  }

  export type GetCashMovementAggregateType<T extends CashMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateCashMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashMovement[P]>
      : GetScalarType<T[P], AggregateCashMovement[P]>
  }




  export type CashMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashMovementWhereInput
    orderBy?: CashMovementOrderByWithAggregationInput | CashMovementOrderByWithAggregationInput[]
    by: CashMovementScalarFieldEnum[] | CashMovementScalarFieldEnum
    having?: CashMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashMovementCountAggregateInputType | true
    _avg?: CashMovementAvgAggregateInputType
    _sum?: CashMovementSumAggregateInputType
    _min?: CashMovementMinAggregateInputType
    _max?: CashMovementMaxAggregateInputType
  }

  export type CashMovementGroupByOutputType = {
    id: string
    type: string
    amount: Decimal
    reason: string
    date: Date
    userId: string
    branchId: string
    _count: CashMovementCountAggregateOutputType | null
    _avg: CashMovementAvgAggregateOutputType | null
    _sum: CashMovementSumAggregateOutputType | null
    _min: CashMovementMinAggregateOutputType | null
    _max: CashMovementMaxAggregateOutputType | null
  }

  type GetCashMovementGroupByPayload<T extends CashMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashMovementGroupByOutputType[P]>
            : GetScalarType<T[P], CashMovementGroupByOutputType[P]>
        }
      >
    >


  export type CashMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    reason?: boolean
    date?: boolean
    userId?: boolean
    branchId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashMovement"]>

  export type CashMovementSelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    reason?: boolean
    date?: boolean
    userId?: boolean
    branchId?: boolean
  }

  export type CashMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }


  export type $CashMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashMovement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      amount: Prisma.Decimal
      reason: string
      date: Date
      userId: string
      branchId: string
    }, ExtArgs["result"]["cashMovement"]>
    composites: {}
  }


  type CashMovementGetPayload<S extends boolean | null | undefined | CashMovementDefaultArgs> = $Result.GetResult<Prisma.$CashMovementPayload, S>

  type CashMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashMovementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CashMovementCountAggregateInputType | true
    }

  export interface CashMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashMovement'], meta: { name: 'CashMovement' } }
    /**
     * Find zero or one CashMovement that matches the filter.
     * @param {CashMovementFindUniqueArgs} args - Arguments to find a CashMovement
     * @example
     * // Get one CashMovement
     * const cashMovement = await prisma.cashMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CashMovementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CashMovementFindUniqueArgs<ExtArgs>>
    ): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CashMovement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CashMovementFindUniqueOrThrowArgs} args - Arguments to find a CashMovement
     * @example
     * // Get one CashMovement
     * const cashMovement = await prisma.cashMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CashMovementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CashMovementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CashMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementFindFirstArgs} args - Arguments to find a CashMovement
     * @example
     * // Get one CashMovement
     * const cashMovement = await prisma.cashMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CashMovementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CashMovementFindFirstArgs<ExtArgs>>
    ): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CashMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementFindFirstOrThrowArgs} args - Arguments to find a CashMovement
     * @example
     * // Get one CashMovement
     * const cashMovement = await prisma.cashMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CashMovementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CashMovementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CashMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashMovements
     * const cashMovements = await prisma.cashMovement.findMany()
     * 
     * // Get first 10 CashMovements
     * const cashMovements = await prisma.cashMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashMovementWithIdOnly = await prisma.cashMovement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CashMovementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashMovementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CashMovement.
     * @param {CashMovementCreateArgs} args - Arguments to create a CashMovement.
     * @example
     * // Create one CashMovement
     * const CashMovement = await prisma.cashMovement.create({
     *   data: {
     *     // ... data to create a CashMovement
     *   }
     * })
     * 
    **/
    create<T extends CashMovementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CashMovementCreateArgs<ExtArgs>>
    ): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a CashMovement.
     * @param {CashMovementDeleteArgs} args - Arguments to delete one CashMovement.
     * @example
     * // Delete one CashMovement
     * const CashMovement = await prisma.cashMovement.delete({
     *   where: {
     *     // ... filter to delete one CashMovement
     *   }
     * })
     * 
    **/
    delete<T extends CashMovementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CashMovementDeleteArgs<ExtArgs>>
    ): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CashMovement.
     * @param {CashMovementUpdateArgs} args - Arguments to update one CashMovement.
     * @example
     * // Update one CashMovement
     * const cashMovement = await prisma.cashMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CashMovementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CashMovementUpdateArgs<ExtArgs>>
    ): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CashMovements.
     * @param {CashMovementDeleteManyArgs} args - Arguments to filter CashMovements to delete.
     * @example
     * // Delete a few CashMovements
     * const { count } = await prisma.cashMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CashMovementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashMovementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashMovements
     * const cashMovement = await prisma.cashMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CashMovementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CashMovementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashMovement.
     * @param {CashMovementUpsertArgs} args - Arguments to update or create a CashMovement.
     * @example
     * // Update or create a CashMovement
     * const cashMovement = await prisma.cashMovement.upsert({
     *   create: {
     *     // ... data to create a CashMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashMovement we want to update
     *   }
     * })
    **/
    upsert<T extends CashMovementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CashMovementUpsertArgs<ExtArgs>>
    ): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CashMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementCountArgs} args - Arguments to filter CashMovements to count.
     * @example
     * // Count the number of CashMovements
     * const count = await prisma.cashMovement.count({
     *   where: {
     *     // ... the filter for the CashMovements we want to count
     *   }
     * })
    **/
    count<T extends CashMovementCountArgs>(
      args?: Subset<T, CashMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashMovementAggregateArgs>(args: Subset<T, CashMovementAggregateArgs>): Prisma.PrismaPromise<GetCashMovementAggregateType<T>>

    /**
     * Group by CashMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashMovementGroupByArgs['orderBy'] }
        : { orderBy?: CashMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashMovement model
   */
  readonly fields: CashMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CashMovement model
   */ 
  interface CashMovementFieldRefs {
    readonly id: FieldRef<"CashMovement", 'String'>
    readonly type: FieldRef<"CashMovement", 'String'>
    readonly amount: FieldRef<"CashMovement", 'Decimal'>
    readonly reason: FieldRef<"CashMovement", 'String'>
    readonly date: FieldRef<"CashMovement", 'DateTime'>
    readonly userId: FieldRef<"CashMovement", 'String'>
    readonly branchId: FieldRef<"CashMovement", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CashMovement findUnique
   */
  export type CashMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * Filter, which CashMovement to fetch.
     */
    where: CashMovementWhereUniqueInput
  }


  /**
   * CashMovement findUniqueOrThrow
   */
  export type CashMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * Filter, which CashMovement to fetch.
     */
    where: CashMovementWhereUniqueInput
  }


  /**
   * CashMovement findFirst
   */
  export type CashMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * Filter, which CashMovement to fetch.
     */
    where?: CashMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashMovements to fetch.
     */
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashMovements.
     */
    cursor?: CashMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashMovements.
     */
    distinct?: CashMovementScalarFieldEnum | CashMovementScalarFieldEnum[]
  }


  /**
   * CashMovement findFirstOrThrow
   */
  export type CashMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * Filter, which CashMovement to fetch.
     */
    where?: CashMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashMovements to fetch.
     */
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashMovements.
     */
    cursor?: CashMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashMovements.
     */
    distinct?: CashMovementScalarFieldEnum | CashMovementScalarFieldEnum[]
  }


  /**
   * CashMovement findMany
   */
  export type CashMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * Filter, which CashMovements to fetch.
     */
    where?: CashMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashMovements to fetch.
     */
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashMovements.
     */
    cursor?: CashMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashMovements.
     */
    skip?: number
    distinct?: CashMovementScalarFieldEnum | CashMovementScalarFieldEnum[]
  }


  /**
   * CashMovement create
   */
  export type CashMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a CashMovement.
     */
    data: XOR<CashMovementCreateInput, CashMovementUncheckedCreateInput>
  }


  /**
   * CashMovement update
   */
  export type CashMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a CashMovement.
     */
    data: XOR<CashMovementUpdateInput, CashMovementUncheckedUpdateInput>
    /**
     * Choose, which CashMovement to update.
     */
    where: CashMovementWhereUniqueInput
  }


  /**
   * CashMovement updateMany
   */
  export type CashMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashMovements.
     */
    data: XOR<CashMovementUpdateManyMutationInput, CashMovementUncheckedUpdateManyInput>
    /**
     * Filter which CashMovements to update
     */
    where?: CashMovementWhereInput
  }


  /**
   * CashMovement upsert
   */
  export type CashMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the CashMovement to update in case it exists.
     */
    where: CashMovementWhereUniqueInput
    /**
     * In case the CashMovement found by the `where` argument doesn't exist, create a new CashMovement with this data.
     */
    create: XOR<CashMovementCreateInput, CashMovementUncheckedCreateInput>
    /**
     * In case the CashMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashMovementUpdateInput, CashMovementUncheckedUpdateInput>
  }


  /**
   * CashMovement delete
   */
  export type CashMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * Filter which CashMovement to delete.
     */
    where: CashMovementWhereUniqueInput
  }


  /**
   * CashMovement deleteMany
   */
  export type CashMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashMovements to delete
     */
    where?: CashMovementWhereInput
  }


  /**
   * CashMovement without action
   */
  export type CashMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CashMovementInclude<ExtArgs> | null
  }



  /**
   * Model InventoryAdjustment
   */

  export type AggregateInventoryAdjustment = {
    _count: InventoryAdjustmentCountAggregateOutputType | null
    _avg: InventoryAdjustmentAvgAggregateOutputType | null
    _sum: InventoryAdjustmentSumAggregateOutputType | null
    _min: InventoryAdjustmentMinAggregateOutputType | null
    _max: InventoryAdjustmentMaxAggregateOutputType | null
  }

  export type InventoryAdjustmentAvgAggregateOutputType = {
    quantity: Decimal | null
  }

  export type InventoryAdjustmentSumAggregateOutputType = {
    quantity: Decimal | null
  }

  export type InventoryAdjustmentMinAggregateOutputType = {
    id: string | null
    date: Date | null
    quantity: Decimal | null
    reason: string | null
    productId: string | null
    userId: string | null
  }

  export type InventoryAdjustmentMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    quantity: Decimal | null
    reason: string | null
    productId: string | null
    userId: string | null
  }

  export type InventoryAdjustmentCountAggregateOutputType = {
    id: number
    date: number
    quantity: number
    reason: number
    productId: number
    userId: number
    _all: number
  }


  export type InventoryAdjustmentAvgAggregateInputType = {
    quantity?: true
  }

  export type InventoryAdjustmentSumAggregateInputType = {
    quantity?: true
  }

  export type InventoryAdjustmentMinAggregateInputType = {
    id?: true
    date?: true
    quantity?: true
    reason?: true
    productId?: true
    userId?: true
  }

  export type InventoryAdjustmentMaxAggregateInputType = {
    id?: true
    date?: true
    quantity?: true
    reason?: true
    productId?: true
    userId?: true
  }

  export type InventoryAdjustmentCountAggregateInputType = {
    id?: true
    date?: true
    quantity?: true
    reason?: true
    productId?: true
    userId?: true
    _all?: true
  }

  export type InventoryAdjustmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryAdjustment to aggregate.
     */
    where?: InventoryAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAdjustments to fetch.
     */
    orderBy?: InventoryAdjustmentOrderByWithRelationInput | InventoryAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryAdjustments
    **/
    _count?: true | InventoryAdjustmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAdjustmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryAdjustmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryAdjustmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryAdjustmentMaxAggregateInputType
  }

  export type GetInventoryAdjustmentAggregateType<T extends InventoryAdjustmentAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryAdjustment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryAdjustment[P]>
      : GetScalarType<T[P], AggregateInventoryAdjustment[P]>
  }




  export type InventoryAdjustmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAdjustmentWhereInput
    orderBy?: InventoryAdjustmentOrderByWithAggregationInput | InventoryAdjustmentOrderByWithAggregationInput[]
    by: InventoryAdjustmentScalarFieldEnum[] | InventoryAdjustmentScalarFieldEnum
    having?: InventoryAdjustmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryAdjustmentCountAggregateInputType | true
    _avg?: InventoryAdjustmentAvgAggregateInputType
    _sum?: InventoryAdjustmentSumAggregateInputType
    _min?: InventoryAdjustmentMinAggregateInputType
    _max?: InventoryAdjustmentMaxAggregateInputType
  }

  export type InventoryAdjustmentGroupByOutputType = {
    id: string
    date: Date
    quantity: Decimal
    reason: string
    productId: string
    userId: string
    _count: InventoryAdjustmentCountAggregateOutputType | null
    _avg: InventoryAdjustmentAvgAggregateOutputType | null
    _sum: InventoryAdjustmentSumAggregateOutputType | null
    _min: InventoryAdjustmentMinAggregateOutputType | null
    _max: InventoryAdjustmentMaxAggregateOutputType | null
  }

  type GetInventoryAdjustmentGroupByPayload<T extends InventoryAdjustmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryAdjustmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryAdjustmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryAdjustmentGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryAdjustmentGroupByOutputType[P]>
        }
      >
    >


  export type InventoryAdjustmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    quantity?: boolean
    reason?: boolean
    productId?: boolean
    userId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAdjustment"]>

  export type InventoryAdjustmentSelectScalar = {
    id?: boolean
    date?: boolean
    quantity?: boolean
    reason?: boolean
    productId?: boolean
    userId?: boolean
  }

  export type InventoryAdjustmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $InventoryAdjustmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryAdjustment"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      quantity: Prisma.Decimal
      reason: string
      productId: string
      userId: string
    }, ExtArgs["result"]["inventoryAdjustment"]>
    composites: {}
  }


  type InventoryAdjustmentGetPayload<S extends boolean | null | undefined | InventoryAdjustmentDefaultArgs> = $Result.GetResult<Prisma.$InventoryAdjustmentPayload, S>

  type InventoryAdjustmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryAdjustmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryAdjustmentCountAggregateInputType | true
    }

  export interface InventoryAdjustmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryAdjustment'], meta: { name: 'InventoryAdjustment' } }
    /**
     * Find zero or one InventoryAdjustment that matches the filter.
     * @param {InventoryAdjustmentFindUniqueArgs} args - Arguments to find a InventoryAdjustment
     * @example
     * // Get one InventoryAdjustment
     * const inventoryAdjustment = await prisma.inventoryAdjustment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryAdjustmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryAdjustmentFindUniqueArgs<ExtArgs>>
    ): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InventoryAdjustment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InventoryAdjustmentFindUniqueOrThrowArgs} args - Arguments to find a InventoryAdjustment
     * @example
     * // Get one InventoryAdjustment
     * const inventoryAdjustment = await prisma.inventoryAdjustment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryAdjustmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryAdjustmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InventoryAdjustment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentFindFirstArgs} args - Arguments to find a InventoryAdjustment
     * @example
     * // Get one InventoryAdjustment
     * const inventoryAdjustment = await prisma.inventoryAdjustment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryAdjustmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryAdjustmentFindFirstArgs<ExtArgs>>
    ): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InventoryAdjustment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentFindFirstOrThrowArgs} args - Arguments to find a InventoryAdjustment
     * @example
     * // Get one InventoryAdjustment
     * const inventoryAdjustment = await prisma.inventoryAdjustment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryAdjustmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryAdjustmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InventoryAdjustments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryAdjustments
     * const inventoryAdjustments = await prisma.inventoryAdjustment.findMany()
     * 
     * // Get first 10 InventoryAdjustments
     * const inventoryAdjustments = await prisma.inventoryAdjustment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryAdjustmentWithIdOnly = await prisma.inventoryAdjustment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InventoryAdjustmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryAdjustmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InventoryAdjustment.
     * @param {InventoryAdjustmentCreateArgs} args - Arguments to create a InventoryAdjustment.
     * @example
     * // Create one InventoryAdjustment
     * const InventoryAdjustment = await prisma.inventoryAdjustment.create({
     *   data: {
     *     // ... data to create a InventoryAdjustment
     *   }
     * })
     * 
    **/
    create<T extends InventoryAdjustmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryAdjustmentCreateArgs<ExtArgs>>
    ): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a InventoryAdjustment.
     * @param {InventoryAdjustmentDeleteArgs} args - Arguments to delete one InventoryAdjustment.
     * @example
     * // Delete one InventoryAdjustment
     * const InventoryAdjustment = await prisma.inventoryAdjustment.delete({
     *   where: {
     *     // ... filter to delete one InventoryAdjustment
     *   }
     * })
     * 
    **/
    delete<T extends InventoryAdjustmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryAdjustmentDeleteArgs<ExtArgs>>
    ): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InventoryAdjustment.
     * @param {InventoryAdjustmentUpdateArgs} args - Arguments to update one InventoryAdjustment.
     * @example
     * // Update one InventoryAdjustment
     * const inventoryAdjustment = await prisma.inventoryAdjustment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryAdjustmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryAdjustmentUpdateArgs<ExtArgs>>
    ): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InventoryAdjustments.
     * @param {InventoryAdjustmentDeleteManyArgs} args - Arguments to filter InventoryAdjustments to delete.
     * @example
     * // Delete a few InventoryAdjustments
     * const { count } = await prisma.inventoryAdjustment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryAdjustmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryAdjustmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryAdjustments
     * const inventoryAdjustment = await prisma.inventoryAdjustment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryAdjustmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryAdjustmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryAdjustment.
     * @param {InventoryAdjustmentUpsertArgs} args - Arguments to update or create a InventoryAdjustment.
     * @example
     * // Update or create a InventoryAdjustment
     * const inventoryAdjustment = await prisma.inventoryAdjustment.upsert({
     *   create: {
     *     // ... data to create a InventoryAdjustment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryAdjustment we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryAdjustmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryAdjustmentUpsertArgs<ExtArgs>>
    ): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InventoryAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentCountArgs} args - Arguments to filter InventoryAdjustments to count.
     * @example
     * // Count the number of InventoryAdjustments
     * const count = await prisma.inventoryAdjustment.count({
     *   where: {
     *     // ... the filter for the InventoryAdjustments we want to count
     *   }
     * })
    **/
    count<T extends InventoryAdjustmentCountArgs>(
      args?: Subset<T, InventoryAdjustmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryAdjustmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAdjustmentAggregateArgs>(args: Subset<T, InventoryAdjustmentAggregateArgs>): Prisma.PrismaPromise<GetInventoryAdjustmentAggregateType<T>>

    /**
     * Group by InventoryAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryAdjustmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryAdjustmentGroupByArgs['orderBy'] }
        : { orderBy?: InventoryAdjustmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryAdjustmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryAdjustmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryAdjustment model
   */
  readonly fields: InventoryAdjustmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryAdjustment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryAdjustmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InventoryAdjustment model
   */ 
  interface InventoryAdjustmentFieldRefs {
    readonly id: FieldRef<"InventoryAdjustment", 'String'>
    readonly date: FieldRef<"InventoryAdjustment", 'DateTime'>
    readonly quantity: FieldRef<"InventoryAdjustment", 'Decimal'>
    readonly reason: FieldRef<"InventoryAdjustment", 'String'>
    readonly productId: FieldRef<"InventoryAdjustment", 'String'>
    readonly userId: FieldRef<"InventoryAdjustment", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InventoryAdjustment findUnique
   */
  export type InventoryAdjustmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustment to fetch.
     */
    where: InventoryAdjustmentWhereUniqueInput
  }


  /**
   * InventoryAdjustment findUniqueOrThrow
   */
  export type InventoryAdjustmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustment to fetch.
     */
    where: InventoryAdjustmentWhereUniqueInput
  }


  /**
   * InventoryAdjustment findFirst
   */
  export type InventoryAdjustmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustment to fetch.
     */
    where?: InventoryAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAdjustments to fetch.
     */
    orderBy?: InventoryAdjustmentOrderByWithRelationInput | InventoryAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryAdjustments.
     */
    cursor?: InventoryAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryAdjustments.
     */
    distinct?: InventoryAdjustmentScalarFieldEnum | InventoryAdjustmentScalarFieldEnum[]
  }


  /**
   * InventoryAdjustment findFirstOrThrow
   */
  export type InventoryAdjustmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustment to fetch.
     */
    where?: InventoryAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAdjustments to fetch.
     */
    orderBy?: InventoryAdjustmentOrderByWithRelationInput | InventoryAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryAdjustments.
     */
    cursor?: InventoryAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryAdjustments.
     */
    distinct?: InventoryAdjustmentScalarFieldEnum | InventoryAdjustmentScalarFieldEnum[]
  }


  /**
   * InventoryAdjustment findMany
   */
  export type InventoryAdjustmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustments to fetch.
     */
    where?: InventoryAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAdjustments to fetch.
     */
    orderBy?: InventoryAdjustmentOrderByWithRelationInput | InventoryAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryAdjustments.
     */
    cursor?: InventoryAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAdjustments.
     */
    skip?: number
    distinct?: InventoryAdjustmentScalarFieldEnum | InventoryAdjustmentScalarFieldEnum[]
  }


  /**
   * InventoryAdjustment create
   */
  export type InventoryAdjustmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryAdjustment.
     */
    data: XOR<InventoryAdjustmentCreateInput, InventoryAdjustmentUncheckedCreateInput>
  }


  /**
   * InventoryAdjustment update
   */
  export type InventoryAdjustmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryAdjustment.
     */
    data: XOR<InventoryAdjustmentUpdateInput, InventoryAdjustmentUncheckedUpdateInput>
    /**
     * Choose, which InventoryAdjustment to update.
     */
    where: InventoryAdjustmentWhereUniqueInput
  }


  /**
   * InventoryAdjustment updateMany
   */
  export type InventoryAdjustmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryAdjustments.
     */
    data: XOR<InventoryAdjustmentUpdateManyMutationInput, InventoryAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which InventoryAdjustments to update
     */
    where?: InventoryAdjustmentWhereInput
  }


  /**
   * InventoryAdjustment upsert
   */
  export type InventoryAdjustmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryAdjustment to update in case it exists.
     */
    where: InventoryAdjustmentWhereUniqueInput
    /**
     * In case the InventoryAdjustment found by the `where` argument doesn't exist, create a new InventoryAdjustment with this data.
     */
    create: XOR<InventoryAdjustmentCreateInput, InventoryAdjustmentUncheckedCreateInput>
    /**
     * In case the InventoryAdjustment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryAdjustmentUpdateInput, InventoryAdjustmentUncheckedUpdateInput>
  }


  /**
   * InventoryAdjustment delete
   */
  export type InventoryAdjustmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter which InventoryAdjustment to delete.
     */
    where: InventoryAdjustmentWhereUniqueInput
  }


  /**
   * InventoryAdjustment deleteMany
   */
  export type InventoryAdjustmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryAdjustments to delete
     */
    where?: InventoryAdjustmentWhereInput
  }


  /**
   * InventoryAdjustment without action
   */
  export type InventoryAdjustmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
  }



  /**
   * Model SystemLog
   */

  export type AggregateSystemLog = {
    _count: SystemLogCountAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  export type SystemLogMinAggregateOutputType = {
    id: string | null
    date: Date | null
    action: string | null
    details: string | null
    userId: string | null
  }

  export type SystemLogMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    action: string | null
    details: string | null
    userId: string | null
  }

  export type SystemLogCountAggregateOutputType = {
    id: number
    date: number
    action: number
    details: number
    userId: number
    _all: number
  }


  export type SystemLogMinAggregateInputType = {
    id?: true
    date?: true
    action?: true
    details?: true
    userId?: true
  }

  export type SystemLogMaxAggregateInputType = {
    id?: true
    date?: true
    action?: true
    details?: true
    userId?: true
  }

  export type SystemLogCountAggregateInputType = {
    id?: true
    date?: true
    action?: true
    details?: true
    userId?: true
    _all?: true
  }

  export type SystemLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLog to aggregate.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemLogs
    **/
    _count?: true | SystemLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemLogMaxAggregateInputType
  }

  export type GetSystemLogAggregateType<T extends SystemLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemLog[P]>
      : GetScalarType<T[P], AggregateSystemLog[P]>
  }




  export type SystemLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithAggregationInput | SystemLogOrderByWithAggregationInput[]
    by: SystemLogScalarFieldEnum[] | SystemLogScalarFieldEnum
    having?: SystemLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemLogCountAggregateInputType | true
    _min?: SystemLogMinAggregateInputType
    _max?: SystemLogMaxAggregateInputType
  }

  export type SystemLogGroupByOutputType = {
    id: string
    date: Date
    action: string
    details: string | null
    userId: string
    _count: SystemLogCountAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  type GetSystemLogGroupByPayload<T extends SystemLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
            : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
        }
      >
    >


  export type SystemLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    action?: boolean
    details?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemLog"]>

  export type SystemLogSelectScalar = {
    id?: boolean
    date?: boolean
    action?: boolean
    details?: boolean
    userId?: boolean
  }

  export type SystemLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $SystemLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      action: string
      details: string | null
      userId: string
    }, ExtArgs["result"]["systemLog"]>
    composites: {}
  }


  type SystemLogGetPayload<S extends boolean | null | undefined | SystemLogDefaultArgs> = $Result.GetResult<Prisma.$SystemLogPayload, S>

  type SystemLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemLogCountAggregateInputType | true
    }

  export interface SystemLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemLog'], meta: { name: 'SystemLog' } }
    /**
     * Find zero or one SystemLog that matches the filter.
     * @param {SystemLogFindUniqueArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SystemLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SystemLogFindUniqueArgs<ExtArgs>>
    ): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SystemLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SystemLogFindUniqueOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SystemLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SystemLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SystemLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemLogFindFirstArgs<ExtArgs>>
    ): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SystemLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SystemLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SystemLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemLogs
     * const systemLogs = await prisma.systemLog.findMany()
     * 
     * // Get first 10 SystemLogs
     * const systemLogs = await prisma.systemLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SystemLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SystemLog.
     * @param {SystemLogCreateArgs} args - Arguments to create a SystemLog.
     * @example
     * // Create one SystemLog
     * const SystemLog = await prisma.systemLog.create({
     *   data: {
     *     // ... data to create a SystemLog
     *   }
     * })
     * 
    **/
    create<T extends SystemLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemLogCreateArgs<ExtArgs>>
    ): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a SystemLog.
     * @param {SystemLogDeleteArgs} args - Arguments to delete one SystemLog.
     * @example
     * // Delete one SystemLog
     * const SystemLog = await prisma.systemLog.delete({
     *   where: {
     *     // ... filter to delete one SystemLog
     *   }
     * })
     * 
    **/
    delete<T extends SystemLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SystemLogDeleteArgs<ExtArgs>>
    ): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SystemLog.
     * @param {SystemLogUpdateArgs} args - Arguments to update one SystemLog.
     * @example
     * // Update one SystemLog
     * const systemLog = await prisma.systemLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SystemLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemLogUpdateArgs<ExtArgs>>
    ): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SystemLogs.
     * @param {SystemLogDeleteManyArgs} args - Arguments to filter SystemLogs to delete.
     * @example
     * // Delete a few SystemLogs
     * const { count } = await prisma.systemLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SystemLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemLogs
     * const systemLog = await prisma.systemLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SystemLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SystemLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemLog.
     * @param {SystemLogUpsertArgs} args - Arguments to update or create a SystemLog.
     * @example
     * // Update or create a SystemLog
     * const systemLog = await prisma.systemLog.upsert({
     *   create: {
     *     // ... data to create a SystemLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemLog we want to update
     *   }
     * })
    **/
    upsert<T extends SystemLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SystemLogUpsertArgs<ExtArgs>>
    ): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogCountArgs} args - Arguments to filter SystemLogs to count.
     * @example
     * // Count the number of SystemLogs
     * const count = await prisma.systemLog.count({
     *   where: {
     *     // ... the filter for the SystemLogs we want to count
     *   }
     * })
    **/
    count<T extends SystemLogCountArgs>(
      args?: Subset<T, SystemLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemLogAggregateArgs>(args: Subset<T, SystemLogAggregateArgs>): Prisma.PrismaPromise<GetSystemLogAggregateType<T>>

    /**
     * Group by SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemLogGroupByArgs['orderBy'] }
        : { orderBy?: SystemLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemLog model
   */
  readonly fields: SystemLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SystemLog model
   */ 
  interface SystemLogFieldRefs {
    readonly id: FieldRef<"SystemLog", 'String'>
    readonly date: FieldRef<"SystemLog", 'DateTime'>
    readonly action: FieldRef<"SystemLog", 'String'>
    readonly details: FieldRef<"SystemLog", 'String'>
    readonly userId: FieldRef<"SystemLog", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SystemLog findUnique
   */
  export type SystemLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }


  /**
   * SystemLog findUniqueOrThrow
   */
  export type SystemLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }


  /**
   * SystemLog findFirst
   */
  export type SystemLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }


  /**
   * SystemLog findFirstOrThrow
   */
  export type SystemLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }


  /**
   * SystemLog findMany
   */
  export type SystemLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLogs to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }


  /**
   * SystemLog create
   */
  export type SystemLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemLog.
     */
    data: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
  }


  /**
   * SystemLog update
   */
  export type SystemLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemLog.
     */
    data: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
    /**
     * Choose, which SystemLog to update.
     */
    where: SystemLogWhereUniqueInput
  }


  /**
   * SystemLog updateMany
   */
  export type SystemLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemLogs.
     */
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyInput>
    /**
     * Filter which SystemLogs to update
     */
    where?: SystemLogWhereInput
  }


  /**
   * SystemLog upsert
   */
  export type SystemLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemLog to update in case it exists.
     */
    where: SystemLogWhereUniqueInput
    /**
     * In case the SystemLog found by the `where` argument doesn't exist, create a new SystemLog with this data.
     */
    create: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
    /**
     * In case the SystemLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
  }


  /**
   * SystemLog delete
   */
  export type SystemLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter which SystemLog to delete.
     */
    where: SystemLogWhereUniqueInput
  }


  /**
   * SystemLog deleteMany
   */
  export type SystemLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLogs to delete
     */
    where?: SystemLogWhereInput
  }


  /**
   * SystemLog without action
   */
  export type SystemLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SystemLogInclude<ExtArgs> | null
  }



  /**
   * Model StockTransfer
   */

  export type AggregateStockTransfer = {
    _count: StockTransferCountAggregateOutputType | null
    _min: StockTransferMinAggregateOutputType | null
    _max: StockTransferMaxAggregateOutputType | null
  }

  export type StockTransferMinAggregateOutputType = {
    id: string | null
    date: Date | null
    status: string | null
    sourceBranchId: string | null
    destBranchId: string | null
  }

  export type StockTransferMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    status: string | null
    sourceBranchId: string | null
    destBranchId: string | null
  }

  export type StockTransferCountAggregateOutputType = {
    id: number
    date: number
    status: number
    sourceBranchId: number
    destBranchId: number
    _all: number
  }


  export type StockTransferMinAggregateInputType = {
    id?: true
    date?: true
    status?: true
    sourceBranchId?: true
    destBranchId?: true
  }

  export type StockTransferMaxAggregateInputType = {
    id?: true
    date?: true
    status?: true
    sourceBranchId?: true
    destBranchId?: true
  }

  export type StockTransferCountAggregateInputType = {
    id?: true
    date?: true
    status?: true
    sourceBranchId?: true
    destBranchId?: true
    _all?: true
  }

  export type StockTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransfer to aggregate.
     */
    where?: StockTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransfers to fetch.
     */
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockTransfers
    **/
    _count?: true | StockTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockTransferMaxAggregateInputType
  }

  export type GetStockTransferAggregateType<T extends StockTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateStockTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockTransfer[P]>
      : GetScalarType<T[P], AggregateStockTransfer[P]>
  }




  export type StockTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferWhereInput
    orderBy?: StockTransferOrderByWithAggregationInput | StockTransferOrderByWithAggregationInput[]
    by: StockTransferScalarFieldEnum[] | StockTransferScalarFieldEnum
    having?: StockTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockTransferCountAggregateInputType | true
    _min?: StockTransferMinAggregateInputType
    _max?: StockTransferMaxAggregateInputType
  }

  export type StockTransferGroupByOutputType = {
    id: string
    date: Date
    status: string
    sourceBranchId: string
    destBranchId: string
    _count: StockTransferCountAggregateOutputType | null
    _min: StockTransferMinAggregateOutputType | null
    _max: StockTransferMaxAggregateOutputType | null
  }

  type GetStockTransferGroupByPayload<T extends StockTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockTransferGroupByOutputType[P]>
            : GetScalarType<T[P], StockTransferGroupByOutputType[P]>
        }
      >
    >


  export type StockTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    sourceBranchId?: boolean
    destBranchId?: boolean
    sourceBranch?: boolean | BranchDefaultArgs<ExtArgs>
    destBranch?: boolean | BranchDefaultArgs<ExtArgs>
    details?: boolean | StockTransfer$detailsArgs<ExtArgs>
    _count?: boolean | StockTransferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransfer"]>

  export type StockTransferSelectScalar = {
    id?: boolean
    date?: boolean
    status?: boolean
    sourceBranchId?: boolean
    destBranchId?: boolean
  }

  export type StockTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceBranch?: boolean | BranchDefaultArgs<ExtArgs>
    destBranch?: boolean | BranchDefaultArgs<ExtArgs>
    details?: boolean | StockTransfer$detailsArgs<ExtArgs>
    _count?: boolean | StockTransferCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StockTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockTransfer"
    objects: {
      sourceBranch: Prisma.$BranchPayload<ExtArgs>
      destBranch: Prisma.$BranchPayload<ExtArgs>
      details: Prisma.$StockTransferDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      status: string
      sourceBranchId: string
      destBranchId: string
    }, ExtArgs["result"]["stockTransfer"]>
    composites: {}
  }


  type StockTransferGetPayload<S extends boolean | null | undefined | StockTransferDefaultArgs> = $Result.GetResult<Prisma.$StockTransferPayload, S>

  type StockTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockTransferFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockTransferCountAggregateInputType | true
    }

  export interface StockTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockTransfer'], meta: { name: 'StockTransfer' } }
    /**
     * Find zero or one StockTransfer that matches the filter.
     * @param {StockTransferFindUniqueArgs} args - Arguments to find a StockTransfer
     * @example
     * // Get one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockTransferFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockTransferFindUniqueArgs<ExtArgs>>
    ): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockTransfer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockTransferFindUniqueOrThrowArgs} args - Arguments to find a StockTransfer
     * @example
     * // Get one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockTransferFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockTransferFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferFindFirstArgs} args - Arguments to find a StockTransfer
     * @example
     * // Get one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockTransferFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockTransferFindFirstArgs<ExtArgs>>
    ): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferFindFirstOrThrowArgs} args - Arguments to find a StockTransfer
     * @example
     * // Get one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockTransferFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockTransferFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockTransfers
     * const stockTransfers = await prisma.stockTransfer.findMany()
     * 
     * // Get first 10 StockTransfers
     * const stockTransfers = await prisma.stockTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockTransferWithIdOnly = await prisma.stockTransfer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockTransferFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockTransferFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockTransfer.
     * @param {StockTransferCreateArgs} args - Arguments to create a StockTransfer.
     * @example
     * // Create one StockTransfer
     * const StockTransfer = await prisma.stockTransfer.create({
     *   data: {
     *     // ... data to create a StockTransfer
     *   }
     * })
     * 
    **/
    create<T extends StockTransferCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockTransferCreateArgs<ExtArgs>>
    ): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a StockTransfer.
     * @param {StockTransferDeleteArgs} args - Arguments to delete one StockTransfer.
     * @example
     * // Delete one StockTransfer
     * const StockTransfer = await prisma.stockTransfer.delete({
     *   where: {
     *     // ... filter to delete one StockTransfer
     *   }
     * })
     * 
    **/
    delete<T extends StockTransferDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockTransferDeleteArgs<ExtArgs>>
    ): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockTransfer.
     * @param {StockTransferUpdateArgs} args - Arguments to update one StockTransfer.
     * @example
     * // Update one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockTransferUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockTransferUpdateArgs<ExtArgs>>
    ): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockTransfers.
     * @param {StockTransferDeleteManyArgs} args - Arguments to filter StockTransfers to delete.
     * @example
     * // Delete a few StockTransfers
     * const { count } = await prisma.stockTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockTransferDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockTransferDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockTransfers
     * const stockTransfer = await prisma.stockTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockTransferUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockTransferUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockTransfer.
     * @param {StockTransferUpsertArgs} args - Arguments to update or create a StockTransfer.
     * @example
     * // Update or create a StockTransfer
     * const stockTransfer = await prisma.stockTransfer.upsert({
     *   create: {
     *     // ... data to create a StockTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockTransfer we want to update
     *   }
     * })
    **/
    upsert<T extends StockTransferUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockTransferUpsertArgs<ExtArgs>>
    ): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferCountArgs} args - Arguments to filter StockTransfers to count.
     * @example
     * // Count the number of StockTransfers
     * const count = await prisma.stockTransfer.count({
     *   where: {
     *     // ... the filter for the StockTransfers we want to count
     *   }
     * })
    **/
    count<T extends StockTransferCountArgs>(
      args?: Subset<T, StockTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockTransferAggregateArgs>(args: Subset<T, StockTransferAggregateArgs>): Prisma.PrismaPromise<GetStockTransferAggregateType<T>>

    /**
     * Group by StockTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockTransferGroupByArgs['orderBy'] }
        : { orderBy?: StockTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockTransfer model
   */
  readonly fields: StockTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sourceBranch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    destBranch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    details<T extends StockTransfer$detailsArgs<ExtArgs> = {}>(args?: Subset<T, StockTransfer$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferDetailPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockTransfer model
   */ 
  interface StockTransferFieldRefs {
    readonly id: FieldRef<"StockTransfer", 'String'>
    readonly date: FieldRef<"StockTransfer", 'DateTime'>
    readonly status: FieldRef<"StockTransfer", 'String'>
    readonly sourceBranchId: FieldRef<"StockTransfer", 'String'>
    readonly destBranchId: FieldRef<"StockTransfer", 'String'>
  }
    

  // Custom InputTypes

  /**
   * StockTransfer findUnique
   */
  export type StockTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfer to fetch.
     */
    where: StockTransferWhereUniqueInput
  }


  /**
   * StockTransfer findUniqueOrThrow
   */
  export type StockTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfer to fetch.
     */
    where: StockTransferWhereUniqueInput
  }


  /**
   * StockTransfer findFirst
   */
  export type StockTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfer to fetch.
     */
    where?: StockTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransfers to fetch.
     */
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransfers.
     */
    cursor?: StockTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransfers.
     */
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }


  /**
   * StockTransfer findFirstOrThrow
   */
  export type StockTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfer to fetch.
     */
    where?: StockTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransfers to fetch.
     */
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransfers.
     */
    cursor?: StockTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransfers.
     */
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }


  /**
   * StockTransfer findMany
   */
  export type StockTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfers to fetch.
     */
    where?: StockTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransfers to fetch.
     */
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockTransfers.
     */
    cursor?: StockTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransfers.
     */
    skip?: number
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }


  /**
   * StockTransfer create
   */
  export type StockTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a StockTransfer.
     */
    data: XOR<StockTransferCreateInput, StockTransferUncheckedCreateInput>
  }


  /**
   * StockTransfer update
   */
  export type StockTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a StockTransfer.
     */
    data: XOR<StockTransferUpdateInput, StockTransferUncheckedUpdateInput>
    /**
     * Choose, which StockTransfer to update.
     */
    where: StockTransferWhereUniqueInput
  }


  /**
   * StockTransfer updateMany
   */
  export type StockTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockTransfers.
     */
    data: XOR<StockTransferUpdateManyMutationInput, StockTransferUncheckedUpdateManyInput>
    /**
     * Filter which StockTransfers to update
     */
    where?: StockTransferWhereInput
  }


  /**
   * StockTransfer upsert
   */
  export type StockTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the StockTransfer to update in case it exists.
     */
    where: StockTransferWhereUniqueInput
    /**
     * In case the StockTransfer found by the `where` argument doesn't exist, create a new StockTransfer with this data.
     */
    create: XOR<StockTransferCreateInput, StockTransferUncheckedCreateInput>
    /**
     * In case the StockTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockTransferUpdateInput, StockTransferUncheckedUpdateInput>
  }


  /**
   * StockTransfer delete
   */
  export type StockTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter which StockTransfer to delete.
     */
    where: StockTransferWhereUniqueInput
  }


  /**
   * StockTransfer deleteMany
   */
  export type StockTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransfers to delete
     */
    where?: StockTransferWhereInput
  }


  /**
   * StockTransfer.details
   */
  export type StockTransfer$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferDetail
     */
    select?: StockTransferDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferDetailInclude<ExtArgs> | null
    where?: StockTransferDetailWhereInput
    orderBy?: StockTransferDetailOrderByWithRelationInput | StockTransferDetailOrderByWithRelationInput[]
    cursor?: StockTransferDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransferDetailScalarFieldEnum | StockTransferDetailScalarFieldEnum[]
  }


  /**
   * StockTransfer without action
   */
  export type StockTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferInclude<ExtArgs> | null
  }



  /**
   * Model StockTransferDetail
   */

  export type AggregateStockTransferDetail = {
    _count: StockTransferDetailCountAggregateOutputType | null
    _avg: StockTransferDetailAvgAggregateOutputType | null
    _sum: StockTransferDetailSumAggregateOutputType | null
    _min: StockTransferDetailMinAggregateOutputType | null
    _max: StockTransferDetailMaxAggregateOutputType | null
  }

  export type StockTransferDetailAvgAggregateOutputType = {
    quantity: Decimal | null
  }

  export type StockTransferDetailSumAggregateOutputType = {
    quantity: Decimal | null
  }

  export type StockTransferDetailMinAggregateOutputType = {
    id: string | null
    transferId: string | null
    productId: string | null
    quantity: Decimal | null
  }

  export type StockTransferDetailMaxAggregateOutputType = {
    id: string | null
    transferId: string | null
    productId: string | null
    quantity: Decimal | null
  }

  export type StockTransferDetailCountAggregateOutputType = {
    id: number
    transferId: number
    productId: number
    quantity: number
    _all: number
  }


  export type StockTransferDetailAvgAggregateInputType = {
    quantity?: true
  }

  export type StockTransferDetailSumAggregateInputType = {
    quantity?: true
  }

  export type StockTransferDetailMinAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    quantity?: true
  }

  export type StockTransferDetailMaxAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    quantity?: true
  }

  export type StockTransferDetailCountAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    quantity?: true
    _all?: true
  }

  export type StockTransferDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransferDetail to aggregate.
     */
    where?: StockTransferDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransferDetails to fetch.
     */
    orderBy?: StockTransferDetailOrderByWithRelationInput | StockTransferDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockTransferDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransferDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransferDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockTransferDetails
    **/
    _count?: true | StockTransferDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockTransferDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockTransferDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockTransferDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockTransferDetailMaxAggregateInputType
  }

  export type GetStockTransferDetailAggregateType<T extends StockTransferDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateStockTransferDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockTransferDetail[P]>
      : GetScalarType<T[P], AggregateStockTransferDetail[P]>
  }




  export type StockTransferDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferDetailWhereInput
    orderBy?: StockTransferDetailOrderByWithAggregationInput | StockTransferDetailOrderByWithAggregationInput[]
    by: StockTransferDetailScalarFieldEnum[] | StockTransferDetailScalarFieldEnum
    having?: StockTransferDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockTransferDetailCountAggregateInputType | true
    _avg?: StockTransferDetailAvgAggregateInputType
    _sum?: StockTransferDetailSumAggregateInputType
    _min?: StockTransferDetailMinAggregateInputType
    _max?: StockTransferDetailMaxAggregateInputType
  }

  export type StockTransferDetailGroupByOutputType = {
    id: string
    transferId: string
    productId: string
    quantity: Decimal
    _count: StockTransferDetailCountAggregateOutputType | null
    _avg: StockTransferDetailAvgAggregateOutputType | null
    _sum: StockTransferDetailSumAggregateOutputType | null
    _min: StockTransferDetailMinAggregateOutputType | null
    _max: StockTransferDetailMaxAggregateOutputType | null
  }

  type GetStockTransferDetailGroupByPayload<T extends StockTransferDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockTransferDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockTransferDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockTransferDetailGroupByOutputType[P]>
            : GetScalarType<T[P], StockTransferDetailGroupByOutputType[P]>
        }
      >
    >


  export type StockTransferDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    productId?: boolean
    quantity?: boolean
    transfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransferDetail"]>

  export type StockTransferDetailSelectScalar = {
    id?: boolean
    transferId?: boolean
    productId?: boolean
    quantity?: boolean
  }

  export type StockTransferDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }


  export type $StockTransferDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockTransferDetail"
    objects: {
      transfer: Prisma.$StockTransferPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transferId: string
      productId: string
      quantity: Prisma.Decimal
    }, ExtArgs["result"]["stockTransferDetail"]>
    composites: {}
  }


  type StockTransferDetailGetPayload<S extends boolean | null | undefined | StockTransferDetailDefaultArgs> = $Result.GetResult<Prisma.$StockTransferDetailPayload, S>

  type StockTransferDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockTransferDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockTransferDetailCountAggregateInputType | true
    }

  export interface StockTransferDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockTransferDetail'], meta: { name: 'StockTransferDetail' } }
    /**
     * Find zero or one StockTransferDetail that matches the filter.
     * @param {StockTransferDetailFindUniqueArgs} args - Arguments to find a StockTransferDetail
     * @example
     * // Get one StockTransferDetail
     * const stockTransferDetail = await prisma.stockTransferDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockTransferDetailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockTransferDetailFindUniqueArgs<ExtArgs>>
    ): Prisma__StockTransferDetailClient<$Result.GetResult<Prisma.$StockTransferDetailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockTransferDetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockTransferDetailFindUniqueOrThrowArgs} args - Arguments to find a StockTransferDetail
     * @example
     * // Get one StockTransferDetail
     * const stockTransferDetail = await prisma.stockTransferDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockTransferDetailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockTransferDetailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockTransferDetailClient<$Result.GetResult<Prisma.$StockTransferDetailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockTransferDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferDetailFindFirstArgs} args - Arguments to find a StockTransferDetail
     * @example
     * // Get one StockTransferDetail
     * const stockTransferDetail = await prisma.stockTransferDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockTransferDetailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockTransferDetailFindFirstArgs<ExtArgs>>
    ): Prisma__StockTransferDetailClient<$Result.GetResult<Prisma.$StockTransferDetailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockTransferDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferDetailFindFirstOrThrowArgs} args - Arguments to find a StockTransferDetail
     * @example
     * // Get one StockTransferDetail
     * const stockTransferDetail = await prisma.stockTransferDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockTransferDetailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockTransferDetailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockTransferDetailClient<$Result.GetResult<Prisma.$StockTransferDetailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockTransferDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockTransferDetails
     * const stockTransferDetails = await prisma.stockTransferDetail.findMany()
     * 
     * // Get first 10 StockTransferDetails
     * const stockTransferDetails = await prisma.stockTransferDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockTransferDetailWithIdOnly = await prisma.stockTransferDetail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockTransferDetailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockTransferDetailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferDetailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockTransferDetail.
     * @param {StockTransferDetailCreateArgs} args - Arguments to create a StockTransferDetail.
     * @example
     * // Create one StockTransferDetail
     * const StockTransferDetail = await prisma.stockTransferDetail.create({
     *   data: {
     *     // ... data to create a StockTransferDetail
     *   }
     * })
     * 
    **/
    create<T extends StockTransferDetailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockTransferDetailCreateArgs<ExtArgs>>
    ): Prisma__StockTransferDetailClient<$Result.GetResult<Prisma.$StockTransferDetailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a StockTransferDetail.
     * @param {StockTransferDetailDeleteArgs} args - Arguments to delete one StockTransferDetail.
     * @example
     * // Delete one StockTransferDetail
     * const StockTransferDetail = await prisma.stockTransferDetail.delete({
     *   where: {
     *     // ... filter to delete one StockTransferDetail
     *   }
     * })
     * 
    **/
    delete<T extends StockTransferDetailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockTransferDetailDeleteArgs<ExtArgs>>
    ): Prisma__StockTransferDetailClient<$Result.GetResult<Prisma.$StockTransferDetailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockTransferDetail.
     * @param {StockTransferDetailUpdateArgs} args - Arguments to update one StockTransferDetail.
     * @example
     * // Update one StockTransferDetail
     * const stockTransferDetail = await prisma.stockTransferDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockTransferDetailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockTransferDetailUpdateArgs<ExtArgs>>
    ): Prisma__StockTransferDetailClient<$Result.GetResult<Prisma.$StockTransferDetailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockTransferDetails.
     * @param {StockTransferDetailDeleteManyArgs} args - Arguments to filter StockTransferDetails to delete.
     * @example
     * // Delete a few StockTransferDetails
     * const { count } = await prisma.stockTransferDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockTransferDetailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockTransferDetailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransferDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockTransferDetails
     * const stockTransferDetail = await prisma.stockTransferDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockTransferDetailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockTransferDetailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockTransferDetail.
     * @param {StockTransferDetailUpsertArgs} args - Arguments to update or create a StockTransferDetail.
     * @example
     * // Update or create a StockTransferDetail
     * const stockTransferDetail = await prisma.stockTransferDetail.upsert({
     *   create: {
     *     // ... data to create a StockTransferDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockTransferDetail we want to update
     *   }
     * })
    **/
    upsert<T extends StockTransferDetailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockTransferDetailUpsertArgs<ExtArgs>>
    ): Prisma__StockTransferDetailClient<$Result.GetResult<Prisma.$StockTransferDetailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockTransferDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferDetailCountArgs} args - Arguments to filter StockTransferDetails to count.
     * @example
     * // Count the number of StockTransferDetails
     * const count = await prisma.stockTransferDetail.count({
     *   where: {
     *     // ... the filter for the StockTransferDetails we want to count
     *   }
     * })
    **/
    count<T extends StockTransferDetailCountArgs>(
      args?: Subset<T, StockTransferDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockTransferDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockTransferDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockTransferDetailAggregateArgs>(args: Subset<T, StockTransferDetailAggregateArgs>): Prisma.PrismaPromise<GetStockTransferDetailAggregateType<T>>

    /**
     * Group by StockTransferDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockTransferDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockTransferDetailGroupByArgs['orderBy'] }
        : { orderBy?: StockTransferDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockTransferDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockTransferDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockTransferDetail model
   */
  readonly fields: StockTransferDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockTransferDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockTransferDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    transfer<T extends StockTransferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockTransferDefaultArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockTransferDetail model
   */ 
  interface StockTransferDetailFieldRefs {
    readonly id: FieldRef<"StockTransferDetail", 'String'>
    readonly transferId: FieldRef<"StockTransferDetail", 'String'>
    readonly productId: FieldRef<"StockTransferDetail", 'String'>
    readonly quantity: FieldRef<"StockTransferDetail", 'Decimal'>
  }
    

  // Custom InputTypes

  /**
   * StockTransferDetail findUnique
   */
  export type StockTransferDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferDetail
     */
    select?: StockTransferDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferDetailInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferDetail to fetch.
     */
    where: StockTransferDetailWhereUniqueInput
  }


  /**
   * StockTransferDetail findUniqueOrThrow
   */
  export type StockTransferDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferDetail
     */
    select?: StockTransferDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferDetailInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferDetail to fetch.
     */
    where: StockTransferDetailWhereUniqueInput
  }


  /**
   * StockTransferDetail findFirst
   */
  export type StockTransferDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferDetail
     */
    select?: StockTransferDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferDetailInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferDetail to fetch.
     */
    where?: StockTransferDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransferDetails to fetch.
     */
    orderBy?: StockTransferDetailOrderByWithRelationInput | StockTransferDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransferDetails.
     */
    cursor?: StockTransferDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransferDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransferDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransferDetails.
     */
    distinct?: StockTransferDetailScalarFieldEnum | StockTransferDetailScalarFieldEnum[]
  }


  /**
   * StockTransferDetail findFirstOrThrow
   */
  export type StockTransferDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferDetail
     */
    select?: StockTransferDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferDetailInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferDetail to fetch.
     */
    where?: StockTransferDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransferDetails to fetch.
     */
    orderBy?: StockTransferDetailOrderByWithRelationInput | StockTransferDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransferDetails.
     */
    cursor?: StockTransferDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransferDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransferDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransferDetails.
     */
    distinct?: StockTransferDetailScalarFieldEnum | StockTransferDetailScalarFieldEnum[]
  }


  /**
   * StockTransferDetail findMany
   */
  export type StockTransferDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferDetail
     */
    select?: StockTransferDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferDetailInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferDetails to fetch.
     */
    where?: StockTransferDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransferDetails to fetch.
     */
    orderBy?: StockTransferDetailOrderByWithRelationInput | StockTransferDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockTransferDetails.
     */
    cursor?: StockTransferDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransferDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransferDetails.
     */
    skip?: number
    distinct?: StockTransferDetailScalarFieldEnum | StockTransferDetailScalarFieldEnum[]
  }


  /**
   * StockTransferDetail create
   */
  export type StockTransferDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferDetail
     */
    select?: StockTransferDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a StockTransferDetail.
     */
    data: XOR<StockTransferDetailCreateInput, StockTransferDetailUncheckedCreateInput>
  }


  /**
   * StockTransferDetail update
   */
  export type StockTransferDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferDetail
     */
    select?: StockTransferDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a StockTransferDetail.
     */
    data: XOR<StockTransferDetailUpdateInput, StockTransferDetailUncheckedUpdateInput>
    /**
     * Choose, which StockTransferDetail to update.
     */
    where: StockTransferDetailWhereUniqueInput
  }


  /**
   * StockTransferDetail updateMany
   */
  export type StockTransferDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockTransferDetails.
     */
    data: XOR<StockTransferDetailUpdateManyMutationInput, StockTransferDetailUncheckedUpdateManyInput>
    /**
     * Filter which StockTransferDetails to update
     */
    where?: StockTransferDetailWhereInput
  }


  /**
   * StockTransferDetail upsert
   */
  export type StockTransferDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferDetail
     */
    select?: StockTransferDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the StockTransferDetail to update in case it exists.
     */
    where: StockTransferDetailWhereUniqueInput
    /**
     * In case the StockTransferDetail found by the `where` argument doesn't exist, create a new StockTransferDetail with this data.
     */
    create: XOR<StockTransferDetailCreateInput, StockTransferDetailUncheckedCreateInput>
    /**
     * In case the StockTransferDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockTransferDetailUpdateInput, StockTransferDetailUncheckedUpdateInput>
  }


  /**
   * StockTransferDetail delete
   */
  export type StockTransferDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferDetail
     */
    select?: StockTransferDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferDetailInclude<ExtArgs> | null
    /**
     * Filter which StockTransferDetail to delete.
     */
    where: StockTransferDetailWhereUniqueInput
  }


  /**
   * StockTransferDetail deleteMany
   */
  export type StockTransferDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransferDetails to delete
     */
    where?: StockTransferDetailWhereInput
  }


  /**
   * StockTransferDetail without action
   */
  export type StockTransferDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferDetail
     */
    select?: StockTransferDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockTransferDetailInclude<ExtArgs> | null
  }



  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: string
    key: string
    value: string
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
  }


  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }


  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SystemSettingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SystemSetting that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SystemSettingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SystemSettingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
    **/
    create<T extends SystemSettingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
    **/
    delete<T extends SystemSettingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SystemSettingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SystemSettingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SystemSettingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
    **/
    upsert<T extends SystemSettingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>
    ): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SystemSetting model
   */ 
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'String'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }


  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }


  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }


  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }


  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }


  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }


  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }


  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
  }


  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }


  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }


  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
  }


  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    branchId: 'branchId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    cost: 'cost',
    priceRetail: 'priceRetail',
    priceWholesale: 'priceWholesale',
    unit: 'unit',
    isActive: 'isActive',
    minStock: 'minStock',
    expiresAt: 'expiresAt',
    providerId: 'providerId',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProviderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contact: 'contact',
    phone: 'phone',
    email: 'email',
    rfc: 'rfc',
    address: 'address'
  };

  export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const ProductBranchScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    branchId: 'branchId',
    quantity: 'quantity'
  };

  export type ProductBranchScalarFieldEnum = (typeof ProductBranchScalarFieldEnum)[keyof typeof ProductBranchScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    rfc: 'rfc',
    taxRegime: 'taxRegime',
    address: 'address',
    zipCode: 'zipCode',
    creditLimit: 'creditLimit',
    currentBalance: 'currentBalance',
    branchId: 'branchId',
    createdAt: 'createdAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SaleHeaderScalarFieldEnum: {
    id: 'id',
    date: 'date',
    total: 'total',
    paymentMethod: 'paymentMethod',
    status: 'status',
    branchId: 'branchId',
    userId: 'userId',
    shiftId: 'shiftId',
    customerId: 'customerId'
  };

  export type SaleHeaderScalarFieldEnum = (typeof SaleHeaderScalarFieldEnum)[keyof typeof SaleHeaderScalarFieldEnum]


  export const SaleDetailScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    subtotal: 'subtotal'
  };

  export type SaleDetailScalarFieldEnum = (typeof SaleDetailScalarFieldEnum)[keyof typeof SaleDetailScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    date: 'date',
    amount: 'amount',
    description: 'description',
    category: 'category',
    imageUrl: 'imageUrl',
    branchId: 'branchId'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    date: 'date',
    total: 'total',
    status: 'status',
    providerId: 'providerId',
    branchId: 'branchId'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const CreditPaymentScalarFieldEnum: {
    id: 'id',
    date: 'date',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    customerId: 'customerId',
    saleId: 'saleId'
  };

  export type CreditPaymentScalarFieldEnum = (typeof CreditPaymentScalarFieldEnum)[keyof typeof CreditPaymentScalarFieldEnum]


  export const EmployeeShiftScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    startTime: 'startTime',
    endTime: 'endTime',
    initialCash: 'initialCash',
    finalCashExpected: 'finalCashExpected',
    finalCashActual: 'finalCashActual',
    difference: 'difference'
  };

  export type EmployeeShiftScalarFieldEnum = (typeof EmployeeShiftScalarFieldEnum)[keyof typeof EmployeeShiftScalarFieldEnum]


  export const CashCountScalarFieldEnum: {
    id: 'id',
    shiftId: 'shiftId',
    denomination: 'denomination',
    quantity: 'quantity',
    type: 'type'
  };

  export type CashCountScalarFieldEnum = (typeof CashCountScalarFieldEnum)[keyof typeof CashCountScalarFieldEnum]


  export const CashMovementScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    reason: 'reason',
    date: 'date',
    userId: 'userId',
    branchId: 'branchId'
  };

  export type CashMovementScalarFieldEnum = (typeof CashMovementScalarFieldEnum)[keyof typeof CashMovementScalarFieldEnum]


  export const InventoryAdjustmentScalarFieldEnum: {
    id: 'id',
    date: 'date',
    quantity: 'quantity',
    reason: 'reason',
    productId: 'productId',
    userId: 'userId'
  };

  export type InventoryAdjustmentScalarFieldEnum = (typeof InventoryAdjustmentScalarFieldEnum)[keyof typeof InventoryAdjustmentScalarFieldEnum]


  export const SystemLogScalarFieldEnum: {
    id: 'id',
    date: 'date',
    action: 'action',
    details: 'details',
    userId: 'userId'
  };

  export type SystemLogScalarFieldEnum = (typeof SystemLogScalarFieldEnum)[keyof typeof SystemLogScalarFieldEnum]


  export const StockTransferScalarFieldEnum: {
    id: 'id',
    date: 'date',
    status: 'status',
    sourceBranchId: 'sourceBranchId',
    destBranchId: 'destBranchId'
  };

  export type StockTransferScalarFieldEnum = (typeof StockTransferScalarFieldEnum)[keyof typeof StockTransferScalarFieldEnum]


  export const StockTransferDetailScalarFieldEnum: {
    id: 'id',
    transferId: 'transferId',
    productId: 'productId',
    quantity: 'quantity'
  };

  export type StockTransferDetailScalarFieldEnum = (typeof StockTransferDetailScalarFieldEnum)[keyof typeof StockTransferDetailScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    permissions?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    branchId?: StringNullableFilter<"User"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    shifts?: EmployeeShiftListRelationFilter
    sales?: SaleHeaderListRelationFilter
    inventoryAdjustments?: InventoryAdjustmentListRelationFilter
    systemLogs?: SystemLogListRelationFilter
    cashMovements?: CashMovementListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
    shifts?: EmployeeShiftOrderByRelationAggregateInput
    sales?: SaleHeaderOrderByRelationAggregateInput
    inventoryAdjustments?: InventoryAdjustmentOrderByRelationAggregateInput
    systemLogs?: SystemLogOrderByRelationAggregateInput
    cashMovements?: CashMovementOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    permissions?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    branchId?: StringNullableFilter<"User"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    shifts?: EmployeeShiftListRelationFilter
    sales?: SaleHeaderListRelationFilter
    inventoryAdjustments?: InventoryAdjustmentListRelationFilter
    systemLogs?: SystemLogListRelationFilter
    cashMovements?: CashMovementListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    permissions?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    branchId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    code?: StringNullableFilter<"Product"> | string | null
    cost?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    priceRetail?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringFilter<"Product"> | string
    isActive?: BoolFilter<"Product"> | boolean
    minStock?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    expiresAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    providerId?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    provider?: XOR<ProviderNullableRelationFilter, ProviderWhereInput> | null
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    inventory?: ProductBranchListRelationFilter
    saleDetails?: SaleDetailListRelationFilter
    adjustments?: InventoryAdjustmentListRelationFilter
    transferDetails?: StockTransferDetailListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    priceRetail?: SortOrderInput | SortOrder
    priceWholesale?: SortOrderInput | SortOrder
    unit?: SortOrder
    isActive?: SortOrder
    minStock?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: ProviderOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    inventory?: ProductBranchOrderByRelationAggregateInput
    saleDetails?: SaleDetailOrderByRelationAggregateInput
    adjustments?: InventoryAdjustmentOrderByRelationAggregateInput
    transferDetails?: StockTransferDetailOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    cost?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    priceRetail?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringFilter<"Product"> | string
    isActive?: BoolFilter<"Product"> | boolean
    minStock?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    expiresAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    providerId?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    provider?: XOR<ProviderNullableRelationFilter, ProviderWhereInput> | null
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    inventory?: ProductBranchListRelationFilter
    saleDetails?: SaleDetailListRelationFilter
    adjustments?: InventoryAdjustmentListRelationFilter
    transferDetails?: StockTransferDetailListRelationFilter
  }, "id" | "code">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    priceRetail?: SortOrderInput | SortOrder
    priceWholesale?: SortOrderInput | SortOrder
    unit?: SortOrder
    isActive?: SortOrder
    minStock?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    code?: StringNullableWithAggregatesFilter<"Product"> | string | null
    cost?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    priceRetail?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringWithAggregatesFilter<"Product"> | string
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    minStock?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    providerId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    products?: ProductListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
  }

  export type ProviderWhereInput = {
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    id?: StringFilter<"Provider"> | string
    name?: StringFilter<"Provider"> | string
    contact?: StringNullableFilter<"Provider"> | string | null
    phone?: StringNullableFilter<"Provider"> | string | null
    email?: StringNullableFilter<"Provider"> | string | null
    rfc?: StringNullableFilter<"Provider"> | string | null
    address?: StringNullableFilter<"Provider"> | string | null
    products?: ProductListRelationFilter
    purchases?: PurchaseListRelationFilter
  }

  export type ProviderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    rfc?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
  }

  export type ProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    name?: StringFilter<"Provider"> | string
    contact?: StringNullableFilter<"Provider"> | string | null
    phone?: StringNullableFilter<"Provider"> | string | null
    email?: StringNullableFilter<"Provider"> | string | null
    rfc?: StringNullableFilter<"Provider"> | string | null
    address?: StringNullableFilter<"Provider"> | string | null
    products?: ProductListRelationFilter
    purchases?: PurchaseListRelationFilter
  }, "id">

  export type ProviderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    rfc?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    _count?: ProviderCountOrderByAggregateInput
    _max?: ProviderMaxOrderByAggregateInput
    _min?: ProviderMinOrderByAggregateInput
  }

  export type ProviderScalarWhereWithAggregatesInput = {
    AND?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    OR?: ProviderScalarWhereWithAggregatesInput[]
    NOT?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Provider"> | string
    name?: StringWithAggregatesFilter<"Provider"> | string
    contact?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    email?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    rfc?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    address?: StringNullableWithAggregatesFilter<"Provider"> | string | null
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    phone?: StringNullableFilter<"Branch"> | string | null
    inventory?: ProductBranchListRelationFilter
    sales?: SaleHeaderListRelationFilter
    expenses?: ExpenseListRelationFilter
    purchases?: PurchaseListRelationFilter
    cashMovements?: CashMovementListRelationFilter
    customers?: CustomerListRelationFilter
    users?: UserListRelationFilter
    sentTransfers?: StockTransferListRelationFilter
    receivedTransfers?: StockTransferListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    inventory?: ProductBranchOrderByRelationAggregateInput
    sales?: SaleHeaderOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    cashMovements?: CashMovementOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    sentTransfers?: StockTransferOrderByRelationAggregateInput
    receivedTransfers?: StockTransferOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    phone?: StringNullableFilter<"Branch"> | string | null
    inventory?: ProductBranchListRelationFilter
    sales?: SaleHeaderListRelationFilter
    expenses?: ExpenseListRelationFilter
    purchases?: PurchaseListRelationFilter
    cashMovements?: CashMovementListRelationFilter
    customers?: CustomerListRelationFilter
    users?: UserListRelationFilter
    sentTransfers?: StockTransferListRelationFilter
    receivedTransfers?: StockTransferListRelationFilter
  }, "id">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: BranchCountOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Branch"> | string
    name?: StringWithAggregatesFilter<"Branch"> | string
    address?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Branch"> | string | null
  }

  export type ProductBranchWhereInput = {
    AND?: ProductBranchWhereInput | ProductBranchWhereInput[]
    OR?: ProductBranchWhereInput[]
    NOT?: ProductBranchWhereInput | ProductBranchWhereInput[]
    id?: StringFilter<"ProductBranch"> | string
    productId?: StringFilter<"ProductBranch"> | string
    branchId?: StringFilter<"ProductBranch"> | string
    quantity?: DecimalFilter<"ProductBranch"> | Decimal | DecimalJsLike | number | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type ProductBranchOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    branchId?: SortOrder
    quantity?: SortOrder
    product?: ProductOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type ProductBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_branchId?: ProductBranchProductIdBranchIdCompoundUniqueInput
    AND?: ProductBranchWhereInput | ProductBranchWhereInput[]
    OR?: ProductBranchWhereInput[]
    NOT?: ProductBranchWhereInput | ProductBranchWhereInput[]
    productId?: StringFilter<"ProductBranch"> | string
    branchId?: StringFilter<"ProductBranch"> | string
    quantity?: DecimalFilter<"ProductBranch"> | Decimal | DecimalJsLike | number | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "productId_branchId">

  export type ProductBranchOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    branchId?: SortOrder
    quantity?: SortOrder
    _count?: ProductBranchCountOrderByAggregateInput
    _avg?: ProductBranchAvgOrderByAggregateInput
    _max?: ProductBranchMaxOrderByAggregateInput
    _min?: ProductBranchMinOrderByAggregateInput
    _sum?: ProductBranchSumOrderByAggregateInput
  }

  export type ProductBranchScalarWhereWithAggregatesInput = {
    AND?: ProductBranchScalarWhereWithAggregatesInput | ProductBranchScalarWhereWithAggregatesInput[]
    OR?: ProductBranchScalarWhereWithAggregatesInput[]
    NOT?: ProductBranchScalarWhereWithAggregatesInput | ProductBranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductBranch"> | string
    productId?: StringWithAggregatesFilter<"ProductBranch"> | string
    branchId?: StringWithAggregatesFilter<"ProductBranch"> | string
    quantity?: DecimalWithAggregatesFilter<"ProductBranch"> | Decimal | DecimalJsLike | number | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    rfc?: StringNullableFilter<"Customer"> | string | null
    taxRegime?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    zipCode?: StringNullableFilter<"Customer"> | string | null
    creditLimit?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    branchId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    sales?: SaleHeaderListRelationFilter
    creditPayments?: CreditPaymentListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    rfc?: SortOrderInput | SortOrder
    taxRegime?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    sales?: SaleHeaderOrderByRelationAggregateInput
    creditPayments?: CreditPaymentOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    rfc?: StringNullableFilter<"Customer"> | string | null
    taxRegime?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    zipCode?: StringNullableFilter<"Customer"> | string | null
    creditLimit?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    branchId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    sales?: SaleHeaderListRelationFilter
    creditPayments?: CreditPaymentListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    rfc?: SortOrderInput | SortOrder
    taxRegime?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    rfc?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    taxRegime?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    creditLimit?: DecimalWithAggregatesFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalWithAggregatesFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    branchId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type SaleHeaderWhereInput = {
    AND?: SaleHeaderWhereInput | SaleHeaderWhereInput[]
    OR?: SaleHeaderWhereInput[]
    NOT?: SaleHeaderWhereInput | SaleHeaderWhereInput[]
    id?: StringFilter<"SaleHeader"> | string
    date?: DateTimeFilter<"SaleHeader"> | Date | string
    total?: DecimalFilter<"SaleHeader"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"SaleHeader"> | string
    status?: StringFilter<"SaleHeader"> | string
    branchId?: StringFilter<"SaleHeader"> | string
    userId?: StringNullableFilter<"SaleHeader"> | string | null
    shiftId?: StringNullableFilter<"SaleHeader"> | string | null
    customerId?: StringNullableFilter<"SaleHeader"> | string | null
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    shift?: XOR<EmployeeShiftNullableRelationFilter, EmployeeShiftWhereInput> | null
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    details?: SaleDetailListRelationFilter
    creditPayment?: CreditPaymentListRelationFilter
  }

  export type SaleHeaderOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    userId?: SortOrderInput | SortOrder
    shiftId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    shift?: EmployeeShiftOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    details?: SaleDetailOrderByRelationAggregateInput
    creditPayment?: CreditPaymentOrderByRelationAggregateInput
  }

  export type SaleHeaderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleHeaderWhereInput | SaleHeaderWhereInput[]
    OR?: SaleHeaderWhereInput[]
    NOT?: SaleHeaderWhereInput | SaleHeaderWhereInput[]
    date?: DateTimeFilter<"SaleHeader"> | Date | string
    total?: DecimalFilter<"SaleHeader"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"SaleHeader"> | string
    status?: StringFilter<"SaleHeader"> | string
    branchId?: StringFilter<"SaleHeader"> | string
    userId?: StringNullableFilter<"SaleHeader"> | string | null
    shiftId?: StringNullableFilter<"SaleHeader"> | string | null
    customerId?: StringNullableFilter<"SaleHeader"> | string | null
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    shift?: XOR<EmployeeShiftNullableRelationFilter, EmployeeShiftWhereInput> | null
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    details?: SaleDetailListRelationFilter
    creditPayment?: CreditPaymentListRelationFilter
  }, "id">

  export type SaleHeaderOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    userId?: SortOrderInput | SortOrder
    shiftId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    _count?: SaleHeaderCountOrderByAggregateInput
    _avg?: SaleHeaderAvgOrderByAggregateInput
    _max?: SaleHeaderMaxOrderByAggregateInput
    _min?: SaleHeaderMinOrderByAggregateInput
    _sum?: SaleHeaderSumOrderByAggregateInput
  }

  export type SaleHeaderScalarWhereWithAggregatesInput = {
    AND?: SaleHeaderScalarWhereWithAggregatesInput | SaleHeaderScalarWhereWithAggregatesInput[]
    OR?: SaleHeaderScalarWhereWithAggregatesInput[]
    NOT?: SaleHeaderScalarWhereWithAggregatesInput | SaleHeaderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleHeader"> | string
    date?: DateTimeWithAggregatesFilter<"SaleHeader"> | Date | string
    total?: DecimalWithAggregatesFilter<"SaleHeader"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringWithAggregatesFilter<"SaleHeader"> | string
    status?: StringWithAggregatesFilter<"SaleHeader"> | string
    branchId?: StringWithAggregatesFilter<"SaleHeader"> | string
    userId?: StringNullableWithAggregatesFilter<"SaleHeader"> | string | null
    shiftId?: StringNullableWithAggregatesFilter<"SaleHeader"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"SaleHeader"> | string | null
  }

  export type SaleDetailWhereInput = {
    AND?: SaleDetailWhereInput | SaleDetailWhereInput[]
    OR?: SaleDetailWhereInput[]
    NOT?: SaleDetailWhereInput | SaleDetailWhereInput[]
    id?: StringFilter<"SaleDetail"> | string
    saleId?: StringFilter<"SaleDetail"> | string
    productId?: StringFilter<"SaleDetail"> | string
    quantity?: DecimalFilter<"SaleDetail"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SaleDetail"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"SaleDetail"> | Decimal | DecimalJsLike | number | string
    sale?: XOR<SaleHeaderRelationFilter, SaleHeaderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type SaleDetailOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    sale?: SaleHeaderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type SaleDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleDetailWhereInput | SaleDetailWhereInput[]
    OR?: SaleDetailWhereInput[]
    NOT?: SaleDetailWhereInput | SaleDetailWhereInput[]
    saleId?: StringFilter<"SaleDetail"> | string
    productId?: StringFilter<"SaleDetail"> | string
    quantity?: DecimalFilter<"SaleDetail"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SaleDetail"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"SaleDetail"> | Decimal | DecimalJsLike | number | string
    sale?: XOR<SaleHeaderRelationFilter, SaleHeaderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type SaleDetailOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    _count?: SaleDetailCountOrderByAggregateInput
    _avg?: SaleDetailAvgOrderByAggregateInput
    _max?: SaleDetailMaxOrderByAggregateInput
    _min?: SaleDetailMinOrderByAggregateInput
    _sum?: SaleDetailSumOrderByAggregateInput
  }

  export type SaleDetailScalarWhereWithAggregatesInput = {
    AND?: SaleDetailScalarWhereWithAggregatesInput | SaleDetailScalarWhereWithAggregatesInput[]
    OR?: SaleDetailScalarWhereWithAggregatesInput[]
    NOT?: SaleDetailScalarWhereWithAggregatesInput | SaleDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleDetail"> | string
    saleId?: StringWithAggregatesFilter<"SaleDetail"> | string
    productId?: StringWithAggregatesFilter<"SaleDetail"> | string
    quantity?: DecimalWithAggregatesFilter<"SaleDetail"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"SaleDetail"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalWithAggregatesFilter<"SaleDetail"> | Decimal | DecimalJsLike | number | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"Expense"> | string
    category?: StringFilter<"Expense"> | string
    imageUrl?: StringNullableFilter<"Expense"> | string | null
    branchId?: StringFilter<"Expense"> | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    branchId?: SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    date?: DateTimeFilter<"Expense"> | Date | string
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"Expense"> | string
    category?: StringFilter<"Expense"> | string
    imageUrl?: StringNullableFilter<"Expense"> | string | null
    branchId?: StringFilter<"Expense"> | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    branchId?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    amount?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    description?: StringWithAggregatesFilter<"Expense"> | string
    category?: StringWithAggregatesFilter<"Expense"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    branchId?: StringWithAggregatesFilter<"Expense"> | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    date?: DateTimeFilter<"Purchase"> | Date | string
    total?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Purchase"> | string
    providerId?: StringFilter<"Purchase"> | string
    branchId?: StringFilter<"Purchase"> | string
    provider?: XOR<ProviderRelationFilter, ProviderWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    status?: SortOrder
    providerId?: SortOrder
    branchId?: SortOrder
    provider?: ProviderOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    date?: DateTimeFilter<"Purchase"> | Date | string
    total?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Purchase"> | string
    providerId?: StringFilter<"Purchase"> | string
    branchId?: StringFilter<"Purchase"> | string
    provider?: XOR<ProviderRelationFilter, ProviderWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    status?: SortOrder
    providerId?: SortOrder
    branchId?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    date?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    total?: DecimalWithAggregatesFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Purchase"> | string
    providerId?: StringWithAggregatesFilter<"Purchase"> | string
    branchId?: StringWithAggregatesFilter<"Purchase"> | string
  }

  export type CreditPaymentWhereInput = {
    AND?: CreditPaymentWhereInput | CreditPaymentWhereInput[]
    OR?: CreditPaymentWhereInput[]
    NOT?: CreditPaymentWhereInput | CreditPaymentWhereInput[]
    id?: StringFilter<"CreditPayment"> | string
    date?: DateTimeFilter<"CreditPayment"> | Date | string
    amount?: DecimalFilter<"CreditPayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"CreditPayment"> | string
    customerId?: StringFilter<"CreditPayment"> | string
    saleId?: StringNullableFilter<"CreditPayment"> | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    sale?: XOR<SaleHeaderNullableRelationFilter, SaleHeaderWhereInput> | null
  }

  export type CreditPaymentOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    sale?: SaleHeaderOrderByWithRelationInput
  }

  export type CreditPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreditPaymentWhereInput | CreditPaymentWhereInput[]
    OR?: CreditPaymentWhereInput[]
    NOT?: CreditPaymentWhereInput | CreditPaymentWhereInput[]
    date?: DateTimeFilter<"CreditPayment"> | Date | string
    amount?: DecimalFilter<"CreditPayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"CreditPayment"> | string
    customerId?: StringFilter<"CreditPayment"> | string
    saleId?: StringNullableFilter<"CreditPayment"> | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    sale?: XOR<SaleHeaderNullableRelationFilter, SaleHeaderWhereInput> | null
  }, "id">

  export type CreditPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrderInput | SortOrder
    _count?: CreditPaymentCountOrderByAggregateInput
    _avg?: CreditPaymentAvgOrderByAggregateInput
    _max?: CreditPaymentMaxOrderByAggregateInput
    _min?: CreditPaymentMinOrderByAggregateInput
    _sum?: CreditPaymentSumOrderByAggregateInput
  }

  export type CreditPaymentScalarWhereWithAggregatesInput = {
    AND?: CreditPaymentScalarWhereWithAggregatesInput | CreditPaymentScalarWhereWithAggregatesInput[]
    OR?: CreditPaymentScalarWhereWithAggregatesInput[]
    NOT?: CreditPaymentScalarWhereWithAggregatesInput | CreditPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditPayment"> | string
    date?: DateTimeWithAggregatesFilter<"CreditPayment"> | Date | string
    amount?: DecimalWithAggregatesFilter<"CreditPayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringWithAggregatesFilter<"CreditPayment"> | string
    customerId?: StringWithAggregatesFilter<"CreditPayment"> | string
    saleId?: StringNullableWithAggregatesFilter<"CreditPayment"> | string | null
  }

  export type EmployeeShiftWhereInput = {
    AND?: EmployeeShiftWhereInput | EmployeeShiftWhereInput[]
    OR?: EmployeeShiftWhereInput[]
    NOT?: EmployeeShiftWhereInput | EmployeeShiftWhereInput[]
    id?: StringFilter<"EmployeeShift"> | string
    userId?: StringFilter<"EmployeeShift"> | string
    startTime?: DateTimeFilter<"EmployeeShift"> | Date | string
    endTime?: DateTimeNullableFilter<"EmployeeShift"> | Date | string | null
    initialCash?: DecimalFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string
    finalCashExpected?: DecimalNullableFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: DecimalNullableFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string | null
    difference?: DecimalNullableFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    cashCounts?: CashCountListRelationFilter
    sales?: SaleHeaderListRelationFilter
  }

  export type EmployeeShiftOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    initialCash?: SortOrder
    finalCashExpected?: SortOrderInput | SortOrder
    finalCashActual?: SortOrderInput | SortOrder
    difference?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    cashCounts?: CashCountOrderByRelationAggregateInput
    sales?: SaleHeaderOrderByRelationAggregateInput
  }

  export type EmployeeShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeShiftWhereInput | EmployeeShiftWhereInput[]
    OR?: EmployeeShiftWhereInput[]
    NOT?: EmployeeShiftWhereInput | EmployeeShiftWhereInput[]
    userId?: StringFilter<"EmployeeShift"> | string
    startTime?: DateTimeFilter<"EmployeeShift"> | Date | string
    endTime?: DateTimeNullableFilter<"EmployeeShift"> | Date | string | null
    initialCash?: DecimalFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string
    finalCashExpected?: DecimalNullableFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: DecimalNullableFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string | null
    difference?: DecimalNullableFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    cashCounts?: CashCountListRelationFilter
    sales?: SaleHeaderListRelationFilter
  }, "id">

  export type EmployeeShiftOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    initialCash?: SortOrder
    finalCashExpected?: SortOrderInput | SortOrder
    finalCashActual?: SortOrderInput | SortOrder
    difference?: SortOrderInput | SortOrder
    _count?: EmployeeShiftCountOrderByAggregateInput
    _avg?: EmployeeShiftAvgOrderByAggregateInput
    _max?: EmployeeShiftMaxOrderByAggregateInput
    _min?: EmployeeShiftMinOrderByAggregateInput
    _sum?: EmployeeShiftSumOrderByAggregateInput
  }

  export type EmployeeShiftScalarWhereWithAggregatesInput = {
    AND?: EmployeeShiftScalarWhereWithAggregatesInput | EmployeeShiftScalarWhereWithAggregatesInput[]
    OR?: EmployeeShiftScalarWhereWithAggregatesInput[]
    NOT?: EmployeeShiftScalarWhereWithAggregatesInput | EmployeeShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeShift"> | string
    userId?: StringWithAggregatesFilter<"EmployeeShift"> | string
    startTime?: DateTimeWithAggregatesFilter<"EmployeeShift"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"EmployeeShift"> | Date | string | null
    initialCash?: DecimalWithAggregatesFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string
    finalCashExpected?: DecimalNullableWithAggregatesFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: DecimalNullableWithAggregatesFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string | null
    difference?: DecimalNullableWithAggregatesFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string | null
  }

  export type CashCountWhereInput = {
    AND?: CashCountWhereInput | CashCountWhereInput[]
    OR?: CashCountWhereInput[]
    NOT?: CashCountWhereInput | CashCountWhereInput[]
    id?: StringFilter<"CashCount"> | string
    shiftId?: StringFilter<"CashCount"> | string
    denomination?: DecimalFilter<"CashCount"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"CashCount"> | number
    type?: StringFilter<"CashCount"> | string
    shift?: XOR<EmployeeShiftRelationFilter, EmployeeShiftWhereInput>
  }

  export type CashCountOrderByWithRelationInput = {
    id?: SortOrder
    shiftId?: SortOrder
    denomination?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    shift?: EmployeeShiftOrderByWithRelationInput
  }

  export type CashCountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashCountWhereInput | CashCountWhereInput[]
    OR?: CashCountWhereInput[]
    NOT?: CashCountWhereInput | CashCountWhereInput[]
    shiftId?: StringFilter<"CashCount"> | string
    denomination?: DecimalFilter<"CashCount"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"CashCount"> | number
    type?: StringFilter<"CashCount"> | string
    shift?: XOR<EmployeeShiftRelationFilter, EmployeeShiftWhereInput>
  }, "id">

  export type CashCountOrderByWithAggregationInput = {
    id?: SortOrder
    shiftId?: SortOrder
    denomination?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    _count?: CashCountCountOrderByAggregateInput
    _avg?: CashCountAvgOrderByAggregateInput
    _max?: CashCountMaxOrderByAggregateInput
    _min?: CashCountMinOrderByAggregateInput
    _sum?: CashCountSumOrderByAggregateInput
  }

  export type CashCountScalarWhereWithAggregatesInput = {
    AND?: CashCountScalarWhereWithAggregatesInput | CashCountScalarWhereWithAggregatesInput[]
    OR?: CashCountScalarWhereWithAggregatesInput[]
    NOT?: CashCountScalarWhereWithAggregatesInput | CashCountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashCount"> | string
    shiftId?: StringWithAggregatesFilter<"CashCount"> | string
    denomination?: DecimalWithAggregatesFilter<"CashCount"> | Decimal | DecimalJsLike | number | string
    quantity?: IntWithAggregatesFilter<"CashCount"> | number
    type?: StringWithAggregatesFilter<"CashCount"> | string
  }

  export type CashMovementWhereInput = {
    AND?: CashMovementWhereInput | CashMovementWhereInput[]
    OR?: CashMovementWhereInput[]
    NOT?: CashMovementWhereInput | CashMovementWhereInput[]
    id?: StringFilter<"CashMovement"> | string
    type?: StringFilter<"CashMovement"> | string
    amount?: DecimalFilter<"CashMovement"> | Decimal | DecimalJsLike | number | string
    reason?: StringFilter<"CashMovement"> | string
    date?: DateTimeFilter<"CashMovement"> | Date | string
    userId?: StringFilter<"CashMovement"> | string
    branchId?: StringFilter<"CashMovement"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type CashMovementOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    user?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type CashMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashMovementWhereInput | CashMovementWhereInput[]
    OR?: CashMovementWhereInput[]
    NOT?: CashMovementWhereInput | CashMovementWhereInput[]
    type?: StringFilter<"CashMovement"> | string
    amount?: DecimalFilter<"CashMovement"> | Decimal | DecimalJsLike | number | string
    reason?: StringFilter<"CashMovement"> | string
    date?: DateTimeFilter<"CashMovement"> | Date | string
    userId?: StringFilter<"CashMovement"> | string
    branchId?: StringFilter<"CashMovement"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id">

  export type CashMovementOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    _count?: CashMovementCountOrderByAggregateInput
    _avg?: CashMovementAvgOrderByAggregateInput
    _max?: CashMovementMaxOrderByAggregateInput
    _min?: CashMovementMinOrderByAggregateInput
    _sum?: CashMovementSumOrderByAggregateInput
  }

  export type CashMovementScalarWhereWithAggregatesInput = {
    AND?: CashMovementScalarWhereWithAggregatesInput | CashMovementScalarWhereWithAggregatesInput[]
    OR?: CashMovementScalarWhereWithAggregatesInput[]
    NOT?: CashMovementScalarWhereWithAggregatesInput | CashMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashMovement"> | string
    type?: StringWithAggregatesFilter<"CashMovement"> | string
    amount?: DecimalWithAggregatesFilter<"CashMovement"> | Decimal | DecimalJsLike | number | string
    reason?: StringWithAggregatesFilter<"CashMovement"> | string
    date?: DateTimeWithAggregatesFilter<"CashMovement"> | Date | string
    userId?: StringWithAggregatesFilter<"CashMovement"> | string
    branchId?: StringWithAggregatesFilter<"CashMovement"> | string
  }

  export type InventoryAdjustmentWhereInput = {
    AND?: InventoryAdjustmentWhereInput | InventoryAdjustmentWhereInput[]
    OR?: InventoryAdjustmentWhereInput[]
    NOT?: InventoryAdjustmentWhereInput | InventoryAdjustmentWhereInput[]
    id?: StringFilter<"InventoryAdjustment"> | string
    date?: DateTimeFilter<"InventoryAdjustment"> | Date | string
    quantity?: DecimalFilter<"InventoryAdjustment"> | Decimal | DecimalJsLike | number | string
    reason?: StringFilter<"InventoryAdjustment"> | string
    productId?: StringFilter<"InventoryAdjustment"> | string
    userId?: StringFilter<"InventoryAdjustment"> | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InventoryAdjustmentOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InventoryAdjustmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryAdjustmentWhereInput | InventoryAdjustmentWhereInput[]
    OR?: InventoryAdjustmentWhereInput[]
    NOT?: InventoryAdjustmentWhereInput | InventoryAdjustmentWhereInput[]
    date?: DateTimeFilter<"InventoryAdjustment"> | Date | string
    quantity?: DecimalFilter<"InventoryAdjustment"> | Decimal | DecimalJsLike | number | string
    reason?: StringFilter<"InventoryAdjustment"> | string
    productId?: StringFilter<"InventoryAdjustment"> | string
    userId?: StringFilter<"InventoryAdjustment"> | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type InventoryAdjustmentOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    _count?: InventoryAdjustmentCountOrderByAggregateInput
    _avg?: InventoryAdjustmentAvgOrderByAggregateInput
    _max?: InventoryAdjustmentMaxOrderByAggregateInput
    _min?: InventoryAdjustmentMinOrderByAggregateInput
    _sum?: InventoryAdjustmentSumOrderByAggregateInput
  }

  export type InventoryAdjustmentScalarWhereWithAggregatesInput = {
    AND?: InventoryAdjustmentScalarWhereWithAggregatesInput | InventoryAdjustmentScalarWhereWithAggregatesInput[]
    OR?: InventoryAdjustmentScalarWhereWithAggregatesInput[]
    NOT?: InventoryAdjustmentScalarWhereWithAggregatesInput | InventoryAdjustmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryAdjustment"> | string
    date?: DateTimeWithAggregatesFilter<"InventoryAdjustment"> | Date | string
    quantity?: DecimalWithAggregatesFilter<"InventoryAdjustment"> | Decimal | DecimalJsLike | number | string
    reason?: StringWithAggregatesFilter<"InventoryAdjustment"> | string
    productId?: StringWithAggregatesFilter<"InventoryAdjustment"> | string
    userId?: StringWithAggregatesFilter<"InventoryAdjustment"> | string
  }

  export type SystemLogWhereInput = {
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    id?: StringFilter<"SystemLog"> | string
    date?: DateTimeFilter<"SystemLog"> | Date | string
    action?: StringFilter<"SystemLog"> | string
    details?: StringNullableFilter<"SystemLog"> | string | null
    userId?: StringFilter<"SystemLog"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SystemLogOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SystemLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    date?: DateTimeFilter<"SystemLog"> | Date | string
    action?: StringFilter<"SystemLog"> | string
    details?: StringNullableFilter<"SystemLog"> | string | null
    userId?: StringFilter<"SystemLog"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SystemLogOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SystemLogCountOrderByAggregateInput
    _max?: SystemLogMaxOrderByAggregateInput
    _min?: SystemLogMinOrderByAggregateInput
  }

  export type SystemLogScalarWhereWithAggregatesInput = {
    AND?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    OR?: SystemLogScalarWhereWithAggregatesInput[]
    NOT?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemLog"> | string
    date?: DateTimeWithAggregatesFilter<"SystemLog"> | Date | string
    action?: StringWithAggregatesFilter<"SystemLog"> | string
    details?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    userId?: StringWithAggregatesFilter<"SystemLog"> | string
  }

  export type StockTransferWhereInput = {
    AND?: StockTransferWhereInput | StockTransferWhereInput[]
    OR?: StockTransferWhereInput[]
    NOT?: StockTransferWhereInput | StockTransferWhereInput[]
    id?: StringFilter<"StockTransfer"> | string
    date?: DateTimeFilter<"StockTransfer"> | Date | string
    status?: StringFilter<"StockTransfer"> | string
    sourceBranchId?: StringFilter<"StockTransfer"> | string
    destBranchId?: StringFilter<"StockTransfer"> | string
    sourceBranch?: XOR<BranchRelationFilter, BranchWhereInput>
    destBranch?: XOR<BranchRelationFilter, BranchWhereInput>
    details?: StockTransferDetailListRelationFilter
  }

  export type StockTransferOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    sourceBranchId?: SortOrder
    destBranchId?: SortOrder
    sourceBranch?: BranchOrderByWithRelationInput
    destBranch?: BranchOrderByWithRelationInput
    details?: StockTransferDetailOrderByRelationAggregateInput
  }

  export type StockTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockTransferWhereInput | StockTransferWhereInput[]
    OR?: StockTransferWhereInput[]
    NOT?: StockTransferWhereInput | StockTransferWhereInput[]
    date?: DateTimeFilter<"StockTransfer"> | Date | string
    status?: StringFilter<"StockTransfer"> | string
    sourceBranchId?: StringFilter<"StockTransfer"> | string
    destBranchId?: StringFilter<"StockTransfer"> | string
    sourceBranch?: XOR<BranchRelationFilter, BranchWhereInput>
    destBranch?: XOR<BranchRelationFilter, BranchWhereInput>
    details?: StockTransferDetailListRelationFilter
  }, "id">

  export type StockTransferOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    sourceBranchId?: SortOrder
    destBranchId?: SortOrder
    _count?: StockTransferCountOrderByAggregateInput
    _max?: StockTransferMaxOrderByAggregateInput
    _min?: StockTransferMinOrderByAggregateInput
  }

  export type StockTransferScalarWhereWithAggregatesInput = {
    AND?: StockTransferScalarWhereWithAggregatesInput | StockTransferScalarWhereWithAggregatesInput[]
    OR?: StockTransferScalarWhereWithAggregatesInput[]
    NOT?: StockTransferScalarWhereWithAggregatesInput | StockTransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockTransfer"> | string
    date?: DateTimeWithAggregatesFilter<"StockTransfer"> | Date | string
    status?: StringWithAggregatesFilter<"StockTransfer"> | string
    sourceBranchId?: StringWithAggregatesFilter<"StockTransfer"> | string
    destBranchId?: StringWithAggregatesFilter<"StockTransfer"> | string
  }

  export type StockTransferDetailWhereInput = {
    AND?: StockTransferDetailWhereInput | StockTransferDetailWhereInput[]
    OR?: StockTransferDetailWhereInput[]
    NOT?: StockTransferDetailWhereInput | StockTransferDetailWhereInput[]
    id?: StringFilter<"StockTransferDetail"> | string
    transferId?: StringFilter<"StockTransferDetail"> | string
    productId?: StringFilter<"StockTransferDetail"> | string
    quantity?: DecimalFilter<"StockTransferDetail"> | Decimal | DecimalJsLike | number | string
    transfer?: XOR<StockTransferRelationFilter, StockTransferWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type StockTransferDetailOrderByWithRelationInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    transfer?: StockTransferOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type StockTransferDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockTransferDetailWhereInput | StockTransferDetailWhereInput[]
    OR?: StockTransferDetailWhereInput[]
    NOT?: StockTransferDetailWhereInput | StockTransferDetailWhereInput[]
    transferId?: StringFilter<"StockTransferDetail"> | string
    productId?: StringFilter<"StockTransferDetail"> | string
    quantity?: DecimalFilter<"StockTransferDetail"> | Decimal | DecimalJsLike | number | string
    transfer?: XOR<StockTransferRelationFilter, StockTransferWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type StockTransferDetailOrderByWithAggregationInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    _count?: StockTransferDetailCountOrderByAggregateInput
    _avg?: StockTransferDetailAvgOrderByAggregateInput
    _max?: StockTransferDetailMaxOrderByAggregateInput
    _min?: StockTransferDetailMinOrderByAggregateInput
    _sum?: StockTransferDetailSumOrderByAggregateInput
  }

  export type StockTransferDetailScalarWhereWithAggregatesInput = {
    AND?: StockTransferDetailScalarWhereWithAggregatesInput | StockTransferDetailScalarWhereWithAggregatesInput[]
    OR?: StockTransferDetailScalarWhereWithAggregatesInput[]
    NOT?: StockTransferDetailScalarWhereWithAggregatesInput | StockTransferDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockTransferDetail"> | string
    transferId?: StringWithAggregatesFilter<"StockTransferDetail"> | string
    productId?: StringWithAggregatesFilter<"StockTransferDetail"> | string
    quantity?: DecimalWithAggregatesFilter<"StockTransferDetail"> | Decimal | DecimalJsLike | number | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: StringFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSetting"> | string
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    shifts?: EmployeeShiftCreateNestedManyWithoutUserInput
    sales?: SaleHeaderCreateNestedManyWithoutUserInput
    inventoryAdjustments?: InventoryAdjustmentCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    cashMovements?: CashMovementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId?: string | null
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutUserInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutUserInput
    inventoryAdjustments?: InventoryAdjustmentUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutUserNestedInput
    sales?: SaleHeaderUpdateManyWithoutUserNestedInput
    inventoryAdjustments?: InventoryAdjustmentUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    cashMovements?: CashMovementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutUserNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutUserNestedInput
    inventoryAdjustments?: InventoryAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider?: ProviderCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    inventory?: ProductBranchCreateNestedManyWithoutProductInput
    saleDetails?: SaleDetailCreateNestedManyWithoutProductInput
    adjustments?: InventoryAdjustmentCreateNestedManyWithoutProductInput
    transferDetails?: StockTransferDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    providerId?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutProductInput
    saleDetails?: SaleDetailUncheckedCreateNestedManyWithoutProductInput
    adjustments?: InventoryAdjustmentUncheckedCreateNestedManyWithoutProductInput
    transferDetails?: StockTransferDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inventory?: ProductBranchUpdateManyWithoutProductNestedInput
    saleDetails?: SaleDetailUpdateManyWithoutProductNestedInput
    adjustments?: InventoryAdjustmentUpdateManyWithoutProductNestedInput
    transferDetails?: StockTransferDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductBranchUncheckedUpdateManyWithoutProductNestedInput
    saleDetails?: SaleDetailUncheckedUpdateManyWithoutProductNestedInput
    adjustments?: InventoryAdjustmentUncheckedUpdateManyWithoutProductNestedInput
    transferDetails?: StockTransferDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderCreateInput = {
    id?: string
    name: string
    contact?: string | null
    phone?: string | null
    email?: string | null
    rfc?: string | null
    address?: string | null
    products?: ProductCreateNestedManyWithoutProviderInput
    purchases?: PurchaseCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateInput = {
    id?: string
    name: string
    contact?: string | null
    phone?: string | null
    email?: string | null
    rfc?: string | null
    address?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutProviderInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutProviderNestedInput
    purchases?: PurchaseUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutProviderNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BranchCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    purchases?: PurchaseCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementCreateNestedManyWithoutBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferCreateNestedManyWithoutDestBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferUncheckedCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferUncheckedCreateNestedManyWithoutDestBranchInput
  }

  export type BranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUpdateManyWithoutBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUpdateManyWithoutDestBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUncheckedUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUncheckedUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUncheckedUpdateManyWithoutDestBranchNestedInput
  }

  export type BranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductBranchCreateInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    product: ProductCreateNestedOneWithoutInventoryInput
    branch: BranchCreateNestedOneWithoutInventoryInput
  }

  export type ProductBranchUncheckedCreateInput = {
    id?: string
    productId: string
    branchId: string
    quantity: Decimal | DecimalJsLike | number | string
  }

  export type ProductBranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: ProductUpdateOneRequiredWithoutInventoryNestedInput
    branch?: BranchUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type ProductBranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductBranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductBranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    rfc?: string | null
    taxRegime?: string | null
    address?: string | null
    zipCode?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutCustomersInput
    sales?: SaleHeaderCreateNestedManyWithoutCustomerInput
    creditPayments?: CreditPaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    rfc?: string | null
    taxRegime?: string | null
    address?: string | null
    zipCode?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    branchId?: string | null
    createdAt?: Date | string
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutCustomerInput
    creditPayments?: CreditPaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    taxRegime?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutCustomersNestedInput
    sales?: SaleHeaderUpdateManyWithoutCustomerNestedInput
    creditPayments?: CreditPaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    taxRegime?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleHeaderUncheckedUpdateManyWithoutCustomerNestedInput
    creditPayments?: CreditPaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    taxRegime?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    taxRegime?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleHeaderCreateInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    branch: BranchCreateNestedOneWithoutSalesInput
    user?: UserCreateNestedOneWithoutSalesInput
    shift?: EmployeeShiftCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    details?: SaleDetailCreateNestedManyWithoutSaleInput
    creditPayment?: CreditPaymentCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderUncheckedCreateInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    branchId: string
    userId?: string | null
    shiftId?: string | null
    customerId?: string | null
    details?: SaleDetailUncheckedCreateNestedManyWithoutSaleInput
    creditPayment?: CreditPaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branch?: BranchUpdateOneRequiredWithoutSalesNestedInput
    user?: UserUpdateOneWithoutSalesNestedInput
    shift?: EmployeeShiftUpdateOneWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    details?: SaleDetailUpdateManyWithoutSaleNestedInput
    creditPayment?: CreditPaymentUpdateManyWithoutSaleNestedInput
  }

  export type SaleHeaderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: SaleDetailUncheckedUpdateManyWithoutSaleNestedInput
    creditPayment?: CreditPaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleHeaderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SaleHeaderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SaleDetailCreateInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    sale: SaleHeaderCreateNestedOneWithoutDetailsInput
    product: ProductCreateNestedOneWithoutSaleDetailsInput
  }

  export type SaleDetailUncheckedCreateInput = {
    id?: string
    saleId: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
  }

  export type SaleDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale?: SaleHeaderUpdateOneRequiredWithoutDetailsNestedInput
    product?: ProductUpdateOneRequiredWithoutSaleDetailsNestedInput
  }

  export type SaleDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ExpenseCreateInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    category: string
    imageUrl?: string | null
    branch: BranchCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    category: string
    imageUrl?: string | null
    branchId: string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseCreateInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    provider: ProviderCreateNestedOneWithoutPurchasesInput
    branch: BranchCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    providerId: string
    branchId: string
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: ProviderUpdateOneRequiredWithoutPurchasesNestedInput
    branch?: BranchUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
  }

  export type CreditPaymentCreateInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    customer: CustomerCreateNestedOneWithoutCreditPaymentsInput
    sale?: SaleHeaderCreateNestedOneWithoutCreditPaymentInput
  }

  export type CreditPaymentUncheckedCreateInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    customerId: string
    saleId?: string | null
  }

  export type CreditPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneRequiredWithoutCreditPaymentsNestedInput
    sale?: SaleHeaderUpdateOneWithoutCreditPaymentNestedInput
  }

  export type CreditPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
  }

  export type CreditPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeShiftCreateInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    initialCash: Decimal | DecimalJsLike | number | string
    finalCashExpected?: Decimal | DecimalJsLike | number | string | null
    finalCashActual?: Decimal | DecimalJsLike | number | string | null
    difference?: Decimal | DecimalJsLike | number | string | null
    user: UserCreateNestedOneWithoutShiftsInput
    cashCounts?: CashCountCreateNestedManyWithoutShiftInput
    sales?: SaleHeaderCreateNestedManyWithoutShiftInput
  }

  export type EmployeeShiftUncheckedCreateInput = {
    id?: string
    userId: string
    startTime?: Date | string
    endTime?: Date | string | null
    initialCash: Decimal | DecimalJsLike | number | string
    finalCashExpected?: Decimal | DecimalJsLike | number | string | null
    finalCashActual?: Decimal | DecimalJsLike | number | string | null
    difference?: Decimal | DecimalJsLike | number | string | null
    cashCounts?: CashCountUncheckedCreateNestedManyWithoutShiftInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutShiftInput
  }

  export type EmployeeShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalCashExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    difference?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: UserUpdateOneRequiredWithoutShiftsNestedInput
    cashCounts?: CashCountUpdateManyWithoutShiftNestedInput
    sales?: SaleHeaderUpdateManyWithoutShiftNestedInput
  }

  export type EmployeeShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalCashExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    difference?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cashCounts?: CashCountUncheckedUpdateManyWithoutShiftNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type EmployeeShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalCashExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    difference?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalCashExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    difference?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CashCountCreateInput = {
    id?: string
    denomination: Decimal | DecimalJsLike | number | string
    quantity: number
    type: string
    shift: EmployeeShiftCreateNestedOneWithoutCashCountsInput
  }

  export type CashCountUncheckedCreateInput = {
    id?: string
    shiftId: string
    denomination: Decimal | DecimalJsLike | number | string
    quantity: number
    type: string
  }

  export type CashCountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    denomination?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    shift?: EmployeeShiftUpdateOneRequiredWithoutCashCountsNestedInput
  }

  export type CashCountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    denomination?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type CashCountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    denomination?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type CashCountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    denomination?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type CashMovementCreateInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    reason: string
    date?: Date | string
    user: UserCreateNestedOneWithoutCashMovementsInput
    branch: BranchCreateNestedOneWithoutCashMovementsInput
  }

  export type CashMovementUncheckedCreateInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    reason: string
    date?: Date | string
    userId: string
    branchId: string
  }

  export type CashMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCashMovementsNestedInput
    branch?: BranchUpdateOneRequiredWithoutCashMovementsNestedInput
  }

  export type CashMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
  }

  export type CashMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryAdjustmentCreateInput = {
    id?: string
    date?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    reason: string
    product: ProductCreateNestedOneWithoutAdjustmentsInput
    user: UserCreateNestedOneWithoutInventoryAdjustmentsInput
  }

  export type InventoryAdjustmentUncheckedCreateInput = {
    id?: string
    date?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    reason: string
    productId: string
    userId: string
  }

  export type InventoryAdjustmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutAdjustmentsNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryAdjustmentsNestedInput
  }

  export type InventoryAdjustmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryAdjustmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryAdjustmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SystemLogCreateInput = {
    id?: string
    date?: Date | string
    action: string
    details?: string | null
    user: UserCreateNestedOneWithoutSystemLogsInput
  }

  export type SystemLogUncheckedCreateInput = {
    id?: string
    date?: Date | string
    action: string
    details?: string | null
    userId: string
  }

  export type SystemLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSystemLogsNestedInput
  }

  export type SystemLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SystemLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type StockTransferCreateInput = {
    id?: string
    date?: Date | string
    status?: string
    sourceBranch: BranchCreateNestedOneWithoutSentTransfersInput
    destBranch: BranchCreateNestedOneWithoutReceivedTransfersInput
    details?: StockTransferDetailCreateNestedManyWithoutTransferInput
  }

  export type StockTransferUncheckedCreateInput = {
    id?: string
    date?: Date | string
    status?: string
    sourceBranchId: string
    destBranchId: string
    details?: StockTransferDetailUncheckedCreateNestedManyWithoutTransferInput
  }

  export type StockTransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sourceBranch?: BranchUpdateOneRequiredWithoutSentTransfersNestedInput
    destBranch?: BranchUpdateOneRequiredWithoutReceivedTransfersNestedInput
    details?: StockTransferDetailUpdateManyWithoutTransferNestedInput
  }

  export type StockTransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sourceBranchId?: StringFieldUpdateOperationsInput | string
    destBranchId?: StringFieldUpdateOperationsInput | string
    details?: StockTransferDetailUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type StockTransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type StockTransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sourceBranchId?: StringFieldUpdateOperationsInput | string
    destBranchId?: StringFieldUpdateOperationsInput | string
  }

  export type StockTransferDetailCreateInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    transfer: StockTransferCreateNestedOneWithoutDetailsInput
    product: ProductCreateNestedOneWithoutTransferDetailsInput
  }

  export type StockTransferDetailUncheckedCreateInput = {
    id?: string
    transferId: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
  }

  export type StockTransferDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transfer?: StockTransferUpdateOneRequiredWithoutDetailsNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferDetailsNestedInput
  }

  export type StockTransferDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StockTransferDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StockTransferDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SystemSettingCreateInput = {
    id?: string
    key: string
    value: string
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
  }

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BranchNullableRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type EmployeeShiftListRelationFilter = {
    every?: EmployeeShiftWhereInput
    some?: EmployeeShiftWhereInput
    none?: EmployeeShiftWhereInput
  }

  export type SaleHeaderListRelationFilter = {
    every?: SaleHeaderWhereInput
    some?: SaleHeaderWhereInput
    none?: SaleHeaderWhereInput
  }

  export type InventoryAdjustmentListRelationFilter = {
    every?: InventoryAdjustmentWhereInput
    some?: InventoryAdjustmentWhereInput
    none?: InventoryAdjustmentWhereInput
  }

  export type SystemLogListRelationFilter = {
    every?: SystemLogWhereInput
    some?: SystemLogWhereInput
    none?: SystemLogWhereInput
  }

  export type CashMovementListRelationFilter = {
    every?: CashMovementWhereInput
    some?: CashMovementWhereInput
    none?: CashMovementWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EmployeeShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleHeaderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryAdjustmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ProviderNullableRelationFilter = {
    is?: ProviderWhereInput | null
    isNot?: ProviderWhereInput | null
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type ProductBranchListRelationFilter = {
    every?: ProductBranchWhereInput
    some?: ProductBranchWhereInput
    none?: ProductBranchWhereInput
  }

  export type SaleDetailListRelationFilter = {
    every?: SaleDetailWhereInput
    some?: SaleDetailWhereInput
    none?: SaleDetailWhereInput
  }

  export type StockTransferDetailListRelationFilter = {
    every?: StockTransferDetailWhereInput
    some?: StockTransferDetailWhereInput
    none?: StockTransferDetailWhereInput
  }

  export type ProductBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockTransferDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    cost?: SortOrder
    priceRetail?: SortOrder
    priceWholesale?: SortOrder
    unit?: SortOrder
    isActive?: SortOrder
    minStock?: SortOrder
    expiresAt?: SortOrder
    providerId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    cost?: SortOrder
    priceRetail?: SortOrder
    priceWholesale?: SortOrder
    minStock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    cost?: SortOrder
    priceRetail?: SortOrder
    priceWholesale?: SortOrder
    unit?: SortOrder
    isActive?: SortOrder
    minStock?: SortOrder
    expiresAt?: SortOrder
    providerId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    cost?: SortOrder
    priceRetail?: SortOrder
    priceWholesale?: SortOrder
    unit?: SortOrder
    isActive?: SortOrder
    minStock?: SortOrder
    expiresAt?: SortOrder
    providerId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    cost?: SortOrder
    priceRetail?: SortOrder
    priceWholesale?: SortOrder
    minStock?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    rfc?: SortOrder
    address?: SortOrder
  }

  export type ProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    rfc?: SortOrder
    address?: SortOrder
  }

  export type ProviderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    rfc?: SortOrder
    address?: SortOrder
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type StockTransferListRelationFilter = {
    every?: StockTransferWhereInput
    some?: StockTransferWhereInput
    none?: StockTransferWhereInput
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type BranchRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type ProductBranchProductIdBranchIdCompoundUniqueInput = {
    productId: string
    branchId: string
  }

  export type ProductBranchCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    branchId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductBranchAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ProductBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    branchId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductBranchMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    branchId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductBranchSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CreditPaymentListRelationFilter = {
    every?: CreditPaymentWhereInput
    some?: CreditPaymentWhereInput
    none?: CreditPaymentWhereInput
  }

  export type CreditPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    rfc?: SortOrder
    taxRegime?: SortOrder
    address?: SortOrder
    zipCode?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    creditLimit?: SortOrder
    currentBalance?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    rfc?: SortOrder
    taxRegime?: SortOrder
    address?: SortOrder
    zipCode?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    rfc?: SortOrder
    taxRegime?: SortOrder
    address?: SortOrder
    zipCode?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    creditLimit?: SortOrder
    currentBalance?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EmployeeShiftNullableRelationFilter = {
    is?: EmployeeShiftWhereInput | null
    isNot?: EmployeeShiftWhereInput | null
  }

  export type CustomerNullableRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type SaleHeaderCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrder
    customerId?: SortOrder
  }

  export type SaleHeaderAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type SaleHeaderMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrder
    customerId?: SortOrder
  }

  export type SaleHeaderMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    branchId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrder
    customerId?: SortOrder
  }

  export type SaleHeaderSumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type SaleHeaderRelationFilter = {
    is?: SaleHeaderWhereInput
    isNot?: SaleHeaderWhereInput
  }

  export type SaleDetailCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type SaleDetailAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type SaleDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type SaleDetailMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type SaleDetailSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    branchId?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    branchId?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    branchId?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ProviderRelationFilter = {
    is?: ProviderWhereInput
    isNot?: ProviderWhereInput
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    status?: SortOrder
    providerId?: SortOrder
    branchId?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    status?: SortOrder
    providerId?: SortOrder
    branchId?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    status?: SortOrder
    providerId?: SortOrder
    branchId?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type SaleHeaderNullableRelationFilter = {
    is?: SaleHeaderWhereInput | null
    isNot?: SaleHeaderWhereInput | null
  }

  export type CreditPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
  }

  export type CreditPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CreditPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
  }

  export type CreditPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
  }

  export type CreditPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CashCountListRelationFilter = {
    every?: CashCountWhereInput
    some?: CashCountWhereInput
    none?: CashCountWhereInput
  }

  export type CashCountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeShiftCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    initialCash?: SortOrder
    finalCashExpected?: SortOrder
    finalCashActual?: SortOrder
    difference?: SortOrder
  }

  export type EmployeeShiftAvgOrderByAggregateInput = {
    initialCash?: SortOrder
    finalCashExpected?: SortOrder
    finalCashActual?: SortOrder
    difference?: SortOrder
  }

  export type EmployeeShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    initialCash?: SortOrder
    finalCashExpected?: SortOrder
    finalCashActual?: SortOrder
    difference?: SortOrder
  }

  export type EmployeeShiftMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    initialCash?: SortOrder
    finalCashExpected?: SortOrder
    finalCashActual?: SortOrder
    difference?: SortOrder
  }

  export type EmployeeShiftSumOrderByAggregateInput = {
    initialCash?: SortOrder
    finalCashExpected?: SortOrder
    finalCashActual?: SortOrder
    difference?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EmployeeShiftRelationFilter = {
    is?: EmployeeShiftWhereInput
    isNot?: EmployeeShiftWhereInput
  }

  export type CashCountCountOrderByAggregateInput = {
    id?: SortOrder
    shiftId?: SortOrder
    denomination?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
  }

  export type CashCountAvgOrderByAggregateInput = {
    denomination?: SortOrder
    quantity?: SortOrder
  }

  export type CashCountMaxOrderByAggregateInput = {
    id?: SortOrder
    shiftId?: SortOrder
    denomination?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
  }

  export type CashCountMinOrderByAggregateInput = {
    id?: SortOrder
    shiftId?: SortOrder
    denomination?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
  }

  export type CashCountSumOrderByAggregateInput = {
    denomination?: SortOrder
    quantity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CashMovementCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
  }

  export type CashMovementAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CashMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
  }

  export type CashMovementMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
  }

  export type CashMovementSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InventoryAdjustmentCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
  }

  export type InventoryAdjustmentAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryAdjustmentMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
  }

  export type InventoryAdjustmentMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
  }

  export type InventoryAdjustmentSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type SystemLogCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    action?: SortOrder
    details?: SortOrder
    userId?: SortOrder
  }

  export type SystemLogMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    action?: SortOrder
    details?: SortOrder
    userId?: SortOrder
  }

  export type SystemLogMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    action?: SortOrder
    details?: SortOrder
    userId?: SortOrder
  }

  export type StockTransferCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    sourceBranchId?: SortOrder
    destBranchId?: SortOrder
  }

  export type StockTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    sourceBranchId?: SortOrder
    destBranchId?: SortOrder
  }

  export type StockTransferMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    sourceBranchId?: SortOrder
    destBranchId?: SortOrder
  }

  export type StockTransferRelationFilter = {
    is?: StockTransferWhereInput
    isNot?: StockTransferWhereInput
  }

  export type StockTransferDetailCountOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type StockTransferDetailAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockTransferDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type StockTransferDetailMinOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type StockTransferDetailSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type BranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type EmployeeShiftCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeShiftCreateWithoutUserInput, EmployeeShiftUncheckedCreateWithoutUserInput> | EmployeeShiftCreateWithoutUserInput[] | EmployeeShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutUserInput | EmployeeShiftCreateOrConnectWithoutUserInput[]
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
  }

  export type SaleHeaderCreateNestedManyWithoutUserInput = {
    create?: XOR<SaleHeaderCreateWithoutUserInput, SaleHeaderUncheckedCreateWithoutUserInput> | SaleHeaderCreateWithoutUserInput[] | SaleHeaderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutUserInput | SaleHeaderCreateOrConnectWithoutUserInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
  }

  export type InventoryAdjustmentCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryAdjustmentCreateWithoutUserInput, InventoryAdjustmentUncheckedCreateWithoutUserInput> | InventoryAdjustmentCreateWithoutUserInput[] | InventoryAdjustmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryAdjustmentCreateOrConnectWithoutUserInput | InventoryAdjustmentCreateOrConnectWithoutUserInput[]
    connect?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
  }

  export type SystemLogCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
  }

  export type CashMovementCreateNestedManyWithoutUserInput = {
    create?: XOR<CashMovementCreateWithoutUserInput, CashMovementUncheckedCreateWithoutUserInput> | CashMovementCreateWithoutUserInput[] | CashMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutUserInput | CashMovementCreateOrConnectWithoutUserInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
  }

  export type EmployeeShiftUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeShiftCreateWithoutUserInput, EmployeeShiftUncheckedCreateWithoutUserInput> | EmployeeShiftCreateWithoutUserInput[] | EmployeeShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutUserInput | EmployeeShiftCreateOrConnectWithoutUserInput[]
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
  }

  export type SaleHeaderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SaleHeaderCreateWithoutUserInput, SaleHeaderUncheckedCreateWithoutUserInput> | SaleHeaderCreateWithoutUserInput[] | SaleHeaderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutUserInput | SaleHeaderCreateOrConnectWithoutUserInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
  }

  export type InventoryAdjustmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryAdjustmentCreateWithoutUserInput, InventoryAdjustmentUncheckedCreateWithoutUserInput> | InventoryAdjustmentCreateWithoutUserInput[] | InventoryAdjustmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryAdjustmentCreateOrConnectWithoutUserInput | InventoryAdjustmentCreateOrConnectWithoutUserInput[]
    connect?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
  }

  export type SystemLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
  }

  export type CashMovementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CashMovementCreateWithoutUserInput, CashMovementUncheckedCreateWithoutUserInput> | CashMovementCreateWithoutUserInput[] | CashMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutUserInput | CashMovementCreateOrConnectWithoutUserInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    upsert?: BranchUpsertWithoutUsersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsersInput, BranchUpdateWithoutUsersInput>, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type EmployeeShiftUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeShiftCreateWithoutUserInput, EmployeeShiftUncheckedCreateWithoutUserInput> | EmployeeShiftCreateWithoutUserInput[] | EmployeeShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutUserInput | EmployeeShiftCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeShiftUpsertWithWhereUniqueWithoutUserInput | EmployeeShiftUpsertWithWhereUniqueWithoutUserInput[]
    set?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    disconnect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    delete?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    update?: EmployeeShiftUpdateWithWhereUniqueWithoutUserInput | EmployeeShiftUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeShiftUpdateManyWithWhereWithoutUserInput | EmployeeShiftUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
  }

  export type SaleHeaderUpdateManyWithoutUserNestedInput = {
    create?: XOR<SaleHeaderCreateWithoutUserInput, SaleHeaderUncheckedCreateWithoutUserInput> | SaleHeaderCreateWithoutUserInput[] | SaleHeaderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutUserInput | SaleHeaderCreateOrConnectWithoutUserInput[]
    upsert?: SaleHeaderUpsertWithWhereUniqueWithoutUserInput | SaleHeaderUpsertWithWhereUniqueWithoutUserInput[]
    set?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    disconnect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    delete?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    update?: SaleHeaderUpdateWithWhereUniqueWithoutUserInput | SaleHeaderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SaleHeaderUpdateManyWithWhereWithoutUserInput | SaleHeaderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SaleHeaderScalarWhereInput | SaleHeaderScalarWhereInput[]
  }

  export type InventoryAdjustmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryAdjustmentCreateWithoutUserInput, InventoryAdjustmentUncheckedCreateWithoutUserInput> | InventoryAdjustmentCreateWithoutUserInput[] | InventoryAdjustmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryAdjustmentCreateOrConnectWithoutUserInput | InventoryAdjustmentCreateOrConnectWithoutUserInput[]
    upsert?: InventoryAdjustmentUpsertWithWhereUniqueWithoutUserInput | InventoryAdjustmentUpsertWithWhereUniqueWithoutUserInput[]
    set?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    disconnect?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    delete?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    connect?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    update?: InventoryAdjustmentUpdateWithWhereUniqueWithoutUserInput | InventoryAdjustmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryAdjustmentUpdateManyWithWhereWithoutUserInput | InventoryAdjustmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryAdjustmentScalarWhereInput | InventoryAdjustmentScalarWhereInput[]
  }

  export type SystemLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    upsert?: SystemLogUpsertWithWhereUniqueWithoutUserInput | SystemLogUpsertWithWhereUniqueWithoutUserInput[]
    set?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    disconnect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    delete?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    update?: SystemLogUpdateWithWhereUniqueWithoutUserInput | SystemLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemLogUpdateManyWithWhereWithoutUserInput | SystemLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
  }

  export type CashMovementUpdateManyWithoutUserNestedInput = {
    create?: XOR<CashMovementCreateWithoutUserInput, CashMovementUncheckedCreateWithoutUserInput> | CashMovementCreateWithoutUserInput[] | CashMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutUserInput | CashMovementCreateOrConnectWithoutUserInput[]
    upsert?: CashMovementUpsertWithWhereUniqueWithoutUserInput | CashMovementUpsertWithWhereUniqueWithoutUserInput[]
    set?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    disconnect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    delete?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    update?: CashMovementUpdateWithWhereUniqueWithoutUserInput | CashMovementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CashMovementUpdateManyWithWhereWithoutUserInput | CashMovementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
  }

  export type EmployeeShiftUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeShiftCreateWithoutUserInput, EmployeeShiftUncheckedCreateWithoutUserInput> | EmployeeShiftCreateWithoutUserInput[] | EmployeeShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutUserInput | EmployeeShiftCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeShiftUpsertWithWhereUniqueWithoutUserInput | EmployeeShiftUpsertWithWhereUniqueWithoutUserInput[]
    set?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    disconnect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    delete?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    update?: EmployeeShiftUpdateWithWhereUniqueWithoutUserInput | EmployeeShiftUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeShiftUpdateManyWithWhereWithoutUserInput | EmployeeShiftUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
  }

  export type SaleHeaderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SaleHeaderCreateWithoutUserInput, SaleHeaderUncheckedCreateWithoutUserInput> | SaleHeaderCreateWithoutUserInput[] | SaleHeaderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutUserInput | SaleHeaderCreateOrConnectWithoutUserInput[]
    upsert?: SaleHeaderUpsertWithWhereUniqueWithoutUserInput | SaleHeaderUpsertWithWhereUniqueWithoutUserInput[]
    set?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    disconnect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    delete?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    update?: SaleHeaderUpdateWithWhereUniqueWithoutUserInput | SaleHeaderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SaleHeaderUpdateManyWithWhereWithoutUserInput | SaleHeaderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SaleHeaderScalarWhereInput | SaleHeaderScalarWhereInput[]
  }

  export type InventoryAdjustmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryAdjustmentCreateWithoutUserInput, InventoryAdjustmentUncheckedCreateWithoutUserInput> | InventoryAdjustmentCreateWithoutUserInput[] | InventoryAdjustmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryAdjustmentCreateOrConnectWithoutUserInput | InventoryAdjustmentCreateOrConnectWithoutUserInput[]
    upsert?: InventoryAdjustmentUpsertWithWhereUniqueWithoutUserInput | InventoryAdjustmentUpsertWithWhereUniqueWithoutUserInput[]
    set?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    disconnect?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    delete?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    connect?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    update?: InventoryAdjustmentUpdateWithWhereUniqueWithoutUserInput | InventoryAdjustmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryAdjustmentUpdateManyWithWhereWithoutUserInput | InventoryAdjustmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryAdjustmentScalarWhereInput | InventoryAdjustmentScalarWhereInput[]
  }

  export type SystemLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    upsert?: SystemLogUpsertWithWhereUniqueWithoutUserInput | SystemLogUpsertWithWhereUniqueWithoutUserInput[]
    set?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    disconnect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    delete?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    update?: SystemLogUpdateWithWhereUniqueWithoutUserInput | SystemLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemLogUpdateManyWithWhereWithoutUserInput | SystemLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
  }

  export type CashMovementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CashMovementCreateWithoutUserInput, CashMovementUncheckedCreateWithoutUserInput> | CashMovementCreateWithoutUserInput[] | CashMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutUserInput | CashMovementCreateOrConnectWithoutUserInput[]
    upsert?: CashMovementUpsertWithWhereUniqueWithoutUserInput | CashMovementUpsertWithWhereUniqueWithoutUserInput[]
    set?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    disconnect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    delete?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    update?: CashMovementUpdateWithWhereUniqueWithoutUserInput | CashMovementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CashMovementUpdateManyWithWhereWithoutUserInput | CashMovementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
  }

  export type ProviderCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProviderCreateWithoutProductsInput, ProviderUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutProductsInput
    connect?: ProviderWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type ProductBranchCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductBranchCreateWithoutProductInput, ProductBranchUncheckedCreateWithoutProductInput> | ProductBranchCreateWithoutProductInput[] | ProductBranchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBranchCreateOrConnectWithoutProductInput | ProductBranchCreateOrConnectWithoutProductInput[]
    connect?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
  }

  export type SaleDetailCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleDetailCreateWithoutProductInput, SaleDetailUncheckedCreateWithoutProductInput> | SaleDetailCreateWithoutProductInput[] | SaleDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleDetailCreateOrConnectWithoutProductInput | SaleDetailCreateOrConnectWithoutProductInput[]
    connect?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
  }

  export type InventoryAdjustmentCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryAdjustmentCreateWithoutProductInput, InventoryAdjustmentUncheckedCreateWithoutProductInput> | InventoryAdjustmentCreateWithoutProductInput[] | InventoryAdjustmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryAdjustmentCreateOrConnectWithoutProductInput | InventoryAdjustmentCreateOrConnectWithoutProductInput[]
    connect?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
  }

  export type StockTransferDetailCreateNestedManyWithoutProductInput = {
    create?: XOR<StockTransferDetailCreateWithoutProductInput, StockTransferDetailUncheckedCreateWithoutProductInput> | StockTransferDetailCreateWithoutProductInput[] | StockTransferDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransferDetailCreateOrConnectWithoutProductInput | StockTransferDetailCreateOrConnectWithoutProductInput[]
    connect?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
  }

  export type ProductBranchUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductBranchCreateWithoutProductInput, ProductBranchUncheckedCreateWithoutProductInput> | ProductBranchCreateWithoutProductInput[] | ProductBranchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBranchCreateOrConnectWithoutProductInput | ProductBranchCreateOrConnectWithoutProductInput[]
    connect?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
  }

  export type SaleDetailUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleDetailCreateWithoutProductInput, SaleDetailUncheckedCreateWithoutProductInput> | SaleDetailCreateWithoutProductInput[] | SaleDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleDetailCreateOrConnectWithoutProductInput | SaleDetailCreateOrConnectWithoutProductInput[]
    connect?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
  }

  export type InventoryAdjustmentUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryAdjustmentCreateWithoutProductInput, InventoryAdjustmentUncheckedCreateWithoutProductInput> | InventoryAdjustmentCreateWithoutProductInput[] | InventoryAdjustmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryAdjustmentCreateOrConnectWithoutProductInput | InventoryAdjustmentCreateOrConnectWithoutProductInput[]
    connect?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
  }

  export type StockTransferDetailUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockTransferDetailCreateWithoutProductInput, StockTransferDetailUncheckedCreateWithoutProductInput> | StockTransferDetailCreateWithoutProductInput[] | StockTransferDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransferDetailCreateOrConnectWithoutProductInput | StockTransferDetailCreateOrConnectWithoutProductInput[]
    connect?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProviderUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ProviderCreateWithoutProductsInput, ProviderUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutProductsInput
    upsert?: ProviderUpsertWithoutProductsInput
    disconnect?: ProviderWhereInput | boolean
    delete?: ProviderWhereInput | boolean
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutProductsInput, ProviderUpdateWithoutProductsInput>, ProviderUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductBranchUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductBranchCreateWithoutProductInput, ProductBranchUncheckedCreateWithoutProductInput> | ProductBranchCreateWithoutProductInput[] | ProductBranchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBranchCreateOrConnectWithoutProductInput | ProductBranchCreateOrConnectWithoutProductInput[]
    upsert?: ProductBranchUpsertWithWhereUniqueWithoutProductInput | ProductBranchUpsertWithWhereUniqueWithoutProductInput[]
    set?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    disconnect?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    delete?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    connect?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    update?: ProductBranchUpdateWithWhereUniqueWithoutProductInput | ProductBranchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductBranchUpdateManyWithWhereWithoutProductInput | ProductBranchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductBranchScalarWhereInput | ProductBranchScalarWhereInput[]
  }

  export type SaleDetailUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleDetailCreateWithoutProductInput, SaleDetailUncheckedCreateWithoutProductInput> | SaleDetailCreateWithoutProductInput[] | SaleDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleDetailCreateOrConnectWithoutProductInput | SaleDetailCreateOrConnectWithoutProductInput[]
    upsert?: SaleDetailUpsertWithWhereUniqueWithoutProductInput | SaleDetailUpsertWithWhereUniqueWithoutProductInput[]
    set?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    disconnect?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    delete?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    connect?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    update?: SaleDetailUpdateWithWhereUniqueWithoutProductInput | SaleDetailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleDetailUpdateManyWithWhereWithoutProductInput | SaleDetailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleDetailScalarWhereInput | SaleDetailScalarWhereInput[]
  }

  export type InventoryAdjustmentUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryAdjustmentCreateWithoutProductInput, InventoryAdjustmentUncheckedCreateWithoutProductInput> | InventoryAdjustmentCreateWithoutProductInput[] | InventoryAdjustmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryAdjustmentCreateOrConnectWithoutProductInput | InventoryAdjustmentCreateOrConnectWithoutProductInput[]
    upsert?: InventoryAdjustmentUpsertWithWhereUniqueWithoutProductInput | InventoryAdjustmentUpsertWithWhereUniqueWithoutProductInput[]
    set?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    disconnect?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    delete?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    connect?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    update?: InventoryAdjustmentUpdateWithWhereUniqueWithoutProductInput | InventoryAdjustmentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryAdjustmentUpdateManyWithWhereWithoutProductInput | InventoryAdjustmentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryAdjustmentScalarWhereInput | InventoryAdjustmentScalarWhereInput[]
  }

  export type StockTransferDetailUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockTransferDetailCreateWithoutProductInput, StockTransferDetailUncheckedCreateWithoutProductInput> | StockTransferDetailCreateWithoutProductInput[] | StockTransferDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransferDetailCreateOrConnectWithoutProductInput | StockTransferDetailCreateOrConnectWithoutProductInput[]
    upsert?: StockTransferDetailUpsertWithWhereUniqueWithoutProductInput | StockTransferDetailUpsertWithWhereUniqueWithoutProductInput[]
    set?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    disconnect?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    delete?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    connect?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    update?: StockTransferDetailUpdateWithWhereUniqueWithoutProductInput | StockTransferDetailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockTransferDetailUpdateManyWithWhereWithoutProductInput | StockTransferDetailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockTransferDetailScalarWhereInput | StockTransferDetailScalarWhereInput[]
  }

  export type ProductBranchUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductBranchCreateWithoutProductInput, ProductBranchUncheckedCreateWithoutProductInput> | ProductBranchCreateWithoutProductInput[] | ProductBranchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBranchCreateOrConnectWithoutProductInput | ProductBranchCreateOrConnectWithoutProductInput[]
    upsert?: ProductBranchUpsertWithWhereUniqueWithoutProductInput | ProductBranchUpsertWithWhereUniqueWithoutProductInput[]
    set?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    disconnect?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    delete?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    connect?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    update?: ProductBranchUpdateWithWhereUniqueWithoutProductInput | ProductBranchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductBranchUpdateManyWithWhereWithoutProductInput | ProductBranchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductBranchScalarWhereInput | ProductBranchScalarWhereInput[]
  }

  export type SaleDetailUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleDetailCreateWithoutProductInput, SaleDetailUncheckedCreateWithoutProductInput> | SaleDetailCreateWithoutProductInput[] | SaleDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleDetailCreateOrConnectWithoutProductInput | SaleDetailCreateOrConnectWithoutProductInput[]
    upsert?: SaleDetailUpsertWithWhereUniqueWithoutProductInput | SaleDetailUpsertWithWhereUniqueWithoutProductInput[]
    set?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    disconnect?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    delete?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    connect?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    update?: SaleDetailUpdateWithWhereUniqueWithoutProductInput | SaleDetailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleDetailUpdateManyWithWhereWithoutProductInput | SaleDetailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleDetailScalarWhereInput | SaleDetailScalarWhereInput[]
  }

  export type InventoryAdjustmentUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryAdjustmentCreateWithoutProductInput, InventoryAdjustmentUncheckedCreateWithoutProductInput> | InventoryAdjustmentCreateWithoutProductInput[] | InventoryAdjustmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryAdjustmentCreateOrConnectWithoutProductInput | InventoryAdjustmentCreateOrConnectWithoutProductInput[]
    upsert?: InventoryAdjustmentUpsertWithWhereUniqueWithoutProductInput | InventoryAdjustmentUpsertWithWhereUniqueWithoutProductInput[]
    set?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    disconnect?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    delete?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    connect?: InventoryAdjustmentWhereUniqueInput | InventoryAdjustmentWhereUniqueInput[]
    update?: InventoryAdjustmentUpdateWithWhereUniqueWithoutProductInput | InventoryAdjustmentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryAdjustmentUpdateManyWithWhereWithoutProductInput | InventoryAdjustmentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryAdjustmentScalarWhereInput | InventoryAdjustmentScalarWhereInput[]
  }

  export type StockTransferDetailUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockTransferDetailCreateWithoutProductInput, StockTransferDetailUncheckedCreateWithoutProductInput> | StockTransferDetailCreateWithoutProductInput[] | StockTransferDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransferDetailCreateOrConnectWithoutProductInput | StockTransferDetailCreateOrConnectWithoutProductInput[]
    upsert?: StockTransferDetailUpsertWithWhereUniqueWithoutProductInput | StockTransferDetailUpsertWithWhereUniqueWithoutProductInput[]
    set?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    disconnect?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    delete?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    connect?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    update?: StockTransferDetailUpdateWithWhereUniqueWithoutProductInput | StockTransferDetailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockTransferDetailUpdateManyWithWhereWithoutProductInput | StockTransferDetailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockTransferDetailScalarWhereInput | StockTransferDetailScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutProviderInput = {
    create?: XOR<ProductCreateWithoutProviderInput, ProductUncheckedCreateWithoutProviderInput> | ProductCreateWithoutProviderInput[] | ProductUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProviderInput | ProductCreateOrConnectWithoutProviderInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutProviderInput = {
    create?: XOR<PurchaseCreateWithoutProviderInput, PurchaseUncheckedCreateWithoutProviderInput> | PurchaseCreateWithoutProviderInput[] | PurchaseUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProviderInput | PurchaseCreateOrConnectWithoutProviderInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ProductCreateWithoutProviderInput, ProductUncheckedCreateWithoutProviderInput> | ProductCreateWithoutProviderInput[] | ProductUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProviderInput | ProductCreateOrConnectWithoutProviderInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<PurchaseCreateWithoutProviderInput, PurchaseUncheckedCreateWithoutProviderInput> | PurchaseCreateWithoutProviderInput[] | PurchaseUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProviderInput | PurchaseCreateOrConnectWithoutProviderInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ProductCreateWithoutProviderInput, ProductUncheckedCreateWithoutProviderInput> | ProductCreateWithoutProviderInput[] | ProductUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProviderInput | ProductCreateOrConnectWithoutProviderInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProviderInput | ProductUpsertWithWhereUniqueWithoutProviderInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProviderInput | ProductUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProviderInput | ProductUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutProviderNestedInput = {
    create?: XOR<PurchaseCreateWithoutProviderInput, PurchaseUncheckedCreateWithoutProviderInput> | PurchaseCreateWithoutProviderInput[] | PurchaseUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProviderInput | PurchaseCreateOrConnectWithoutProviderInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutProviderInput | PurchaseUpsertWithWhereUniqueWithoutProviderInput[]
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutProviderInput | PurchaseUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutProviderInput | PurchaseUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ProductCreateWithoutProviderInput, ProductUncheckedCreateWithoutProviderInput> | ProductCreateWithoutProviderInput[] | ProductUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProviderInput | ProductCreateOrConnectWithoutProviderInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProviderInput | ProductUpsertWithWhereUniqueWithoutProviderInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProviderInput | ProductUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProviderInput | ProductUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<PurchaseCreateWithoutProviderInput, PurchaseUncheckedCreateWithoutProviderInput> | PurchaseCreateWithoutProviderInput[] | PurchaseUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProviderInput | PurchaseCreateOrConnectWithoutProviderInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutProviderInput | PurchaseUpsertWithWhereUniqueWithoutProviderInput[]
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutProviderInput | PurchaseUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutProviderInput | PurchaseUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type ProductBranchCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProductBranchCreateWithoutBranchInput, ProductBranchUncheckedCreateWithoutBranchInput> | ProductBranchCreateWithoutBranchInput[] | ProductBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductBranchCreateOrConnectWithoutBranchInput | ProductBranchCreateOrConnectWithoutBranchInput[]
    connect?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
  }

  export type SaleHeaderCreateNestedManyWithoutBranchInput = {
    create?: XOR<SaleHeaderCreateWithoutBranchInput, SaleHeaderUncheckedCreateWithoutBranchInput> | SaleHeaderCreateWithoutBranchInput[] | SaleHeaderUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutBranchInput | SaleHeaderCreateOrConnectWithoutBranchInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutBranchInput = {
    create?: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput> | ExpenseCreateWithoutBranchInput[] | ExpenseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBranchInput | ExpenseCreateOrConnectWithoutBranchInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutBranchInput = {
    create?: XOR<PurchaseCreateWithoutBranchInput, PurchaseUncheckedCreateWithoutBranchInput> | PurchaseCreateWithoutBranchInput[] | PurchaseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutBranchInput | PurchaseCreateOrConnectWithoutBranchInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type CashMovementCreateNestedManyWithoutBranchInput = {
    create?: XOR<CashMovementCreateWithoutBranchInput, CashMovementUncheckedCreateWithoutBranchInput> | CashMovementCreateWithoutBranchInput[] | CashMovementUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutBranchInput | CashMovementCreateOrConnectWithoutBranchInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutBranchInput = {
    create?: XOR<CustomerCreateWithoutBranchInput, CustomerUncheckedCreateWithoutBranchInput> | CustomerCreateWithoutBranchInput[] | CustomerUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutBranchInput | CustomerCreateOrConnectWithoutBranchInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StockTransferCreateNestedManyWithoutSourceBranchInput = {
    create?: XOR<StockTransferCreateWithoutSourceBranchInput, StockTransferUncheckedCreateWithoutSourceBranchInput> | StockTransferCreateWithoutSourceBranchInput[] | StockTransferUncheckedCreateWithoutSourceBranchInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutSourceBranchInput | StockTransferCreateOrConnectWithoutSourceBranchInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
  }

  export type StockTransferCreateNestedManyWithoutDestBranchInput = {
    create?: XOR<StockTransferCreateWithoutDestBranchInput, StockTransferUncheckedCreateWithoutDestBranchInput> | StockTransferCreateWithoutDestBranchInput[] | StockTransferUncheckedCreateWithoutDestBranchInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutDestBranchInput | StockTransferCreateOrConnectWithoutDestBranchInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
  }

  export type ProductBranchUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProductBranchCreateWithoutBranchInput, ProductBranchUncheckedCreateWithoutBranchInput> | ProductBranchCreateWithoutBranchInput[] | ProductBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductBranchCreateOrConnectWithoutBranchInput | ProductBranchCreateOrConnectWithoutBranchInput[]
    connect?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
  }

  export type SaleHeaderUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<SaleHeaderCreateWithoutBranchInput, SaleHeaderUncheckedCreateWithoutBranchInput> | SaleHeaderCreateWithoutBranchInput[] | SaleHeaderUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutBranchInput | SaleHeaderCreateOrConnectWithoutBranchInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput> | ExpenseCreateWithoutBranchInput[] | ExpenseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBranchInput | ExpenseCreateOrConnectWithoutBranchInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<PurchaseCreateWithoutBranchInput, PurchaseUncheckedCreateWithoutBranchInput> | PurchaseCreateWithoutBranchInput[] | PurchaseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutBranchInput | PurchaseCreateOrConnectWithoutBranchInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type CashMovementUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<CashMovementCreateWithoutBranchInput, CashMovementUncheckedCreateWithoutBranchInput> | CashMovementCreateWithoutBranchInput[] | CashMovementUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutBranchInput | CashMovementCreateOrConnectWithoutBranchInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<CustomerCreateWithoutBranchInput, CustomerUncheckedCreateWithoutBranchInput> | CustomerCreateWithoutBranchInput[] | CustomerUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutBranchInput | CustomerCreateOrConnectWithoutBranchInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StockTransferUncheckedCreateNestedManyWithoutSourceBranchInput = {
    create?: XOR<StockTransferCreateWithoutSourceBranchInput, StockTransferUncheckedCreateWithoutSourceBranchInput> | StockTransferCreateWithoutSourceBranchInput[] | StockTransferUncheckedCreateWithoutSourceBranchInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutSourceBranchInput | StockTransferCreateOrConnectWithoutSourceBranchInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
  }

  export type StockTransferUncheckedCreateNestedManyWithoutDestBranchInput = {
    create?: XOR<StockTransferCreateWithoutDestBranchInput, StockTransferUncheckedCreateWithoutDestBranchInput> | StockTransferCreateWithoutDestBranchInput[] | StockTransferUncheckedCreateWithoutDestBranchInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutDestBranchInput | StockTransferCreateOrConnectWithoutDestBranchInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
  }

  export type ProductBranchUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProductBranchCreateWithoutBranchInput, ProductBranchUncheckedCreateWithoutBranchInput> | ProductBranchCreateWithoutBranchInput[] | ProductBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductBranchCreateOrConnectWithoutBranchInput | ProductBranchCreateOrConnectWithoutBranchInput[]
    upsert?: ProductBranchUpsertWithWhereUniqueWithoutBranchInput | ProductBranchUpsertWithWhereUniqueWithoutBranchInput[]
    set?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    disconnect?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    delete?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    connect?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    update?: ProductBranchUpdateWithWhereUniqueWithoutBranchInput | ProductBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProductBranchUpdateManyWithWhereWithoutBranchInput | ProductBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProductBranchScalarWhereInput | ProductBranchScalarWhereInput[]
  }

  export type SaleHeaderUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SaleHeaderCreateWithoutBranchInput, SaleHeaderUncheckedCreateWithoutBranchInput> | SaleHeaderCreateWithoutBranchInput[] | SaleHeaderUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutBranchInput | SaleHeaderCreateOrConnectWithoutBranchInput[]
    upsert?: SaleHeaderUpsertWithWhereUniqueWithoutBranchInput | SaleHeaderUpsertWithWhereUniqueWithoutBranchInput[]
    set?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    disconnect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    delete?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    update?: SaleHeaderUpdateWithWhereUniqueWithoutBranchInput | SaleHeaderUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SaleHeaderUpdateManyWithWhereWithoutBranchInput | SaleHeaderUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SaleHeaderScalarWhereInput | SaleHeaderScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput> | ExpenseCreateWithoutBranchInput[] | ExpenseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBranchInput | ExpenseCreateOrConnectWithoutBranchInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutBranchInput | ExpenseUpsertWithWhereUniqueWithoutBranchInput[]
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutBranchInput | ExpenseUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutBranchInput | ExpenseUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PurchaseCreateWithoutBranchInput, PurchaseUncheckedCreateWithoutBranchInput> | PurchaseCreateWithoutBranchInput[] | PurchaseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutBranchInput | PurchaseCreateOrConnectWithoutBranchInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutBranchInput | PurchaseUpsertWithWhereUniqueWithoutBranchInput[]
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutBranchInput | PurchaseUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutBranchInput | PurchaseUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type CashMovementUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CashMovementCreateWithoutBranchInput, CashMovementUncheckedCreateWithoutBranchInput> | CashMovementCreateWithoutBranchInput[] | CashMovementUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutBranchInput | CashMovementCreateOrConnectWithoutBranchInput[]
    upsert?: CashMovementUpsertWithWhereUniqueWithoutBranchInput | CashMovementUpsertWithWhereUniqueWithoutBranchInput[]
    set?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    disconnect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    delete?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    update?: CashMovementUpdateWithWhereUniqueWithoutBranchInput | CashMovementUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CashMovementUpdateManyWithWhereWithoutBranchInput | CashMovementUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CustomerCreateWithoutBranchInput, CustomerUncheckedCreateWithoutBranchInput> | CustomerCreateWithoutBranchInput[] | CustomerUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutBranchInput | CustomerCreateOrConnectWithoutBranchInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutBranchInput | CustomerUpsertWithWhereUniqueWithoutBranchInput[]
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutBranchInput | CustomerUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutBranchInput | CustomerUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type StockTransferUpdateManyWithoutSourceBranchNestedInput = {
    create?: XOR<StockTransferCreateWithoutSourceBranchInput, StockTransferUncheckedCreateWithoutSourceBranchInput> | StockTransferCreateWithoutSourceBranchInput[] | StockTransferUncheckedCreateWithoutSourceBranchInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutSourceBranchInput | StockTransferCreateOrConnectWithoutSourceBranchInput[]
    upsert?: StockTransferUpsertWithWhereUniqueWithoutSourceBranchInput | StockTransferUpsertWithWhereUniqueWithoutSourceBranchInput[]
    set?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    disconnect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    delete?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    update?: StockTransferUpdateWithWhereUniqueWithoutSourceBranchInput | StockTransferUpdateWithWhereUniqueWithoutSourceBranchInput[]
    updateMany?: StockTransferUpdateManyWithWhereWithoutSourceBranchInput | StockTransferUpdateManyWithWhereWithoutSourceBranchInput[]
    deleteMany?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
  }

  export type StockTransferUpdateManyWithoutDestBranchNestedInput = {
    create?: XOR<StockTransferCreateWithoutDestBranchInput, StockTransferUncheckedCreateWithoutDestBranchInput> | StockTransferCreateWithoutDestBranchInput[] | StockTransferUncheckedCreateWithoutDestBranchInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutDestBranchInput | StockTransferCreateOrConnectWithoutDestBranchInput[]
    upsert?: StockTransferUpsertWithWhereUniqueWithoutDestBranchInput | StockTransferUpsertWithWhereUniqueWithoutDestBranchInput[]
    set?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    disconnect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    delete?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    update?: StockTransferUpdateWithWhereUniqueWithoutDestBranchInput | StockTransferUpdateWithWhereUniqueWithoutDestBranchInput[]
    updateMany?: StockTransferUpdateManyWithWhereWithoutDestBranchInput | StockTransferUpdateManyWithWhereWithoutDestBranchInput[]
    deleteMany?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
  }

  export type ProductBranchUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProductBranchCreateWithoutBranchInput, ProductBranchUncheckedCreateWithoutBranchInput> | ProductBranchCreateWithoutBranchInput[] | ProductBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductBranchCreateOrConnectWithoutBranchInput | ProductBranchCreateOrConnectWithoutBranchInput[]
    upsert?: ProductBranchUpsertWithWhereUniqueWithoutBranchInput | ProductBranchUpsertWithWhereUniqueWithoutBranchInput[]
    set?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    disconnect?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    delete?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    connect?: ProductBranchWhereUniqueInput | ProductBranchWhereUniqueInput[]
    update?: ProductBranchUpdateWithWhereUniqueWithoutBranchInput | ProductBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProductBranchUpdateManyWithWhereWithoutBranchInput | ProductBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProductBranchScalarWhereInput | ProductBranchScalarWhereInput[]
  }

  export type SaleHeaderUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SaleHeaderCreateWithoutBranchInput, SaleHeaderUncheckedCreateWithoutBranchInput> | SaleHeaderCreateWithoutBranchInput[] | SaleHeaderUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutBranchInput | SaleHeaderCreateOrConnectWithoutBranchInput[]
    upsert?: SaleHeaderUpsertWithWhereUniqueWithoutBranchInput | SaleHeaderUpsertWithWhereUniqueWithoutBranchInput[]
    set?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    disconnect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    delete?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    update?: SaleHeaderUpdateWithWhereUniqueWithoutBranchInput | SaleHeaderUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SaleHeaderUpdateManyWithWhereWithoutBranchInput | SaleHeaderUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SaleHeaderScalarWhereInput | SaleHeaderScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput> | ExpenseCreateWithoutBranchInput[] | ExpenseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBranchInput | ExpenseCreateOrConnectWithoutBranchInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutBranchInput | ExpenseUpsertWithWhereUniqueWithoutBranchInput[]
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutBranchInput | ExpenseUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutBranchInput | ExpenseUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PurchaseCreateWithoutBranchInput, PurchaseUncheckedCreateWithoutBranchInput> | PurchaseCreateWithoutBranchInput[] | PurchaseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutBranchInput | PurchaseCreateOrConnectWithoutBranchInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutBranchInput | PurchaseUpsertWithWhereUniqueWithoutBranchInput[]
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutBranchInput | PurchaseUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutBranchInput | PurchaseUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type CashMovementUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CashMovementCreateWithoutBranchInput, CashMovementUncheckedCreateWithoutBranchInput> | CashMovementCreateWithoutBranchInput[] | CashMovementUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutBranchInput | CashMovementCreateOrConnectWithoutBranchInput[]
    upsert?: CashMovementUpsertWithWhereUniqueWithoutBranchInput | CashMovementUpsertWithWhereUniqueWithoutBranchInput[]
    set?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    disconnect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    delete?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    update?: CashMovementUpdateWithWhereUniqueWithoutBranchInput | CashMovementUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CashMovementUpdateManyWithWhereWithoutBranchInput | CashMovementUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<CustomerCreateWithoutBranchInput, CustomerUncheckedCreateWithoutBranchInput> | CustomerCreateWithoutBranchInput[] | CustomerUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutBranchInput | CustomerCreateOrConnectWithoutBranchInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutBranchInput | CustomerUpsertWithWhereUniqueWithoutBranchInput[]
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutBranchInput | CustomerUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutBranchInput | CustomerUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type StockTransferUncheckedUpdateManyWithoutSourceBranchNestedInput = {
    create?: XOR<StockTransferCreateWithoutSourceBranchInput, StockTransferUncheckedCreateWithoutSourceBranchInput> | StockTransferCreateWithoutSourceBranchInput[] | StockTransferUncheckedCreateWithoutSourceBranchInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutSourceBranchInput | StockTransferCreateOrConnectWithoutSourceBranchInput[]
    upsert?: StockTransferUpsertWithWhereUniqueWithoutSourceBranchInput | StockTransferUpsertWithWhereUniqueWithoutSourceBranchInput[]
    set?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    disconnect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    delete?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    update?: StockTransferUpdateWithWhereUniqueWithoutSourceBranchInput | StockTransferUpdateWithWhereUniqueWithoutSourceBranchInput[]
    updateMany?: StockTransferUpdateManyWithWhereWithoutSourceBranchInput | StockTransferUpdateManyWithWhereWithoutSourceBranchInput[]
    deleteMany?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
  }

  export type StockTransferUncheckedUpdateManyWithoutDestBranchNestedInput = {
    create?: XOR<StockTransferCreateWithoutDestBranchInput, StockTransferUncheckedCreateWithoutDestBranchInput> | StockTransferCreateWithoutDestBranchInput[] | StockTransferUncheckedCreateWithoutDestBranchInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutDestBranchInput | StockTransferCreateOrConnectWithoutDestBranchInput[]
    upsert?: StockTransferUpsertWithWhereUniqueWithoutDestBranchInput | StockTransferUpsertWithWhereUniqueWithoutDestBranchInput[]
    set?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    disconnect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    delete?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    update?: StockTransferUpdateWithWhereUniqueWithoutDestBranchInput | StockTransferUpdateWithWhereUniqueWithoutDestBranchInput[]
    updateMany?: StockTransferUpdateManyWithWhereWithoutDestBranchInput | StockTransferUpdateManyWithWhereWithoutDestBranchInput[]
    deleteMany?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryInput
    connect?: ProductWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutInventoryInput = {
    create?: XOR<BranchCreateWithoutInventoryInput, BranchUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInventoryInput
    connect?: BranchWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProductUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryInput
    upsert?: ProductUpsertWithoutInventoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryInput, ProductUpdateWithoutInventoryInput>, ProductUncheckedUpdateWithoutInventoryInput>
  }

  export type BranchUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<BranchCreateWithoutInventoryInput, BranchUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInventoryInput
    upsert?: BranchUpsertWithoutInventoryInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutInventoryInput, BranchUpdateWithoutInventoryInput>, BranchUncheckedUpdateWithoutInventoryInput>
  }

  export type BranchCreateNestedOneWithoutCustomersInput = {
    create?: XOR<BranchCreateWithoutCustomersInput, BranchUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutCustomersInput
    connect?: BranchWhereUniqueInput
  }

  export type SaleHeaderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleHeaderCreateWithoutCustomerInput, SaleHeaderUncheckedCreateWithoutCustomerInput> | SaleHeaderCreateWithoutCustomerInput[] | SaleHeaderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutCustomerInput | SaleHeaderCreateOrConnectWithoutCustomerInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
  }

  export type CreditPaymentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CreditPaymentCreateWithoutCustomerInput, CreditPaymentUncheckedCreateWithoutCustomerInput> | CreditPaymentCreateWithoutCustomerInput[] | CreditPaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CreditPaymentCreateOrConnectWithoutCustomerInput | CreditPaymentCreateOrConnectWithoutCustomerInput[]
    connect?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
  }

  export type SaleHeaderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleHeaderCreateWithoutCustomerInput, SaleHeaderUncheckedCreateWithoutCustomerInput> | SaleHeaderCreateWithoutCustomerInput[] | SaleHeaderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutCustomerInput | SaleHeaderCreateOrConnectWithoutCustomerInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
  }

  export type CreditPaymentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CreditPaymentCreateWithoutCustomerInput, CreditPaymentUncheckedCreateWithoutCustomerInput> | CreditPaymentCreateWithoutCustomerInput[] | CreditPaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CreditPaymentCreateOrConnectWithoutCustomerInput | CreditPaymentCreateOrConnectWithoutCustomerInput[]
    connect?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
  }

  export type BranchUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<BranchCreateWithoutCustomersInput, BranchUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutCustomersInput
    upsert?: BranchUpsertWithoutCustomersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutCustomersInput, BranchUpdateWithoutCustomersInput>, BranchUncheckedUpdateWithoutCustomersInput>
  }

  export type SaleHeaderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleHeaderCreateWithoutCustomerInput, SaleHeaderUncheckedCreateWithoutCustomerInput> | SaleHeaderCreateWithoutCustomerInput[] | SaleHeaderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutCustomerInput | SaleHeaderCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleHeaderUpsertWithWhereUniqueWithoutCustomerInput | SaleHeaderUpsertWithWhereUniqueWithoutCustomerInput[]
    set?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    disconnect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    delete?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    update?: SaleHeaderUpdateWithWhereUniqueWithoutCustomerInput | SaleHeaderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleHeaderUpdateManyWithWhereWithoutCustomerInput | SaleHeaderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleHeaderScalarWhereInput | SaleHeaderScalarWhereInput[]
  }

  export type CreditPaymentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CreditPaymentCreateWithoutCustomerInput, CreditPaymentUncheckedCreateWithoutCustomerInput> | CreditPaymentCreateWithoutCustomerInput[] | CreditPaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CreditPaymentCreateOrConnectWithoutCustomerInput | CreditPaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: CreditPaymentUpsertWithWhereUniqueWithoutCustomerInput | CreditPaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    set?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    disconnect?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    delete?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    connect?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    update?: CreditPaymentUpdateWithWhereUniqueWithoutCustomerInput | CreditPaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CreditPaymentUpdateManyWithWhereWithoutCustomerInput | CreditPaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CreditPaymentScalarWhereInput | CreditPaymentScalarWhereInput[]
  }

  export type SaleHeaderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleHeaderCreateWithoutCustomerInput, SaleHeaderUncheckedCreateWithoutCustomerInput> | SaleHeaderCreateWithoutCustomerInput[] | SaleHeaderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutCustomerInput | SaleHeaderCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleHeaderUpsertWithWhereUniqueWithoutCustomerInput | SaleHeaderUpsertWithWhereUniqueWithoutCustomerInput[]
    set?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    disconnect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    delete?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    update?: SaleHeaderUpdateWithWhereUniqueWithoutCustomerInput | SaleHeaderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleHeaderUpdateManyWithWhereWithoutCustomerInput | SaleHeaderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleHeaderScalarWhereInput | SaleHeaderScalarWhereInput[]
  }

  export type CreditPaymentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CreditPaymentCreateWithoutCustomerInput, CreditPaymentUncheckedCreateWithoutCustomerInput> | CreditPaymentCreateWithoutCustomerInput[] | CreditPaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CreditPaymentCreateOrConnectWithoutCustomerInput | CreditPaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: CreditPaymentUpsertWithWhereUniqueWithoutCustomerInput | CreditPaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    set?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    disconnect?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    delete?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    connect?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    update?: CreditPaymentUpdateWithWhereUniqueWithoutCustomerInput | CreditPaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CreditPaymentUpdateManyWithWhereWithoutCustomerInput | CreditPaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CreditPaymentScalarWhereInput | CreditPaymentScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutSalesInput = {
    create?: XOR<BranchCreateWithoutSalesInput, BranchUncheckedCreateWithoutSalesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSalesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSalesInput = {
    create?: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeShiftCreateNestedOneWithoutSalesInput = {
    create?: XOR<EmployeeShiftCreateWithoutSalesInput, EmployeeShiftUncheckedCreateWithoutSalesInput>
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutSalesInput
    connect?: EmployeeShiftWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSalesInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    connect?: CustomerWhereUniqueInput
  }

  export type SaleDetailCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleDetailCreateWithoutSaleInput, SaleDetailUncheckedCreateWithoutSaleInput> | SaleDetailCreateWithoutSaleInput[] | SaleDetailUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleDetailCreateOrConnectWithoutSaleInput | SaleDetailCreateOrConnectWithoutSaleInput[]
    connect?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
  }

  export type CreditPaymentCreateNestedManyWithoutSaleInput = {
    create?: XOR<CreditPaymentCreateWithoutSaleInput, CreditPaymentUncheckedCreateWithoutSaleInput> | CreditPaymentCreateWithoutSaleInput[] | CreditPaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: CreditPaymentCreateOrConnectWithoutSaleInput | CreditPaymentCreateOrConnectWithoutSaleInput[]
    connect?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
  }

  export type SaleDetailUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleDetailCreateWithoutSaleInput, SaleDetailUncheckedCreateWithoutSaleInput> | SaleDetailCreateWithoutSaleInput[] | SaleDetailUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleDetailCreateOrConnectWithoutSaleInput | SaleDetailCreateOrConnectWithoutSaleInput[]
    connect?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
  }

  export type CreditPaymentUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<CreditPaymentCreateWithoutSaleInput, CreditPaymentUncheckedCreateWithoutSaleInput> | CreditPaymentCreateWithoutSaleInput[] | CreditPaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: CreditPaymentCreateOrConnectWithoutSaleInput | CreditPaymentCreateOrConnectWithoutSaleInput[]
    connect?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<BranchCreateWithoutSalesInput, BranchUncheckedCreateWithoutSalesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSalesInput
    upsert?: BranchUpsertWithoutSalesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSalesInput, BranchUpdateWithoutSalesInput>, BranchUncheckedUpdateWithoutSalesInput>
  }

  export type UserUpdateOneWithoutSalesNestedInput = {
    create?: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesInput
    upsert?: UserUpsertWithoutSalesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalesInput, UserUpdateWithoutSalesInput>, UserUncheckedUpdateWithoutSalesInput>
  }

  export type EmployeeShiftUpdateOneWithoutSalesNestedInput = {
    create?: XOR<EmployeeShiftCreateWithoutSalesInput, EmployeeShiftUncheckedCreateWithoutSalesInput>
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutSalesInput
    upsert?: EmployeeShiftUpsertWithoutSalesInput
    disconnect?: EmployeeShiftWhereInput | boolean
    delete?: EmployeeShiftWhereInput | boolean
    connect?: EmployeeShiftWhereUniqueInput
    update?: XOR<XOR<EmployeeShiftUpdateToOneWithWhereWithoutSalesInput, EmployeeShiftUpdateWithoutSalesInput>, EmployeeShiftUncheckedUpdateWithoutSalesInput>
  }

  export type CustomerUpdateOneWithoutSalesNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    upsert?: CustomerUpsertWithoutSalesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesInput, CustomerUpdateWithoutSalesInput>, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type SaleDetailUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleDetailCreateWithoutSaleInput, SaleDetailUncheckedCreateWithoutSaleInput> | SaleDetailCreateWithoutSaleInput[] | SaleDetailUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleDetailCreateOrConnectWithoutSaleInput | SaleDetailCreateOrConnectWithoutSaleInput[]
    upsert?: SaleDetailUpsertWithWhereUniqueWithoutSaleInput | SaleDetailUpsertWithWhereUniqueWithoutSaleInput[]
    set?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    disconnect?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    delete?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    connect?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    update?: SaleDetailUpdateWithWhereUniqueWithoutSaleInput | SaleDetailUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleDetailUpdateManyWithWhereWithoutSaleInput | SaleDetailUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleDetailScalarWhereInput | SaleDetailScalarWhereInput[]
  }

  export type CreditPaymentUpdateManyWithoutSaleNestedInput = {
    create?: XOR<CreditPaymentCreateWithoutSaleInput, CreditPaymentUncheckedCreateWithoutSaleInput> | CreditPaymentCreateWithoutSaleInput[] | CreditPaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: CreditPaymentCreateOrConnectWithoutSaleInput | CreditPaymentCreateOrConnectWithoutSaleInput[]
    upsert?: CreditPaymentUpsertWithWhereUniqueWithoutSaleInput | CreditPaymentUpsertWithWhereUniqueWithoutSaleInput[]
    set?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    disconnect?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    delete?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    connect?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    update?: CreditPaymentUpdateWithWhereUniqueWithoutSaleInput | CreditPaymentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: CreditPaymentUpdateManyWithWhereWithoutSaleInput | CreditPaymentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: CreditPaymentScalarWhereInput | CreditPaymentScalarWhereInput[]
  }

  export type SaleDetailUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleDetailCreateWithoutSaleInput, SaleDetailUncheckedCreateWithoutSaleInput> | SaleDetailCreateWithoutSaleInput[] | SaleDetailUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleDetailCreateOrConnectWithoutSaleInput | SaleDetailCreateOrConnectWithoutSaleInput[]
    upsert?: SaleDetailUpsertWithWhereUniqueWithoutSaleInput | SaleDetailUpsertWithWhereUniqueWithoutSaleInput[]
    set?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    disconnect?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    delete?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    connect?: SaleDetailWhereUniqueInput | SaleDetailWhereUniqueInput[]
    update?: SaleDetailUpdateWithWhereUniqueWithoutSaleInput | SaleDetailUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleDetailUpdateManyWithWhereWithoutSaleInput | SaleDetailUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleDetailScalarWhereInput | SaleDetailScalarWhereInput[]
  }

  export type CreditPaymentUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<CreditPaymentCreateWithoutSaleInput, CreditPaymentUncheckedCreateWithoutSaleInput> | CreditPaymentCreateWithoutSaleInput[] | CreditPaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: CreditPaymentCreateOrConnectWithoutSaleInput | CreditPaymentCreateOrConnectWithoutSaleInput[]
    upsert?: CreditPaymentUpsertWithWhereUniqueWithoutSaleInput | CreditPaymentUpsertWithWhereUniqueWithoutSaleInput[]
    set?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    disconnect?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    delete?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    connect?: CreditPaymentWhereUniqueInput | CreditPaymentWhereUniqueInput[]
    update?: CreditPaymentUpdateWithWhereUniqueWithoutSaleInput | CreditPaymentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: CreditPaymentUpdateManyWithWhereWithoutSaleInput | CreditPaymentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: CreditPaymentScalarWhereInput | CreditPaymentScalarWhereInput[]
  }

  export type SaleHeaderCreateNestedOneWithoutDetailsInput = {
    create?: XOR<SaleHeaderCreateWithoutDetailsInput, SaleHeaderUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutDetailsInput
    connect?: SaleHeaderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSaleDetailsInput = {
    create?: XOR<ProductCreateWithoutSaleDetailsInput, ProductUncheckedCreateWithoutSaleDetailsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSaleDetailsInput
    connect?: ProductWhereUniqueInput
  }

  export type SaleHeaderUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<SaleHeaderCreateWithoutDetailsInput, SaleHeaderUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutDetailsInput
    upsert?: SaleHeaderUpsertWithoutDetailsInput
    connect?: SaleHeaderWhereUniqueInput
    update?: XOR<XOR<SaleHeaderUpdateToOneWithWhereWithoutDetailsInput, SaleHeaderUpdateWithoutDetailsInput>, SaleHeaderUncheckedUpdateWithoutDetailsInput>
  }

  export type ProductUpdateOneRequiredWithoutSaleDetailsNestedInput = {
    create?: XOR<ProductCreateWithoutSaleDetailsInput, ProductUncheckedCreateWithoutSaleDetailsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSaleDetailsInput
    upsert?: ProductUpsertWithoutSaleDetailsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSaleDetailsInput, ProductUpdateWithoutSaleDetailsInput>, ProductUncheckedUpdateWithoutSaleDetailsInput>
  }

  export type BranchCreateNestedOneWithoutExpensesInput = {
    create?: XOR<BranchCreateWithoutExpensesInput, BranchUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutExpensesInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<BranchCreateWithoutExpensesInput, BranchUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutExpensesInput
    upsert?: BranchUpsertWithoutExpensesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutExpensesInput, BranchUpdateWithoutExpensesInput>, BranchUncheckedUpdateWithoutExpensesInput>
  }

  export type ProviderCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<ProviderCreateWithoutPurchasesInput, ProviderUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutPurchasesInput
    connect?: ProviderWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<BranchCreateWithoutPurchasesInput, BranchUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPurchasesInput
    connect?: BranchWhereUniqueInput
  }

  export type ProviderUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<ProviderCreateWithoutPurchasesInput, ProviderUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutPurchasesInput
    upsert?: ProviderUpsertWithoutPurchasesInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutPurchasesInput, ProviderUpdateWithoutPurchasesInput>, ProviderUncheckedUpdateWithoutPurchasesInput>
  }

  export type BranchUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<BranchCreateWithoutPurchasesInput, BranchUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPurchasesInput
    upsert?: BranchUpsertWithoutPurchasesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutPurchasesInput, BranchUpdateWithoutPurchasesInput>, BranchUncheckedUpdateWithoutPurchasesInput>
  }

  export type CustomerCreateNestedOneWithoutCreditPaymentsInput = {
    create?: XOR<CustomerCreateWithoutCreditPaymentsInput, CustomerUncheckedCreateWithoutCreditPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCreditPaymentsInput
    connect?: CustomerWhereUniqueInput
  }

  export type SaleHeaderCreateNestedOneWithoutCreditPaymentInput = {
    create?: XOR<SaleHeaderCreateWithoutCreditPaymentInput, SaleHeaderUncheckedCreateWithoutCreditPaymentInput>
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutCreditPaymentInput
    connect?: SaleHeaderWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCreditPaymentsNestedInput = {
    create?: XOR<CustomerCreateWithoutCreditPaymentsInput, CustomerUncheckedCreateWithoutCreditPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCreditPaymentsInput
    upsert?: CustomerUpsertWithoutCreditPaymentsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCreditPaymentsInput, CustomerUpdateWithoutCreditPaymentsInput>, CustomerUncheckedUpdateWithoutCreditPaymentsInput>
  }

  export type SaleHeaderUpdateOneWithoutCreditPaymentNestedInput = {
    create?: XOR<SaleHeaderCreateWithoutCreditPaymentInput, SaleHeaderUncheckedCreateWithoutCreditPaymentInput>
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutCreditPaymentInput
    upsert?: SaleHeaderUpsertWithoutCreditPaymentInput
    disconnect?: SaleHeaderWhereInput | boolean
    delete?: SaleHeaderWhereInput | boolean
    connect?: SaleHeaderWhereUniqueInput
    update?: XOR<XOR<SaleHeaderUpdateToOneWithWhereWithoutCreditPaymentInput, SaleHeaderUpdateWithoutCreditPaymentInput>, SaleHeaderUncheckedUpdateWithoutCreditPaymentInput>
  }

  export type UserCreateNestedOneWithoutShiftsInput = {
    create?: XOR<UserCreateWithoutShiftsInput, UserUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftsInput
    connect?: UserWhereUniqueInput
  }

  export type CashCountCreateNestedManyWithoutShiftInput = {
    create?: XOR<CashCountCreateWithoutShiftInput, CashCountUncheckedCreateWithoutShiftInput> | CashCountCreateWithoutShiftInput[] | CashCountUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: CashCountCreateOrConnectWithoutShiftInput | CashCountCreateOrConnectWithoutShiftInput[]
    connect?: CashCountWhereUniqueInput | CashCountWhereUniqueInput[]
  }

  export type SaleHeaderCreateNestedManyWithoutShiftInput = {
    create?: XOR<SaleHeaderCreateWithoutShiftInput, SaleHeaderUncheckedCreateWithoutShiftInput> | SaleHeaderCreateWithoutShiftInput[] | SaleHeaderUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutShiftInput | SaleHeaderCreateOrConnectWithoutShiftInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
  }

  export type CashCountUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<CashCountCreateWithoutShiftInput, CashCountUncheckedCreateWithoutShiftInput> | CashCountCreateWithoutShiftInput[] | CashCountUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: CashCountCreateOrConnectWithoutShiftInput | CashCountCreateOrConnectWithoutShiftInput[]
    connect?: CashCountWhereUniqueInput | CashCountWhereUniqueInput[]
  }

  export type SaleHeaderUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<SaleHeaderCreateWithoutShiftInput, SaleHeaderUncheckedCreateWithoutShiftInput> | SaleHeaderCreateWithoutShiftInput[] | SaleHeaderUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutShiftInput | SaleHeaderCreateOrConnectWithoutShiftInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<UserCreateWithoutShiftsInput, UserUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftsInput
    upsert?: UserUpsertWithoutShiftsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShiftsInput, UserUpdateWithoutShiftsInput>, UserUncheckedUpdateWithoutShiftsInput>
  }

  export type CashCountUpdateManyWithoutShiftNestedInput = {
    create?: XOR<CashCountCreateWithoutShiftInput, CashCountUncheckedCreateWithoutShiftInput> | CashCountCreateWithoutShiftInput[] | CashCountUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: CashCountCreateOrConnectWithoutShiftInput | CashCountCreateOrConnectWithoutShiftInput[]
    upsert?: CashCountUpsertWithWhereUniqueWithoutShiftInput | CashCountUpsertWithWhereUniqueWithoutShiftInput[]
    set?: CashCountWhereUniqueInput | CashCountWhereUniqueInput[]
    disconnect?: CashCountWhereUniqueInput | CashCountWhereUniqueInput[]
    delete?: CashCountWhereUniqueInput | CashCountWhereUniqueInput[]
    connect?: CashCountWhereUniqueInput | CashCountWhereUniqueInput[]
    update?: CashCountUpdateWithWhereUniqueWithoutShiftInput | CashCountUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: CashCountUpdateManyWithWhereWithoutShiftInput | CashCountUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: CashCountScalarWhereInput | CashCountScalarWhereInput[]
  }

  export type SaleHeaderUpdateManyWithoutShiftNestedInput = {
    create?: XOR<SaleHeaderCreateWithoutShiftInput, SaleHeaderUncheckedCreateWithoutShiftInput> | SaleHeaderCreateWithoutShiftInput[] | SaleHeaderUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutShiftInput | SaleHeaderCreateOrConnectWithoutShiftInput[]
    upsert?: SaleHeaderUpsertWithWhereUniqueWithoutShiftInput | SaleHeaderUpsertWithWhereUniqueWithoutShiftInput[]
    set?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    disconnect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    delete?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    update?: SaleHeaderUpdateWithWhereUniqueWithoutShiftInput | SaleHeaderUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: SaleHeaderUpdateManyWithWhereWithoutShiftInput | SaleHeaderUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: SaleHeaderScalarWhereInput | SaleHeaderScalarWhereInput[]
  }

  export type CashCountUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<CashCountCreateWithoutShiftInput, CashCountUncheckedCreateWithoutShiftInput> | CashCountCreateWithoutShiftInput[] | CashCountUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: CashCountCreateOrConnectWithoutShiftInput | CashCountCreateOrConnectWithoutShiftInput[]
    upsert?: CashCountUpsertWithWhereUniqueWithoutShiftInput | CashCountUpsertWithWhereUniqueWithoutShiftInput[]
    set?: CashCountWhereUniqueInput | CashCountWhereUniqueInput[]
    disconnect?: CashCountWhereUniqueInput | CashCountWhereUniqueInput[]
    delete?: CashCountWhereUniqueInput | CashCountWhereUniqueInput[]
    connect?: CashCountWhereUniqueInput | CashCountWhereUniqueInput[]
    update?: CashCountUpdateWithWhereUniqueWithoutShiftInput | CashCountUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: CashCountUpdateManyWithWhereWithoutShiftInput | CashCountUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: CashCountScalarWhereInput | CashCountScalarWhereInput[]
  }

  export type SaleHeaderUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<SaleHeaderCreateWithoutShiftInput, SaleHeaderUncheckedCreateWithoutShiftInput> | SaleHeaderCreateWithoutShiftInput[] | SaleHeaderUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: SaleHeaderCreateOrConnectWithoutShiftInput | SaleHeaderCreateOrConnectWithoutShiftInput[]
    upsert?: SaleHeaderUpsertWithWhereUniqueWithoutShiftInput | SaleHeaderUpsertWithWhereUniqueWithoutShiftInput[]
    set?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    disconnect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    delete?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    connect?: SaleHeaderWhereUniqueInput | SaleHeaderWhereUniqueInput[]
    update?: SaleHeaderUpdateWithWhereUniqueWithoutShiftInput | SaleHeaderUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: SaleHeaderUpdateManyWithWhereWithoutShiftInput | SaleHeaderUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: SaleHeaderScalarWhereInput | SaleHeaderScalarWhereInput[]
  }

  export type EmployeeShiftCreateNestedOneWithoutCashCountsInput = {
    create?: XOR<EmployeeShiftCreateWithoutCashCountsInput, EmployeeShiftUncheckedCreateWithoutCashCountsInput>
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutCashCountsInput
    connect?: EmployeeShiftWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeShiftUpdateOneRequiredWithoutCashCountsNestedInput = {
    create?: XOR<EmployeeShiftCreateWithoutCashCountsInput, EmployeeShiftUncheckedCreateWithoutCashCountsInput>
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutCashCountsInput
    upsert?: EmployeeShiftUpsertWithoutCashCountsInput
    connect?: EmployeeShiftWhereUniqueInput
    update?: XOR<XOR<EmployeeShiftUpdateToOneWithWhereWithoutCashCountsInput, EmployeeShiftUpdateWithoutCashCountsInput>, EmployeeShiftUncheckedUpdateWithoutCashCountsInput>
  }

  export type UserCreateNestedOneWithoutCashMovementsInput = {
    create?: XOR<UserCreateWithoutCashMovementsInput, UserUncheckedCreateWithoutCashMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashMovementsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutCashMovementsInput = {
    create?: XOR<BranchCreateWithoutCashMovementsInput, BranchUncheckedCreateWithoutCashMovementsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutCashMovementsInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCashMovementsNestedInput = {
    create?: XOR<UserCreateWithoutCashMovementsInput, UserUncheckedCreateWithoutCashMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashMovementsInput
    upsert?: UserUpsertWithoutCashMovementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCashMovementsInput, UserUpdateWithoutCashMovementsInput>, UserUncheckedUpdateWithoutCashMovementsInput>
  }

  export type BranchUpdateOneRequiredWithoutCashMovementsNestedInput = {
    create?: XOR<BranchCreateWithoutCashMovementsInput, BranchUncheckedCreateWithoutCashMovementsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutCashMovementsInput
    upsert?: BranchUpsertWithoutCashMovementsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutCashMovementsInput, BranchUpdateWithoutCashMovementsInput>, BranchUncheckedUpdateWithoutCashMovementsInput>
  }

  export type ProductCreateNestedOneWithoutAdjustmentsInput = {
    create?: XOR<ProductCreateWithoutAdjustmentsInput, ProductUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdjustmentsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryAdjustmentsInput = {
    create?: XOR<UserCreateWithoutInventoryAdjustmentsInput, UserUncheckedCreateWithoutInventoryAdjustmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryAdjustmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutAdjustmentsNestedInput = {
    create?: XOR<ProductCreateWithoutAdjustmentsInput, ProductUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdjustmentsInput
    upsert?: ProductUpsertWithoutAdjustmentsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAdjustmentsInput, ProductUpdateWithoutAdjustmentsInput>, ProductUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type UserUpdateOneRequiredWithoutInventoryAdjustmentsNestedInput = {
    create?: XOR<UserCreateWithoutInventoryAdjustmentsInput, UserUncheckedCreateWithoutInventoryAdjustmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryAdjustmentsInput
    upsert?: UserUpsertWithoutInventoryAdjustmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryAdjustmentsInput, UserUpdateWithoutInventoryAdjustmentsInput>, UserUncheckedUpdateWithoutInventoryAdjustmentsInput>
  }

  export type UserCreateNestedOneWithoutSystemLogsInput = {
    create?: XOR<UserCreateWithoutSystemLogsInput, UserUncheckedCreateWithoutSystemLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSystemLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSystemLogsNestedInput = {
    create?: XOR<UserCreateWithoutSystemLogsInput, UserUncheckedCreateWithoutSystemLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSystemLogsInput
    upsert?: UserUpsertWithoutSystemLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSystemLogsInput, UserUpdateWithoutSystemLogsInput>, UserUncheckedUpdateWithoutSystemLogsInput>
  }

  export type BranchCreateNestedOneWithoutSentTransfersInput = {
    create?: XOR<BranchCreateWithoutSentTransfersInput, BranchUncheckedCreateWithoutSentTransfersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSentTransfersInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutReceivedTransfersInput = {
    create?: XOR<BranchCreateWithoutReceivedTransfersInput, BranchUncheckedCreateWithoutReceivedTransfersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutReceivedTransfersInput
    connect?: BranchWhereUniqueInput
  }

  export type StockTransferDetailCreateNestedManyWithoutTransferInput = {
    create?: XOR<StockTransferDetailCreateWithoutTransferInput, StockTransferDetailUncheckedCreateWithoutTransferInput> | StockTransferDetailCreateWithoutTransferInput[] | StockTransferDetailUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: StockTransferDetailCreateOrConnectWithoutTransferInput | StockTransferDetailCreateOrConnectWithoutTransferInput[]
    connect?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
  }

  export type StockTransferDetailUncheckedCreateNestedManyWithoutTransferInput = {
    create?: XOR<StockTransferDetailCreateWithoutTransferInput, StockTransferDetailUncheckedCreateWithoutTransferInput> | StockTransferDetailCreateWithoutTransferInput[] | StockTransferDetailUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: StockTransferDetailCreateOrConnectWithoutTransferInput | StockTransferDetailCreateOrConnectWithoutTransferInput[]
    connect?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutSentTransfersNestedInput = {
    create?: XOR<BranchCreateWithoutSentTransfersInput, BranchUncheckedCreateWithoutSentTransfersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSentTransfersInput
    upsert?: BranchUpsertWithoutSentTransfersInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSentTransfersInput, BranchUpdateWithoutSentTransfersInput>, BranchUncheckedUpdateWithoutSentTransfersInput>
  }

  export type BranchUpdateOneRequiredWithoutReceivedTransfersNestedInput = {
    create?: XOR<BranchCreateWithoutReceivedTransfersInput, BranchUncheckedCreateWithoutReceivedTransfersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutReceivedTransfersInput
    upsert?: BranchUpsertWithoutReceivedTransfersInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutReceivedTransfersInput, BranchUpdateWithoutReceivedTransfersInput>, BranchUncheckedUpdateWithoutReceivedTransfersInput>
  }

  export type StockTransferDetailUpdateManyWithoutTransferNestedInput = {
    create?: XOR<StockTransferDetailCreateWithoutTransferInput, StockTransferDetailUncheckedCreateWithoutTransferInput> | StockTransferDetailCreateWithoutTransferInput[] | StockTransferDetailUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: StockTransferDetailCreateOrConnectWithoutTransferInput | StockTransferDetailCreateOrConnectWithoutTransferInput[]
    upsert?: StockTransferDetailUpsertWithWhereUniqueWithoutTransferInput | StockTransferDetailUpsertWithWhereUniqueWithoutTransferInput[]
    set?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    disconnect?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    delete?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    connect?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    update?: StockTransferDetailUpdateWithWhereUniqueWithoutTransferInput | StockTransferDetailUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: StockTransferDetailUpdateManyWithWhereWithoutTransferInput | StockTransferDetailUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: StockTransferDetailScalarWhereInput | StockTransferDetailScalarWhereInput[]
  }

  export type StockTransferDetailUncheckedUpdateManyWithoutTransferNestedInput = {
    create?: XOR<StockTransferDetailCreateWithoutTransferInput, StockTransferDetailUncheckedCreateWithoutTransferInput> | StockTransferDetailCreateWithoutTransferInput[] | StockTransferDetailUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: StockTransferDetailCreateOrConnectWithoutTransferInput | StockTransferDetailCreateOrConnectWithoutTransferInput[]
    upsert?: StockTransferDetailUpsertWithWhereUniqueWithoutTransferInput | StockTransferDetailUpsertWithWhereUniqueWithoutTransferInput[]
    set?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    disconnect?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    delete?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    connect?: StockTransferDetailWhereUniqueInput | StockTransferDetailWhereUniqueInput[]
    update?: StockTransferDetailUpdateWithWhereUniqueWithoutTransferInput | StockTransferDetailUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: StockTransferDetailUpdateManyWithWhereWithoutTransferInput | StockTransferDetailUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: StockTransferDetailScalarWhereInput | StockTransferDetailScalarWhereInput[]
  }

  export type StockTransferCreateNestedOneWithoutDetailsInput = {
    create?: XOR<StockTransferCreateWithoutDetailsInput, StockTransferUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: StockTransferCreateOrConnectWithoutDetailsInput
    connect?: StockTransferWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutTransferDetailsInput = {
    create?: XOR<ProductCreateWithoutTransferDetailsInput, ProductUncheckedCreateWithoutTransferDetailsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransferDetailsInput
    connect?: ProductWhereUniqueInput
  }

  export type StockTransferUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<StockTransferCreateWithoutDetailsInput, StockTransferUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: StockTransferCreateOrConnectWithoutDetailsInput
    upsert?: StockTransferUpsertWithoutDetailsInput
    connect?: StockTransferWhereUniqueInput
    update?: XOR<XOR<StockTransferUpdateToOneWithWhereWithoutDetailsInput, StockTransferUpdateWithoutDetailsInput>, StockTransferUncheckedUpdateWithoutDetailsInput>
  }

  export type ProductUpdateOneRequiredWithoutTransferDetailsNestedInput = {
    create?: XOR<ProductCreateWithoutTransferDetailsInput, ProductUncheckedCreateWithoutTransferDetailsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransferDetailsInput
    upsert?: ProductUpsertWithoutTransferDetailsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTransferDetailsInput, ProductUpdateWithoutTransferDetailsInput>, ProductUncheckedUpdateWithoutTransferDetailsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BranchCreateWithoutUsersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    purchases?: PurchaseCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementCreateNestedManyWithoutBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferCreateNestedManyWithoutDestBranchInput
  }

  export type BranchUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferUncheckedCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferUncheckedCreateNestedManyWithoutDestBranchInput
  }

  export type BranchCreateOrConnectWithoutUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
  }

  export type EmployeeShiftCreateWithoutUserInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    initialCash: Decimal | DecimalJsLike | number | string
    finalCashExpected?: Decimal | DecimalJsLike | number | string | null
    finalCashActual?: Decimal | DecimalJsLike | number | string | null
    difference?: Decimal | DecimalJsLike | number | string | null
    cashCounts?: CashCountCreateNestedManyWithoutShiftInput
    sales?: SaleHeaderCreateNestedManyWithoutShiftInput
  }

  export type EmployeeShiftUncheckedCreateWithoutUserInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    initialCash: Decimal | DecimalJsLike | number | string
    finalCashExpected?: Decimal | DecimalJsLike | number | string | null
    finalCashActual?: Decimal | DecimalJsLike | number | string | null
    difference?: Decimal | DecimalJsLike | number | string | null
    cashCounts?: CashCountUncheckedCreateNestedManyWithoutShiftInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutShiftInput
  }

  export type EmployeeShiftCreateOrConnectWithoutUserInput = {
    where: EmployeeShiftWhereUniqueInput
    create: XOR<EmployeeShiftCreateWithoutUserInput, EmployeeShiftUncheckedCreateWithoutUserInput>
  }

  export type SaleHeaderCreateWithoutUserInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    branch: BranchCreateNestedOneWithoutSalesInput
    shift?: EmployeeShiftCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    details?: SaleDetailCreateNestedManyWithoutSaleInput
    creditPayment?: CreditPaymentCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderUncheckedCreateWithoutUserInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    branchId: string
    shiftId?: string | null
    customerId?: string | null
    details?: SaleDetailUncheckedCreateNestedManyWithoutSaleInput
    creditPayment?: CreditPaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderCreateOrConnectWithoutUserInput = {
    where: SaleHeaderWhereUniqueInput
    create: XOR<SaleHeaderCreateWithoutUserInput, SaleHeaderUncheckedCreateWithoutUserInput>
  }

  export type InventoryAdjustmentCreateWithoutUserInput = {
    id?: string
    date?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    reason: string
    product: ProductCreateNestedOneWithoutAdjustmentsInput
  }

  export type InventoryAdjustmentUncheckedCreateWithoutUserInput = {
    id?: string
    date?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    reason: string
    productId: string
  }

  export type InventoryAdjustmentCreateOrConnectWithoutUserInput = {
    where: InventoryAdjustmentWhereUniqueInput
    create: XOR<InventoryAdjustmentCreateWithoutUserInput, InventoryAdjustmentUncheckedCreateWithoutUserInput>
  }

  export type SystemLogCreateWithoutUserInput = {
    id?: string
    date?: Date | string
    action: string
    details?: string | null
  }

  export type SystemLogUncheckedCreateWithoutUserInput = {
    id?: string
    date?: Date | string
    action: string
    details?: string | null
  }

  export type SystemLogCreateOrConnectWithoutUserInput = {
    where: SystemLogWhereUniqueInput
    create: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput>
  }

  export type CashMovementCreateWithoutUserInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    reason: string
    date?: Date | string
    branch: BranchCreateNestedOneWithoutCashMovementsInput
  }

  export type CashMovementUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    reason: string
    date?: Date | string
    branchId: string
  }

  export type CashMovementCreateOrConnectWithoutUserInput = {
    where: CashMovementWhereUniqueInput
    create: XOR<CashMovementCreateWithoutUserInput, CashMovementUncheckedCreateWithoutUserInput>
  }

  export type BranchUpsertWithoutUsersInput = {
    update: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUpdateManyWithoutBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUpdateManyWithoutDestBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUncheckedUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUncheckedUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUncheckedUpdateManyWithoutDestBranchNestedInput
  }

  export type EmployeeShiftUpsertWithWhereUniqueWithoutUserInput = {
    where: EmployeeShiftWhereUniqueInput
    update: XOR<EmployeeShiftUpdateWithoutUserInput, EmployeeShiftUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeShiftCreateWithoutUserInput, EmployeeShiftUncheckedCreateWithoutUserInput>
  }

  export type EmployeeShiftUpdateWithWhereUniqueWithoutUserInput = {
    where: EmployeeShiftWhereUniqueInput
    data: XOR<EmployeeShiftUpdateWithoutUserInput, EmployeeShiftUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeShiftUpdateManyWithWhereWithoutUserInput = {
    where: EmployeeShiftScalarWhereInput
    data: XOR<EmployeeShiftUpdateManyMutationInput, EmployeeShiftUncheckedUpdateManyWithoutUserInput>
  }

  export type EmployeeShiftScalarWhereInput = {
    AND?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
    OR?: EmployeeShiftScalarWhereInput[]
    NOT?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
    id?: StringFilter<"EmployeeShift"> | string
    userId?: StringFilter<"EmployeeShift"> | string
    startTime?: DateTimeFilter<"EmployeeShift"> | Date | string
    endTime?: DateTimeNullableFilter<"EmployeeShift"> | Date | string | null
    initialCash?: DecimalFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string
    finalCashExpected?: DecimalNullableFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: DecimalNullableFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string | null
    difference?: DecimalNullableFilter<"EmployeeShift"> | Decimal | DecimalJsLike | number | string | null
  }

  export type SaleHeaderUpsertWithWhereUniqueWithoutUserInput = {
    where: SaleHeaderWhereUniqueInput
    update: XOR<SaleHeaderUpdateWithoutUserInput, SaleHeaderUncheckedUpdateWithoutUserInput>
    create: XOR<SaleHeaderCreateWithoutUserInput, SaleHeaderUncheckedCreateWithoutUserInput>
  }

  export type SaleHeaderUpdateWithWhereUniqueWithoutUserInput = {
    where: SaleHeaderWhereUniqueInput
    data: XOR<SaleHeaderUpdateWithoutUserInput, SaleHeaderUncheckedUpdateWithoutUserInput>
  }

  export type SaleHeaderUpdateManyWithWhereWithoutUserInput = {
    where: SaleHeaderScalarWhereInput
    data: XOR<SaleHeaderUpdateManyMutationInput, SaleHeaderUncheckedUpdateManyWithoutUserInput>
  }

  export type SaleHeaderScalarWhereInput = {
    AND?: SaleHeaderScalarWhereInput | SaleHeaderScalarWhereInput[]
    OR?: SaleHeaderScalarWhereInput[]
    NOT?: SaleHeaderScalarWhereInput | SaleHeaderScalarWhereInput[]
    id?: StringFilter<"SaleHeader"> | string
    date?: DateTimeFilter<"SaleHeader"> | Date | string
    total?: DecimalFilter<"SaleHeader"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"SaleHeader"> | string
    status?: StringFilter<"SaleHeader"> | string
    branchId?: StringFilter<"SaleHeader"> | string
    userId?: StringNullableFilter<"SaleHeader"> | string | null
    shiftId?: StringNullableFilter<"SaleHeader"> | string | null
    customerId?: StringNullableFilter<"SaleHeader"> | string | null
  }

  export type InventoryAdjustmentUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryAdjustmentWhereUniqueInput
    update: XOR<InventoryAdjustmentUpdateWithoutUserInput, InventoryAdjustmentUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryAdjustmentCreateWithoutUserInput, InventoryAdjustmentUncheckedCreateWithoutUserInput>
  }

  export type InventoryAdjustmentUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryAdjustmentWhereUniqueInput
    data: XOR<InventoryAdjustmentUpdateWithoutUserInput, InventoryAdjustmentUncheckedUpdateWithoutUserInput>
  }

  export type InventoryAdjustmentUpdateManyWithWhereWithoutUserInput = {
    where: InventoryAdjustmentScalarWhereInput
    data: XOR<InventoryAdjustmentUpdateManyMutationInput, InventoryAdjustmentUncheckedUpdateManyWithoutUserInput>
  }

  export type InventoryAdjustmentScalarWhereInput = {
    AND?: InventoryAdjustmentScalarWhereInput | InventoryAdjustmentScalarWhereInput[]
    OR?: InventoryAdjustmentScalarWhereInput[]
    NOT?: InventoryAdjustmentScalarWhereInput | InventoryAdjustmentScalarWhereInput[]
    id?: StringFilter<"InventoryAdjustment"> | string
    date?: DateTimeFilter<"InventoryAdjustment"> | Date | string
    quantity?: DecimalFilter<"InventoryAdjustment"> | Decimal | DecimalJsLike | number | string
    reason?: StringFilter<"InventoryAdjustment"> | string
    productId?: StringFilter<"InventoryAdjustment"> | string
    userId?: StringFilter<"InventoryAdjustment"> | string
  }

  export type SystemLogUpsertWithWhereUniqueWithoutUserInput = {
    where: SystemLogWhereUniqueInput
    update: XOR<SystemLogUpdateWithoutUserInput, SystemLogUncheckedUpdateWithoutUserInput>
    create: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput>
  }

  export type SystemLogUpdateWithWhereUniqueWithoutUserInput = {
    where: SystemLogWhereUniqueInput
    data: XOR<SystemLogUpdateWithoutUserInput, SystemLogUncheckedUpdateWithoutUserInput>
  }

  export type SystemLogUpdateManyWithWhereWithoutUserInput = {
    where: SystemLogScalarWhereInput
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyWithoutUserInput>
  }

  export type SystemLogScalarWhereInput = {
    AND?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
    OR?: SystemLogScalarWhereInput[]
    NOT?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
    id?: StringFilter<"SystemLog"> | string
    date?: DateTimeFilter<"SystemLog"> | Date | string
    action?: StringFilter<"SystemLog"> | string
    details?: StringNullableFilter<"SystemLog"> | string | null
    userId?: StringFilter<"SystemLog"> | string
  }

  export type CashMovementUpsertWithWhereUniqueWithoutUserInput = {
    where: CashMovementWhereUniqueInput
    update: XOR<CashMovementUpdateWithoutUserInput, CashMovementUncheckedUpdateWithoutUserInput>
    create: XOR<CashMovementCreateWithoutUserInput, CashMovementUncheckedCreateWithoutUserInput>
  }

  export type CashMovementUpdateWithWhereUniqueWithoutUserInput = {
    where: CashMovementWhereUniqueInput
    data: XOR<CashMovementUpdateWithoutUserInput, CashMovementUncheckedUpdateWithoutUserInput>
  }

  export type CashMovementUpdateManyWithWhereWithoutUserInput = {
    where: CashMovementScalarWhereInput
    data: XOR<CashMovementUpdateManyMutationInput, CashMovementUncheckedUpdateManyWithoutUserInput>
  }

  export type CashMovementScalarWhereInput = {
    AND?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
    OR?: CashMovementScalarWhereInput[]
    NOT?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
    id?: StringFilter<"CashMovement"> | string
    type?: StringFilter<"CashMovement"> | string
    amount?: DecimalFilter<"CashMovement"> | Decimal | DecimalJsLike | number | string
    reason?: StringFilter<"CashMovement"> | string
    date?: DateTimeFilter<"CashMovement"> | Date | string
    userId?: StringFilter<"CashMovement"> | string
    branchId?: StringFilter<"CashMovement"> | string
  }

  export type ProviderCreateWithoutProductsInput = {
    id?: string
    name: string
    contact?: string | null
    phone?: string | null
    email?: string | null
    rfc?: string | null
    address?: string | null
    purchases?: PurchaseCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    contact?: string | null
    phone?: string | null
    email?: string | null
    rfc?: string | null
    address?: string | null
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutProductsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutProductsInput, ProviderUncheckedCreateWithoutProductsInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductBranchCreateWithoutProductInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    branch: BranchCreateNestedOneWithoutInventoryInput
  }

  export type ProductBranchUncheckedCreateWithoutProductInput = {
    id?: string
    branchId: string
    quantity: Decimal | DecimalJsLike | number | string
  }

  export type ProductBranchCreateOrConnectWithoutProductInput = {
    where: ProductBranchWhereUniqueInput
    create: XOR<ProductBranchCreateWithoutProductInput, ProductBranchUncheckedCreateWithoutProductInput>
  }

  export type SaleDetailCreateWithoutProductInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    sale: SaleHeaderCreateNestedOneWithoutDetailsInput
  }

  export type SaleDetailUncheckedCreateWithoutProductInput = {
    id?: string
    saleId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
  }

  export type SaleDetailCreateOrConnectWithoutProductInput = {
    where: SaleDetailWhereUniqueInput
    create: XOR<SaleDetailCreateWithoutProductInput, SaleDetailUncheckedCreateWithoutProductInput>
  }

  export type InventoryAdjustmentCreateWithoutProductInput = {
    id?: string
    date?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    reason: string
    user: UserCreateNestedOneWithoutInventoryAdjustmentsInput
  }

  export type InventoryAdjustmentUncheckedCreateWithoutProductInput = {
    id?: string
    date?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    reason: string
    userId: string
  }

  export type InventoryAdjustmentCreateOrConnectWithoutProductInput = {
    where: InventoryAdjustmentWhereUniqueInput
    create: XOR<InventoryAdjustmentCreateWithoutProductInput, InventoryAdjustmentUncheckedCreateWithoutProductInput>
  }

  export type StockTransferDetailCreateWithoutProductInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    transfer: StockTransferCreateNestedOneWithoutDetailsInput
  }

  export type StockTransferDetailUncheckedCreateWithoutProductInput = {
    id?: string
    transferId: string
    quantity: Decimal | DecimalJsLike | number | string
  }

  export type StockTransferDetailCreateOrConnectWithoutProductInput = {
    where: StockTransferDetailWhereUniqueInput
    create: XOR<StockTransferDetailCreateWithoutProductInput, StockTransferDetailUncheckedCreateWithoutProductInput>
  }

  export type ProviderUpsertWithoutProductsInput = {
    update: XOR<ProviderUpdateWithoutProductsInput, ProviderUncheckedUpdateWithoutProductsInput>
    create: XOR<ProviderCreateWithoutProductsInput, ProviderUncheckedCreateWithoutProductsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutProductsInput, ProviderUncheckedUpdateWithoutProductsInput>
  }

  export type ProviderUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    purchases?: PurchaseUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    purchases?: PurchaseUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductBranchUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductBranchWhereUniqueInput
    update: XOR<ProductBranchUpdateWithoutProductInput, ProductBranchUncheckedUpdateWithoutProductInput>
    create: XOR<ProductBranchCreateWithoutProductInput, ProductBranchUncheckedCreateWithoutProductInput>
  }

  export type ProductBranchUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductBranchWhereUniqueInput
    data: XOR<ProductBranchUpdateWithoutProductInput, ProductBranchUncheckedUpdateWithoutProductInput>
  }

  export type ProductBranchUpdateManyWithWhereWithoutProductInput = {
    where: ProductBranchScalarWhereInput
    data: XOR<ProductBranchUpdateManyMutationInput, ProductBranchUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductBranchScalarWhereInput = {
    AND?: ProductBranchScalarWhereInput | ProductBranchScalarWhereInput[]
    OR?: ProductBranchScalarWhereInput[]
    NOT?: ProductBranchScalarWhereInput | ProductBranchScalarWhereInput[]
    id?: StringFilter<"ProductBranch"> | string
    productId?: StringFilter<"ProductBranch"> | string
    branchId?: StringFilter<"ProductBranch"> | string
    quantity?: DecimalFilter<"ProductBranch"> | Decimal | DecimalJsLike | number | string
  }

  export type SaleDetailUpsertWithWhereUniqueWithoutProductInput = {
    where: SaleDetailWhereUniqueInput
    update: XOR<SaleDetailUpdateWithoutProductInput, SaleDetailUncheckedUpdateWithoutProductInput>
    create: XOR<SaleDetailCreateWithoutProductInput, SaleDetailUncheckedCreateWithoutProductInput>
  }

  export type SaleDetailUpdateWithWhereUniqueWithoutProductInput = {
    where: SaleDetailWhereUniqueInput
    data: XOR<SaleDetailUpdateWithoutProductInput, SaleDetailUncheckedUpdateWithoutProductInput>
  }

  export type SaleDetailUpdateManyWithWhereWithoutProductInput = {
    where: SaleDetailScalarWhereInput
    data: XOR<SaleDetailUpdateManyMutationInput, SaleDetailUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleDetailScalarWhereInput = {
    AND?: SaleDetailScalarWhereInput | SaleDetailScalarWhereInput[]
    OR?: SaleDetailScalarWhereInput[]
    NOT?: SaleDetailScalarWhereInput | SaleDetailScalarWhereInput[]
    id?: StringFilter<"SaleDetail"> | string
    saleId?: StringFilter<"SaleDetail"> | string
    productId?: StringFilter<"SaleDetail"> | string
    quantity?: DecimalFilter<"SaleDetail"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SaleDetail"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"SaleDetail"> | Decimal | DecimalJsLike | number | string
  }

  export type InventoryAdjustmentUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryAdjustmentWhereUniqueInput
    update: XOR<InventoryAdjustmentUpdateWithoutProductInput, InventoryAdjustmentUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryAdjustmentCreateWithoutProductInput, InventoryAdjustmentUncheckedCreateWithoutProductInput>
  }

  export type InventoryAdjustmentUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryAdjustmentWhereUniqueInput
    data: XOR<InventoryAdjustmentUpdateWithoutProductInput, InventoryAdjustmentUncheckedUpdateWithoutProductInput>
  }

  export type InventoryAdjustmentUpdateManyWithWhereWithoutProductInput = {
    where: InventoryAdjustmentScalarWhereInput
    data: XOR<InventoryAdjustmentUpdateManyMutationInput, InventoryAdjustmentUncheckedUpdateManyWithoutProductInput>
  }

  export type StockTransferDetailUpsertWithWhereUniqueWithoutProductInput = {
    where: StockTransferDetailWhereUniqueInput
    update: XOR<StockTransferDetailUpdateWithoutProductInput, StockTransferDetailUncheckedUpdateWithoutProductInput>
    create: XOR<StockTransferDetailCreateWithoutProductInput, StockTransferDetailUncheckedCreateWithoutProductInput>
  }

  export type StockTransferDetailUpdateWithWhereUniqueWithoutProductInput = {
    where: StockTransferDetailWhereUniqueInput
    data: XOR<StockTransferDetailUpdateWithoutProductInput, StockTransferDetailUncheckedUpdateWithoutProductInput>
  }

  export type StockTransferDetailUpdateManyWithWhereWithoutProductInput = {
    where: StockTransferDetailScalarWhereInput
    data: XOR<StockTransferDetailUpdateManyMutationInput, StockTransferDetailUncheckedUpdateManyWithoutProductInput>
  }

  export type StockTransferDetailScalarWhereInput = {
    AND?: StockTransferDetailScalarWhereInput | StockTransferDetailScalarWhereInput[]
    OR?: StockTransferDetailScalarWhereInput[]
    NOT?: StockTransferDetailScalarWhereInput | StockTransferDetailScalarWhereInput[]
    id?: StringFilter<"StockTransferDetail"> | string
    transferId?: StringFilter<"StockTransferDetail"> | string
    productId?: StringFilter<"StockTransferDetail"> | string
    quantity?: DecimalFilter<"StockTransferDetail"> | Decimal | DecimalJsLike | number | string
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider?: ProviderCreateNestedOneWithoutProductsInput
    inventory?: ProductBranchCreateNestedManyWithoutProductInput
    saleDetails?: SaleDetailCreateNestedManyWithoutProductInput
    adjustments?: InventoryAdjustmentCreateNestedManyWithoutProductInput
    transferDetails?: StockTransferDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutProductInput
    saleDetails?: SaleDetailUncheckedCreateNestedManyWithoutProductInput
    adjustments?: InventoryAdjustmentUncheckedCreateNestedManyWithoutProductInput
    transferDetails?: StockTransferDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    code?: StringNullableFilter<"Product"> | string | null
    cost?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    priceRetail?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringFilter<"Product"> | string
    isActive?: BoolFilter<"Product"> | boolean
    minStock?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    expiresAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    providerId?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProductCreateWithoutProviderInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    inventory?: ProductBranchCreateNestedManyWithoutProductInput
    saleDetails?: SaleDetailCreateNestedManyWithoutProductInput
    adjustments?: InventoryAdjustmentCreateNestedManyWithoutProductInput
    transferDetails?: StockTransferDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProviderInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutProductInput
    saleDetails?: SaleDetailUncheckedCreateNestedManyWithoutProductInput
    adjustments?: InventoryAdjustmentUncheckedCreateNestedManyWithoutProductInput
    transferDetails?: StockTransferDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProviderInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProviderInput, ProductUncheckedCreateWithoutProviderInput>
  }

  export type PurchaseCreateWithoutProviderInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    branch: BranchCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutProviderInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    branchId: string
  }

  export type PurchaseCreateOrConnectWithoutProviderInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutProviderInput, PurchaseUncheckedCreateWithoutProviderInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutProviderInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProviderInput, ProductUncheckedUpdateWithoutProviderInput>
    create: XOR<ProductCreateWithoutProviderInput, ProductUncheckedCreateWithoutProviderInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProviderInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProviderInput, ProductUncheckedUpdateWithoutProviderInput>
  }

  export type ProductUpdateManyWithWhereWithoutProviderInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProviderInput>
  }

  export type PurchaseUpsertWithWhereUniqueWithoutProviderInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutProviderInput, PurchaseUncheckedUpdateWithoutProviderInput>
    create: XOR<PurchaseCreateWithoutProviderInput, PurchaseUncheckedCreateWithoutProviderInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutProviderInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutProviderInput, PurchaseUncheckedUpdateWithoutProviderInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutProviderInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutProviderInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    date?: DateTimeFilter<"Purchase"> | Date | string
    total?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Purchase"> | string
    providerId?: StringFilter<"Purchase"> | string
    branchId?: StringFilter<"Purchase"> | string
  }

  export type ProductBranchCreateWithoutBranchInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    product: ProductCreateNestedOneWithoutInventoryInput
  }

  export type ProductBranchUncheckedCreateWithoutBranchInput = {
    id?: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
  }

  export type ProductBranchCreateOrConnectWithoutBranchInput = {
    where: ProductBranchWhereUniqueInput
    create: XOR<ProductBranchCreateWithoutBranchInput, ProductBranchUncheckedCreateWithoutBranchInput>
  }

  export type SaleHeaderCreateWithoutBranchInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    user?: UserCreateNestedOneWithoutSalesInput
    shift?: EmployeeShiftCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    details?: SaleDetailCreateNestedManyWithoutSaleInput
    creditPayment?: CreditPaymentCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderUncheckedCreateWithoutBranchInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    userId?: string | null
    shiftId?: string | null
    customerId?: string | null
    details?: SaleDetailUncheckedCreateNestedManyWithoutSaleInput
    creditPayment?: CreditPaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderCreateOrConnectWithoutBranchInput = {
    where: SaleHeaderWhereUniqueInput
    create: XOR<SaleHeaderCreateWithoutBranchInput, SaleHeaderUncheckedCreateWithoutBranchInput>
  }

  export type ExpenseCreateWithoutBranchInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    category: string
    imageUrl?: string | null
  }

  export type ExpenseUncheckedCreateWithoutBranchInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    category: string
    imageUrl?: string | null
  }

  export type ExpenseCreateOrConnectWithoutBranchInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput>
  }

  export type PurchaseCreateWithoutBranchInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    provider: ProviderCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutBranchInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    providerId: string
  }

  export type PurchaseCreateOrConnectWithoutBranchInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutBranchInput, PurchaseUncheckedCreateWithoutBranchInput>
  }

  export type CashMovementCreateWithoutBranchInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    reason: string
    date?: Date | string
    user: UserCreateNestedOneWithoutCashMovementsInput
  }

  export type CashMovementUncheckedCreateWithoutBranchInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    reason: string
    date?: Date | string
    userId: string
  }

  export type CashMovementCreateOrConnectWithoutBranchInput = {
    where: CashMovementWhereUniqueInput
    create: XOR<CashMovementCreateWithoutBranchInput, CashMovementUncheckedCreateWithoutBranchInput>
  }

  export type CustomerCreateWithoutBranchInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    rfc?: string | null
    taxRegime?: string | null
    address?: string | null
    zipCode?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    sales?: SaleHeaderCreateNestedManyWithoutCustomerInput
    creditPayments?: CreditPaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutBranchInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    rfc?: string | null
    taxRegime?: string | null
    address?: string | null
    zipCode?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutCustomerInput
    creditPayments?: CreditPaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutBranchInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutBranchInput, CustomerUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateWithoutBranchInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: EmployeeShiftCreateNestedManyWithoutUserInput
    sales?: SaleHeaderCreateNestedManyWithoutUserInput
    inventoryAdjustments?: InventoryAdjustmentCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    cashMovements?: CashMovementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutUserInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutUserInput
    inventoryAdjustments?: InventoryAdjustmentUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type StockTransferCreateWithoutSourceBranchInput = {
    id?: string
    date?: Date | string
    status?: string
    destBranch: BranchCreateNestedOneWithoutReceivedTransfersInput
    details?: StockTransferDetailCreateNestedManyWithoutTransferInput
  }

  export type StockTransferUncheckedCreateWithoutSourceBranchInput = {
    id?: string
    date?: Date | string
    status?: string
    destBranchId: string
    details?: StockTransferDetailUncheckedCreateNestedManyWithoutTransferInput
  }

  export type StockTransferCreateOrConnectWithoutSourceBranchInput = {
    where: StockTransferWhereUniqueInput
    create: XOR<StockTransferCreateWithoutSourceBranchInput, StockTransferUncheckedCreateWithoutSourceBranchInput>
  }

  export type StockTransferCreateWithoutDestBranchInput = {
    id?: string
    date?: Date | string
    status?: string
    sourceBranch: BranchCreateNestedOneWithoutSentTransfersInput
    details?: StockTransferDetailCreateNestedManyWithoutTransferInput
  }

  export type StockTransferUncheckedCreateWithoutDestBranchInput = {
    id?: string
    date?: Date | string
    status?: string
    sourceBranchId: string
    details?: StockTransferDetailUncheckedCreateNestedManyWithoutTransferInput
  }

  export type StockTransferCreateOrConnectWithoutDestBranchInput = {
    where: StockTransferWhereUniqueInput
    create: XOR<StockTransferCreateWithoutDestBranchInput, StockTransferUncheckedCreateWithoutDestBranchInput>
  }

  export type ProductBranchUpsertWithWhereUniqueWithoutBranchInput = {
    where: ProductBranchWhereUniqueInput
    update: XOR<ProductBranchUpdateWithoutBranchInput, ProductBranchUncheckedUpdateWithoutBranchInput>
    create: XOR<ProductBranchCreateWithoutBranchInput, ProductBranchUncheckedCreateWithoutBranchInput>
  }

  export type ProductBranchUpdateWithWhereUniqueWithoutBranchInput = {
    where: ProductBranchWhereUniqueInput
    data: XOR<ProductBranchUpdateWithoutBranchInput, ProductBranchUncheckedUpdateWithoutBranchInput>
  }

  export type ProductBranchUpdateManyWithWhereWithoutBranchInput = {
    where: ProductBranchScalarWhereInput
    data: XOR<ProductBranchUpdateManyMutationInput, ProductBranchUncheckedUpdateManyWithoutBranchInput>
  }

  export type SaleHeaderUpsertWithWhereUniqueWithoutBranchInput = {
    where: SaleHeaderWhereUniqueInput
    update: XOR<SaleHeaderUpdateWithoutBranchInput, SaleHeaderUncheckedUpdateWithoutBranchInput>
    create: XOR<SaleHeaderCreateWithoutBranchInput, SaleHeaderUncheckedCreateWithoutBranchInput>
  }

  export type SaleHeaderUpdateWithWhereUniqueWithoutBranchInput = {
    where: SaleHeaderWhereUniqueInput
    data: XOR<SaleHeaderUpdateWithoutBranchInput, SaleHeaderUncheckedUpdateWithoutBranchInput>
  }

  export type SaleHeaderUpdateManyWithWhereWithoutBranchInput = {
    where: SaleHeaderScalarWhereInput
    data: XOR<SaleHeaderUpdateManyMutationInput, SaleHeaderUncheckedUpdateManyWithoutBranchInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutBranchInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutBranchInput, ExpenseUncheckedUpdateWithoutBranchInput>
    create: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutBranchInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutBranchInput, ExpenseUncheckedUpdateWithoutBranchInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutBranchInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutBranchInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"Expense"> | string
    category?: StringFilter<"Expense"> | string
    imageUrl?: StringNullableFilter<"Expense"> | string | null
    branchId?: StringFilter<"Expense"> | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutBranchInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutBranchInput, PurchaseUncheckedUpdateWithoutBranchInput>
    create: XOR<PurchaseCreateWithoutBranchInput, PurchaseUncheckedCreateWithoutBranchInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutBranchInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutBranchInput, PurchaseUncheckedUpdateWithoutBranchInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutBranchInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutBranchInput>
  }

  export type CashMovementUpsertWithWhereUniqueWithoutBranchInput = {
    where: CashMovementWhereUniqueInput
    update: XOR<CashMovementUpdateWithoutBranchInput, CashMovementUncheckedUpdateWithoutBranchInput>
    create: XOR<CashMovementCreateWithoutBranchInput, CashMovementUncheckedCreateWithoutBranchInput>
  }

  export type CashMovementUpdateWithWhereUniqueWithoutBranchInput = {
    where: CashMovementWhereUniqueInput
    data: XOR<CashMovementUpdateWithoutBranchInput, CashMovementUncheckedUpdateWithoutBranchInput>
  }

  export type CashMovementUpdateManyWithWhereWithoutBranchInput = {
    where: CashMovementScalarWhereInput
    data: XOR<CashMovementUpdateManyMutationInput, CashMovementUncheckedUpdateManyWithoutBranchInput>
  }

  export type CustomerUpsertWithWhereUniqueWithoutBranchInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutBranchInput, CustomerUncheckedUpdateWithoutBranchInput>
    create: XOR<CustomerCreateWithoutBranchInput, CustomerUncheckedCreateWithoutBranchInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutBranchInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutBranchInput, CustomerUncheckedUpdateWithoutBranchInput>
  }

  export type CustomerUpdateManyWithWhereWithoutBranchInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutBranchInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    rfc?: StringNullableFilter<"Customer"> | string | null
    taxRegime?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    zipCode?: StringNullableFilter<"Customer"> | string | null
    creditLimit?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    branchId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    permissions?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    branchId?: StringNullableFilter<"User"> | string | null
  }

  export type StockTransferUpsertWithWhereUniqueWithoutSourceBranchInput = {
    where: StockTransferWhereUniqueInput
    update: XOR<StockTransferUpdateWithoutSourceBranchInput, StockTransferUncheckedUpdateWithoutSourceBranchInput>
    create: XOR<StockTransferCreateWithoutSourceBranchInput, StockTransferUncheckedCreateWithoutSourceBranchInput>
  }

  export type StockTransferUpdateWithWhereUniqueWithoutSourceBranchInput = {
    where: StockTransferWhereUniqueInput
    data: XOR<StockTransferUpdateWithoutSourceBranchInput, StockTransferUncheckedUpdateWithoutSourceBranchInput>
  }

  export type StockTransferUpdateManyWithWhereWithoutSourceBranchInput = {
    where: StockTransferScalarWhereInput
    data: XOR<StockTransferUpdateManyMutationInput, StockTransferUncheckedUpdateManyWithoutSourceBranchInput>
  }

  export type StockTransferScalarWhereInput = {
    AND?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
    OR?: StockTransferScalarWhereInput[]
    NOT?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
    id?: StringFilter<"StockTransfer"> | string
    date?: DateTimeFilter<"StockTransfer"> | Date | string
    status?: StringFilter<"StockTransfer"> | string
    sourceBranchId?: StringFilter<"StockTransfer"> | string
    destBranchId?: StringFilter<"StockTransfer"> | string
  }

  export type StockTransferUpsertWithWhereUniqueWithoutDestBranchInput = {
    where: StockTransferWhereUniqueInput
    update: XOR<StockTransferUpdateWithoutDestBranchInput, StockTransferUncheckedUpdateWithoutDestBranchInput>
    create: XOR<StockTransferCreateWithoutDestBranchInput, StockTransferUncheckedCreateWithoutDestBranchInput>
  }

  export type StockTransferUpdateWithWhereUniqueWithoutDestBranchInput = {
    where: StockTransferWhereUniqueInput
    data: XOR<StockTransferUpdateWithoutDestBranchInput, StockTransferUncheckedUpdateWithoutDestBranchInput>
  }

  export type StockTransferUpdateManyWithWhereWithoutDestBranchInput = {
    where: StockTransferScalarWhereInput
    data: XOR<StockTransferUpdateManyMutationInput, StockTransferUncheckedUpdateManyWithoutDestBranchInput>
  }

  export type ProductCreateWithoutInventoryInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider?: ProviderCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    saleDetails?: SaleDetailCreateNestedManyWithoutProductInput
    adjustments?: InventoryAdjustmentCreateNestedManyWithoutProductInput
    transferDetails?: StockTransferDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    providerId?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    saleDetails?: SaleDetailUncheckedCreateNestedManyWithoutProductInput
    adjustments?: InventoryAdjustmentUncheckedCreateNestedManyWithoutProductInput
    transferDetails?: StockTransferDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
  }

  export type BranchCreateWithoutInventoryInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    sales?: SaleHeaderCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    purchases?: PurchaseCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementCreateNestedManyWithoutBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferCreateNestedManyWithoutDestBranchInput
  }

  export type BranchUncheckedCreateWithoutInventoryInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferUncheckedCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferUncheckedCreateNestedManyWithoutDestBranchInput
  }

  export type BranchCreateOrConnectWithoutInventoryInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutInventoryInput, BranchUncheckedCreateWithoutInventoryInput>
  }

  export type ProductUpsertWithoutInventoryInput = {
    update: XOR<ProductUpdateWithoutInventoryInput, ProductUncheckedUpdateWithoutInventoryInput>
    create: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryInput, ProductUncheckedUpdateWithoutInventoryInput>
  }

  export type ProductUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    saleDetails?: SaleDetailUpdateManyWithoutProductNestedInput
    adjustments?: InventoryAdjustmentUpdateManyWithoutProductNestedInput
    transferDetails?: StockTransferDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleDetails?: SaleDetailUncheckedUpdateManyWithoutProductNestedInput
    adjustments?: InventoryAdjustmentUncheckedUpdateManyWithoutProductNestedInput
    transferDetails?: StockTransferDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BranchUpsertWithoutInventoryInput = {
    update: XOR<BranchUpdateWithoutInventoryInput, BranchUncheckedUpdateWithoutInventoryInput>
    create: XOR<BranchCreateWithoutInventoryInput, BranchUncheckedCreateWithoutInventoryInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutInventoryInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutInventoryInput, BranchUncheckedUpdateWithoutInventoryInput>
  }

  export type BranchUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: SaleHeaderUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUpdateManyWithoutBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUpdateManyWithoutDestBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: SaleHeaderUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUncheckedUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUncheckedUpdateManyWithoutDestBranchNestedInput
  }

  export type BranchCreateWithoutCustomersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    purchases?: PurchaseCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferCreateNestedManyWithoutDestBranchInput
  }

  export type BranchUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferUncheckedCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferUncheckedCreateNestedManyWithoutDestBranchInput
  }

  export type BranchCreateOrConnectWithoutCustomersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutCustomersInput, BranchUncheckedCreateWithoutCustomersInput>
  }

  export type SaleHeaderCreateWithoutCustomerInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    branch: BranchCreateNestedOneWithoutSalesInput
    user?: UserCreateNestedOneWithoutSalesInput
    shift?: EmployeeShiftCreateNestedOneWithoutSalesInput
    details?: SaleDetailCreateNestedManyWithoutSaleInput
    creditPayment?: CreditPaymentCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderUncheckedCreateWithoutCustomerInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    branchId: string
    userId?: string | null
    shiftId?: string | null
    details?: SaleDetailUncheckedCreateNestedManyWithoutSaleInput
    creditPayment?: CreditPaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderCreateOrConnectWithoutCustomerInput = {
    where: SaleHeaderWhereUniqueInput
    create: XOR<SaleHeaderCreateWithoutCustomerInput, SaleHeaderUncheckedCreateWithoutCustomerInput>
  }

  export type CreditPaymentCreateWithoutCustomerInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    sale?: SaleHeaderCreateNestedOneWithoutCreditPaymentInput
  }

  export type CreditPaymentUncheckedCreateWithoutCustomerInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    saleId?: string | null
  }

  export type CreditPaymentCreateOrConnectWithoutCustomerInput = {
    where: CreditPaymentWhereUniqueInput
    create: XOR<CreditPaymentCreateWithoutCustomerInput, CreditPaymentUncheckedCreateWithoutCustomerInput>
  }

  export type BranchUpsertWithoutCustomersInput = {
    update: XOR<BranchUpdateWithoutCustomersInput, BranchUncheckedUpdateWithoutCustomersInput>
    create: XOR<BranchCreateWithoutCustomersInput, BranchUncheckedCreateWithoutCustomersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutCustomersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutCustomersInput, BranchUncheckedUpdateWithoutCustomersInput>
  }

  export type BranchUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUpdateManyWithoutDestBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUncheckedUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUncheckedUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUncheckedUpdateManyWithoutDestBranchNestedInput
  }

  export type SaleHeaderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SaleHeaderWhereUniqueInput
    update: XOR<SaleHeaderUpdateWithoutCustomerInput, SaleHeaderUncheckedUpdateWithoutCustomerInput>
    create: XOR<SaleHeaderCreateWithoutCustomerInput, SaleHeaderUncheckedCreateWithoutCustomerInput>
  }

  export type SaleHeaderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SaleHeaderWhereUniqueInput
    data: XOR<SaleHeaderUpdateWithoutCustomerInput, SaleHeaderUncheckedUpdateWithoutCustomerInput>
  }

  export type SaleHeaderUpdateManyWithWhereWithoutCustomerInput = {
    where: SaleHeaderScalarWhereInput
    data: XOR<SaleHeaderUpdateManyMutationInput, SaleHeaderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CreditPaymentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CreditPaymentWhereUniqueInput
    update: XOR<CreditPaymentUpdateWithoutCustomerInput, CreditPaymentUncheckedUpdateWithoutCustomerInput>
    create: XOR<CreditPaymentCreateWithoutCustomerInput, CreditPaymentUncheckedCreateWithoutCustomerInput>
  }

  export type CreditPaymentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CreditPaymentWhereUniqueInput
    data: XOR<CreditPaymentUpdateWithoutCustomerInput, CreditPaymentUncheckedUpdateWithoutCustomerInput>
  }

  export type CreditPaymentUpdateManyWithWhereWithoutCustomerInput = {
    where: CreditPaymentScalarWhereInput
    data: XOR<CreditPaymentUpdateManyMutationInput, CreditPaymentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CreditPaymentScalarWhereInput = {
    AND?: CreditPaymentScalarWhereInput | CreditPaymentScalarWhereInput[]
    OR?: CreditPaymentScalarWhereInput[]
    NOT?: CreditPaymentScalarWhereInput | CreditPaymentScalarWhereInput[]
    id?: StringFilter<"CreditPayment"> | string
    date?: DateTimeFilter<"CreditPayment"> | Date | string
    amount?: DecimalFilter<"CreditPayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFilter<"CreditPayment"> | string
    customerId?: StringFilter<"CreditPayment"> | string
    saleId?: StringNullableFilter<"CreditPayment"> | string | null
  }

  export type BranchCreateWithoutSalesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    purchases?: PurchaseCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementCreateNestedManyWithoutBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferCreateNestedManyWithoutDestBranchInput
  }

  export type BranchUncheckedCreateWithoutSalesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferUncheckedCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferUncheckedCreateNestedManyWithoutDestBranchInput
  }

  export type BranchCreateOrConnectWithoutSalesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSalesInput, BranchUncheckedCreateWithoutSalesInput>
  }

  export type UserCreateWithoutSalesInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    shifts?: EmployeeShiftCreateNestedManyWithoutUserInput
    inventoryAdjustments?: InventoryAdjustmentCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    cashMovements?: CashMovementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalesInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId?: string | null
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutUserInput
    inventoryAdjustments?: InventoryAdjustmentUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
  }

  export type EmployeeShiftCreateWithoutSalesInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    initialCash: Decimal | DecimalJsLike | number | string
    finalCashExpected?: Decimal | DecimalJsLike | number | string | null
    finalCashActual?: Decimal | DecimalJsLike | number | string | null
    difference?: Decimal | DecimalJsLike | number | string | null
    user: UserCreateNestedOneWithoutShiftsInput
    cashCounts?: CashCountCreateNestedManyWithoutShiftInput
  }

  export type EmployeeShiftUncheckedCreateWithoutSalesInput = {
    id?: string
    userId: string
    startTime?: Date | string
    endTime?: Date | string | null
    initialCash: Decimal | DecimalJsLike | number | string
    finalCashExpected?: Decimal | DecimalJsLike | number | string | null
    finalCashActual?: Decimal | DecimalJsLike | number | string | null
    difference?: Decimal | DecimalJsLike | number | string | null
    cashCounts?: CashCountUncheckedCreateNestedManyWithoutShiftInput
  }

  export type EmployeeShiftCreateOrConnectWithoutSalesInput = {
    where: EmployeeShiftWhereUniqueInput
    create: XOR<EmployeeShiftCreateWithoutSalesInput, EmployeeShiftUncheckedCreateWithoutSalesInput>
  }

  export type CustomerCreateWithoutSalesInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    rfc?: string | null
    taxRegime?: string | null
    address?: string | null
    zipCode?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutCustomersInput
    creditPayments?: CreditPaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSalesInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    rfc?: string | null
    taxRegime?: string | null
    address?: string | null
    zipCode?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    branchId?: string | null
    createdAt?: Date | string
    creditPayments?: CreditPaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSalesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
  }

  export type SaleDetailCreateWithoutSaleInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    product: ProductCreateNestedOneWithoutSaleDetailsInput
  }

  export type SaleDetailUncheckedCreateWithoutSaleInput = {
    id?: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
  }

  export type SaleDetailCreateOrConnectWithoutSaleInput = {
    where: SaleDetailWhereUniqueInput
    create: XOR<SaleDetailCreateWithoutSaleInput, SaleDetailUncheckedCreateWithoutSaleInput>
  }

  export type CreditPaymentCreateWithoutSaleInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    customer: CustomerCreateNestedOneWithoutCreditPaymentsInput
  }

  export type CreditPaymentUncheckedCreateWithoutSaleInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    customerId: string
  }

  export type CreditPaymentCreateOrConnectWithoutSaleInput = {
    where: CreditPaymentWhereUniqueInput
    create: XOR<CreditPaymentCreateWithoutSaleInput, CreditPaymentUncheckedCreateWithoutSaleInput>
  }

  export type BranchUpsertWithoutSalesInput = {
    update: XOR<BranchUpdateWithoutSalesInput, BranchUncheckedUpdateWithoutSalesInput>
    create: XOR<BranchCreateWithoutSalesInput, BranchUncheckedCreateWithoutSalesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSalesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSalesInput, BranchUncheckedUpdateWithoutSalesInput>
  }

  export type BranchUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUpdateManyWithoutBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUpdateManyWithoutDestBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUncheckedUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUncheckedUpdateManyWithoutDestBranchNestedInput
  }

  export type UserUpsertWithoutSalesInput = {
    update: XOR<UserUpdateWithoutSalesInput, UserUncheckedUpdateWithoutSalesInput>
    create: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalesInput, UserUncheckedUpdateWithoutSalesInput>
  }

  export type UserUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutUserNestedInput
    inventoryAdjustments?: InventoryAdjustmentUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    cashMovements?: CashMovementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutUserNestedInput
    inventoryAdjustments?: InventoryAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmployeeShiftUpsertWithoutSalesInput = {
    update: XOR<EmployeeShiftUpdateWithoutSalesInput, EmployeeShiftUncheckedUpdateWithoutSalesInput>
    create: XOR<EmployeeShiftCreateWithoutSalesInput, EmployeeShiftUncheckedCreateWithoutSalesInput>
    where?: EmployeeShiftWhereInput
  }

  export type EmployeeShiftUpdateToOneWithWhereWithoutSalesInput = {
    where?: EmployeeShiftWhereInput
    data: XOR<EmployeeShiftUpdateWithoutSalesInput, EmployeeShiftUncheckedUpdateWithoutSalesInput>
  }

  export type EmployeeShiftUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalCashExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    difference?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: UserUpdateOneRequiredWithoutShiftsNestedInput
    cashCounts?: CashCountUpdateManyWithoutShiftNestedInput
  }

  export type EmployeeShiftUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalCashExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    difference?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cashCounts?: CashCountUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type CustomerUpsertWithoutSalesInput = {
    update: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type CustomerUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    taxRegime?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutCustomersNestedInput
    creditPayments?: CreditPaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    taxRegime?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditPayments?: CreditPaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SaleDetailUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleDetailWhereUniqueInput
    update: XOR<SaleDetailUpdateWithoutSaleInput, SaleDetailUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleDetailCreateWithoutSaleInput, SaleDetailUncheckedCreateWithoutSaleInput>
  }

  export type SaleDetailUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleDetailWhereUniqueInput
    data: XOR<SaleDetailUpdateWithoutSaleInput, SaleDetailUncheckedUpdateWithoutSaleInput>
  }

  export type SaleDetailUpdateManyWithWhereWithoutSaleInput = {
    where: SaleDetailScalarWhereInput
    data: XOR<SaleDetailUpdateManyMutationInput, SaleDetailUncheckedUpdateManyWithoutSaleInput>
  }

  export type CreditPaymentUpsertWithWhereUniqueWithoutSaleInput = {
    where: CreditPaymentWhereUniqueInput
    update: XOR<CreditPaymentUpdateWithoutSaleInput, CreditPaymentUncheckedUpdateWithoutSaleInput>
    create: XOR<CreditPaymentCreateWithoutSaleInput, CreditPaymentUncheckedCreateWithoutSaleInput>
  }

  export type CreditPaymentUpdateWithWhereUniqueWithoutSaleInput = {
    where: CreditPaymentWhereUniqueInput
    data: XOR<CreditPaymentUpdateWithoutSaleInput, CreditPaymentUncheckedUpdateWithoutSaleInput>
  }

  export type CreditPaymentUpdateManyWithWhereWithoutSaleInput = {
    where: CreditPaymentScalarWhereInput
    data: XOR<CreditPaymentUpdateManyMutationInput, CreditPaymentUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleHeaderCreateWithoutDetailsInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    branch: BranchCreateNestedOneWithoutSalesInput
    user?: UserCreateNestedOneWithoutSalesInput
    shift?: EmployeeShiftCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    creditPayment?: CreditPaymentCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderUncheckedCreateWithoutDetailsInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    branchId: string
    userId?: string | null
    shiftId?: string | null
    customerId?: string | null
    creditPayment?: CreditPaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderCreateOrConnectWithoutDetailsInput = {
    where: SaleHeaderWhereUniqueInput
    create: XOR<SaleHeaderCreateWithoutDetailsInput, SaleHeaderUncheckedCreateWithoutDetailsInput>
  }

  export type ProductCreateWithoutSaleDetailsInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider?: ProviderCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    inventory?: ProductBranchCreateNestedManyWithoutProductInput
    adjustments?: InventoryAdjustmentCreateNestedManyWithoutProductInput
    transferDetails?: StockTransferDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSaleDetailsInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    providerId?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutProductInput
    adjustments?: InventoryAdjustmentUncheckedCreateNestedManyWithoutProductInput
    transferDetails?: StockTransferDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSaleDetailsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSaleDetailsInput, ProductUncheckedCreateWithoutSaleDetailsInput>
  }

  export type SaleHeaderUpsertWithoutDetailsInput = {
    update: XOR<SaleHeaderUpdateWithoutDetailsInput, SaleHeaderUncheckedUpdateWithoutDetailsInput>
    create: XOR<SaleHeaderCreateWithoutDetailsInput, SaleHeaderUncheckedCreateWithoutDetailsInput>
    where?: SaleHeaderWhereInput
  }

  export type SaleHeaderUpdateToOneWithWhereWithoutDetailsInput = {
    where?: SaleHeaderWhereInput
    data: XOR<SaleHeaderUpdateWithoutDetailsInput, SaleHeaderUncheckedUpdateWithoutDetailsInput>
  }

  export type SaleHeaderUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branch?: BranchUpdateOneRequiredWithoutSalesNestedInput
    user?: UserUpdateOneWithoutSalesNestedInput
    shift?: EmployeeShiftUpdateOneWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    creditPayment?: CreditPaymentUpdateManyWithoutSaleNestedInput
  }

  export type SaleHeaderUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    creditPayment?: CreditPaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type ProductUpsertWithoutSaleDetailsInput = {
    update: XOR<ProductUpdateWithoutSaleDetailsInput, ProductUncheckedUpdateWithoutSaleDetailsInput>
    create: XOR<ProductCreateWithoutSaleDetailsInput, ProductUncheckedCreateWithoutSaleDetailsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSaleDetailsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSaleDetailsInput, ProductUncheckedUpdateWithoutSaleDetailsInput>
  }

  export type ProductUpdateWithoutSaleDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inventory?: ProductBranchUpdateManyWithoutProductNestedInput
    adjustments?: InventoryAdjustmentUpdateManyWithoutProductNestedInput
    transferDetails?: StockTransferDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSaleDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductBranchUncheckedUpdateManyWithoutProductNestedInput
    adjustments?: InventoryAdjustmentUncheckedUpdateManyWithoutProductNestedInput
    transferDetails?: StockTransferDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BranchCreateWithoutExpensesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderCreateNestedManyWithoutBranchInput
    purchases?: PurchaseCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementCreateNestedManyWithoutBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferCreateNestedManyWithoutDestBranchInput
  }

  export type BranchUncheckedCreateWithoutExpensesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutBranchInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferUncheckedCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferUncheckedCreateNestedManyWithoutDestBranchInput
  }

  export type BranchCreateOrConnectWithoutExpensesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutExpensesInput, BranchUncheckedCreateWithoutExpensesInput>
  }

  export type BranchUpsertWithoutExpensesInput = {
    update: XOR<BranchUpdateWithoutExpensesInput, BranchUncheckedUpdateWithoutExpensesInput>
    create: XOR<BranchCreateWithoutExpensesInput, BranchUncheckedCreateWithoutExpensesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutExpensesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutExpensesInput, BranchUncheckedUpdateWithoutExpensesInput>
  }

  export type BranchUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUpdateManyWithoutBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUpdateManyWithoutDestBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUncheckedUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUncheckedUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUncheckedUpdateManyWithoutDestBranchNestedInput
  }

  export type ProviderCreateWithoutPurchasesInput = {
    id?: string
    name: string
    contact?: string | null
    phone?: string | null
    email?: string | null
    rfc?: string | null
    address?: string | null
    products?: ProductCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutPurchasesInput = {
    id?: string
    name: string
    contact?: string | null
    phone?: string | null
    email?: string | null
    rfc?: string | null
    address?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutPurchasesInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutPurchasesInput, ProviderUncheckedCreateWithoutPurchasesInput>
  }

  export type BranchCreateWithoutPurchasesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementCreateNestedManyWithoutBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferCreateNestedManyWithoutDestBranchInput
  }

  export type BranchUncheckedCreateWithoutPurchasesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferUncheckedCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferUncheckedCreateNestedManyWithoutDestBranchInput
  }

  export type BranchCreateOrConnectWithoutPurchasesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutPurchasesInput, BranchUncheckedCreateWithoutPurchasesInput>
  }

  export type ProviderUpsertWithoutPurchasesInput = {
    update: XOR<ProviderUpdateWithoutPurchasesInput, ProviderUncheckedUpdateWithoutPurchasesInput>
    create: XOR<ProviderCreateWithoutPurchasesInput, ProviderUncheckedCreateWithoutPurchasesInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutPurchasesInput, ProviderUncheckedUpdateWithoutPurchasesInput>
  }

  export type ProviderUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type BranchUpsertWithoutPurchasesInput = {
    update: XOR<BranchUpdateWithoutPurchasesInput, BranchUncheckedUpdateWithoutPurchasesInput>
    create: XOR<BranchCreateWithoutPurchasesInput, BranchUncheckedCreateWithoutPurchasesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutPurchasesInput, BranchUncheckedUpdateWithoutPurchasesInput>
  }

  export type BranchUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUpdateManyWithoutBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUpdateManyWithoutDestBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUncheckedUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUncheckedUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUncheckedUpdateManyWithoutDestBranchNestedInput
  }

  export type CustomerCreateWithoutCreditPaymentsInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    rfc?: string | null
    taxRegime?: string | null
    address?: string | null
    zipCode?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutCustomersInput
    sales?: SaleHeaderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCreditPaymentsInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    rfc?: string | null
    taxRegime?: string | null
    address?: string | null
    zipCode?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    branchId?: string | null
    createdAt?: Date | string
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCreditPaymentsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCreditPaymentsInput, CustomerUncheckedCreateWithoutCreditPaymentsInput>
  }

  export type SaleHeaderCreateWithoutCreditPaymentInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    branch: BranchCreateNestedOneWithoutSalesInput
    user?: UserCreateNestedOneWithoutSalesInput
    shift?: EmployeeShiftCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    details?: SaleDetailCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderUncheckedCreateWithoutCreditPaymentInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    branchId: string
    userId?: string | null
    shiftId?: string | null
    customerId?: string | null
    details?: SaleDetailUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderCreateOrConnectWithoutCreditPaymentInput = {
    where: SaleHeaderWhereUniqueInput
    create: XOR<SaleHeaderCreateWithoutCreditPaymentInput, SaleHeaderUncheckedCreateWithoutCreditPaymentInput>
  }

  export type CustomerUpsertWithoutCreditPaymentsInput = {
    update: XOR<CustomerUpdateWithoutCreditPaymentsInput, CustomerUncheckedUpdateWithoutCreditPaymentsInput>
    create: XOR<CustomerCreateWithoutCreditPaymentsInput, CustomerUncheckedCreateWithoutCreditPaymentsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCreditPaymentsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCreditPaymentsInput, CustomerUncheckedUpdateWithoutCreditPaymentsInput>
  }

  export type CustomerUpdateWithoutCreditPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    taxRegime?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutCustomersNestedInput
    sales?: SaleHeaderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCreditPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    taxRegime?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleHeaderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SaleHeaderUpsertWithoutCreditPaymentInput = {
    update: XOR<SaleHeaderUpdateWithoutCreditPaymentInput, SaleHeaderUncheckedUpdateWithoutCreditPaymentInput>
    create: XOR<SaleHeaderCreateWithoutCreditPaymentInput, SaleHeaderUncheckedCreateWithoutCreditPaymentInput>
    where?: SaleHeaderWhereInput
  }

  export type SaleHeaderUpdateToOneWithWhereWithoutCreditPaymentInput = {
    where?: SaleHeaderWhereInput
    data: XOR<SaleHeaderUpdateWithoutCreditPaymentInput, SaleHeaderUncheckedUpdateWithoutCreditPaymentInput>
  }

  export type SaleHeaderUpdateWithoutCreditPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branch?: BranchUpdateOneRequiredWithoutSalesNestedInput
    user?: UserUpdateOneWithoutSalesNestedInput
    shift?: EmployeeShiftUpdateOneWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    details?: SaleDetailUpdateManyWithoutSaleNestedInput
  }

  export type SaleHeaderUncheckedUpdateWithoutCreditPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: SaleDetailUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type UserCreateWithoutShiftsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    sales?: SaleHeaderCreateNestedManyWithoutUserInput
    inventoryAdjustments?: InventoryAdjustmentCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    cashMovements?: CashMovementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShiftsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId?: string | null
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutUserInput
    inventoryAdjustments?: InventoryAdjustmentUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShiftsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShiftsInput, UserUncheckedCreateWithoutShiftsInput>
  }

  export type CashCountCreateWithoutShiftInput = {
    id?: string
    denomination: Decimal | DecimalJsLike | number | string
    quantity: number
    type: string
  }

  export type CashCountUncheckedCreateWithoutShiftInput = {
    id?: string
    denomination: Decimal | DecimalJsLike | number | string
    quantity: number
    type: string
  }

  export type CashCountCreateOrConnectWithoutShiftInput = {
    where: CashCountWhereUniqueInput
    create: XOR<CashCountCreateWithoutShiftInput, CashCountUncheckedCreateWithoutShiftInput>
  }

  export type SaleHeaderCreateWithoutShiftInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    branch: BranchCreateNestedOneWithoutSalesInput
    user?: UserCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    details?: SaleDetailCreateNestedManyWithoutSaleInput
    creditPayment?: CreditPaymentCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderUncheckedCreateWithoutShiftInput = {
    id?: string
    date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod: string
    status: string
    branchId: string
    userId?: string | null
    customerId?: string | null
    details?: SaleDetailUncheckedCreateNestedManyWithoutSaleInput
    creditPayment?: CreditPaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleHeaderCreateOrConnectWithoutShiftInput = {
    where: SaleHeaderWhereUniqueInput
    create: XOR<SaleHeaderCreateWithoutShiftInput, SaleHeaderUncheckedCreateWithoutShiftInput>
  }

  export type UserUpsertWithoutShiftsInput = {
    update: XOR<UserUpdateWithoutShiftsInput, UserUncheckedUpdateWithoutShiftsInput>
    create: XOR<UserCreateWithoutShiftsInput, UserUncheckedCreateWithoutShiftsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShiftsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShiftsInput, UserUncheckedUpdateWithoutShiftsInput>
  }

  export type UserUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    sales?: SaleHeaderUpdateManyWithoutUserNestedInput
    inventoryAdjustments?: InventoryAdjustmentUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    cashMovements?: CashMovementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    sales?: SaleHeaderUncheckedUpdateManyWithoutUserNestedInput
    inventoryAdjustments?: InventoryAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CashCountUpsertWithWhereUniqueWithoutShiftInput = {
    where: CashCountWhereUniqueInput
    update: XOR<CashCountUpdateWithoutShiftInput, CashCountUncheckedUpdateWithoutShiftInput>
    create: XOR<CashCountCreateWithoutShiftInput, CashCountUncheckedCreateWithoutShiftInput>
  }

  export type CashCountUpdateWithWhereUniqueWithoutShiftInput = {
    where: CashCountWhereUniqueInput
    data: XOR<CashCountUpdateWithoutShiftInput, CashCountUncheckedUpdateWithoutShiftInput>
  }

  export type CashCountUpdateManyWithWhereWithoutShiftInput = {
    where: CashCountScalarWhereInput
    data: XOR<CashCountUpdateManyMutationInput, CashCountUncheckedUpdateManyWithoutShiftInput>
  }

  export type CashCountScalarWhereInput = {
    AND?: CashCountScalarWhereInput | CashCountScalarWhereInput[]
    OR?: CashCountScalarWhereInput[]
    NOT?: CashCountScalarWhereInput | CashCountScalarWhereInput[]
    id?: StringFilter<"CashCount"> | string
    shiftId?: StringFilter<"CashCount"> | string
    denomination?: DecimalFilter<"CashCount"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"CashCount"> | number
    type?: StringFilter<"CashCount"> | string
  }

  export type SaleHeaderUpsertWithWhereUniqueWithoutShiftInput = {
    where: SaleHeaderWhereUniqueInput
    update: XOR<SaleHeaderUpdateWithoutShiftInput, SaleHeaderUncheckedUpdateWithoutShiftInput>
    create: XOR<SaleHeaderCreateWithoutShiftInput, SaleHeaderUncheckedCreateWithoutShiftInput>
  }

  export type SaleHeaderUpdateWithWhereUniqueWithoutShiftInput = {
    where: SaleHeaderWhereUniqueInput
    data: XOR<SaleHeaderUpdateWithoutShiftInput, SaleHeaderUncheckedUpdateWithoutShiftInput>
  }

  export type SaleHeaderUpdateManyWithWhereWithoutShiftInput = {
    where: SaleHeaderScalarWhereInput
    data: XOR<SaleHeaderUpdateManyMutationInput, SaleHeaderUncheckedUpdateManyWithoutShiftInput>
  }

  export type EmployeeShiftCreateWithoutCashCountsInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    initialCash: Decimal | DecimalJsLike | number | string
    finalCashExpected?: Decimal | DecimalJsLike | number | string | null
    finalCashActual?: Decimal | DecimalJsLike | number | string | null
    difference?: Decimal | DecimalJsLike | number | string | null
    user: UserCreateNestedOneWithoutShiftsInput
    sales?: SaleHeaderCreateNestedManyWithoutShiftInput
  }

  export type EmployeeShiftUncheckedCreateWithoutCashCountsInput = {
    id?: string
    userId: string
    startTime?: Date | string
    endTime?: Date | string | null
    initialCash: Decimal | DecimalJsLike | number | string
    finalCashExpected?: Decimal | DecimalJsLike | number | string | null
    finalCashActual?: Decimal | DecimalJsLike | number | string | null
    difference?: Decimal | DecimalJsLike | number | string | null
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutShiftInput
  }

  export type EmployeeShiftCreateOrConnectWithoutCashCountsInput = {
    where: EmployeeShiftWhereUniqueInput
    create: XOR<EmployeeShiftCreateWithoutCashCountsInput, EmployeeShiftUncheckedCreateWithoutCashCountsInput>
  }

  export type EmployeeShiftUpsertWithoutCashCountsInput = {
    update: XOR<EmployeeShiftUpdateWithoutCashCountsInput, EmployeeShiftUncheckedUpdateWithoutCashCountsInput>
    create: XOR<EmployeeShiftCreateWithoutCashCountsInput, EmployeeShiftUncheckedCreateWithoutCashCountsInput>
    where?: EmployeeShiftWhereInput
  }

  export type EmployeeShiftUpdateToOneWithWhereWithoutCashCountsInput = {
    where?: EmployeeShiftWhereInput
    data: XOR<EmployeeShiftUpdateWithoutCashCountsInput, EmployeeShiftUncheckedUpdateWithoutCashCountsInput>
  }

  export type EmployeeShiftUpdateWithoutCashCountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalCashExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    difference?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: UserUpdateOneRequiredWithoutShiftsNestedInput
    sales?: SaleHeaderUpdateManyWithoutShiftNestedInput
  }

  export type EmployeeShiftUncheckedUpdateWithoutCashCountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalCashExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    difference?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sales?: SaleHeaderUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type UserCreateWithoutCashMovementsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    shifts?: EmployeeShiftCreateNestedManyWithoutUserInput
    sales?: SaleHeaderCreateNestedManyWithoutUserInput
    inventoryAdjustments?: InventoryAdjustmentCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCashMovementsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId?: string | null
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutUserInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutUserInput
    inventoryAdjustments?: InventoryAdjustmentUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCashMovementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashMovementsInput, UserUncheckedCreateWithoutCashMovementsInput>
  }

  export type BranchCreateWithoutCashMovementsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    purchases?: PurchaseCreateNestedManyWithoutBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferCreateNestedManyWithoutDestBranchInput
  }

  export type BranchUncheckedCreateWithoutCashMovementsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferUncheckedCreateNestedManyWithoutSourceBranchInput
    receivedTransfers?: StockTransferUncheckedCreateNestedManyWithoutDestBranchInput
  }

  export type BranchCreateOrConnectWithoutCashMovementsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutCashMovementsInput, BranchUncheckedCreateWithoutCashMovementsInput>
  }

  export type UserUpsertWithoutCashMovementsInput = {
    update: XOR<UserUpdateWithoutCashMovementsInput, UserUncheckedUpdateWithoutCashMovementsInput>
    create: XOR<UserCreateWithoutCashMovementsInput, UserUncheckedCreateWithoutCashMovementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCashMovementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCashMovementsInput, UserUncheckedUpdateWithoutCashMovementsInput>
  }

  export type UserUpdateWithoutCashMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutUserNestedInput
    sales?: SaleHeaderUpdateManyWithoutUserNestedInput
    inventoryAdjustments?: InventoryAdjustmentUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCashMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutUserNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutUserNestedInput
    inventoryAdjustments?: InventoryAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BranchUpsertWithoutCashMovementsInput = {
    update: XOR<BranchUpdateWithoutCashMovementsInput, BranchUncheckedUpdateWithoutCashMovementsInput>
    create: XOR<BranchCreateWithoutCashMovementsInput, BranchUncheckedCreateWithoutCashMovementsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutCashMovementsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutCashMovementsInput, BranchUncheckedUpdateWithoutCashMovementsInput>
  }

  export type BranchUpdateWithoutCashMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUpdateManyWithoutBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUpdateManyWithoutDestBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutCashMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUncheckedUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUncheckedUpdateManyWithoutSourceBranchNestedInput
    receivedTransfers?: StockTransferUncheckedUpdateManyWithoutDestBranchNestedInput
  }

  export type ProductCreateWithoutAdjustmentsInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider?: ProviderCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    inventory?: ProductBranchCreateNestedManyWithoutProductInput
    saleDetails?: SaleDetailCreateNestedManyWithoutProductInput
    transferDetails?: StockTransferDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAdjustmentsInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    providerId?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutProductInput
    saleDetails?: SaleDetailUncheckedCreateNestedManyWithoutProductInput
    transferDetails?: StockTransferDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAdjustmentsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAdjustmentsInput, ProductUncheckedCreateWithoutAdjustmentsInput>
  }

  export type UserCreateWithoutInventoryAdjustmentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    shifts?: EmployeeShiftCreateNestedManyWithoutUserInput
    sales?: SaleHeaderCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    cashMovements?: CashMovementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoryAdjustmentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId?: string | null
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutUserInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoryAdjustmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryAdjustmentsInput, UserUncheckedCreateWithoutInventoryAdjustmentsInput>
  }

  export type ProductUpsertWithoutAdjustmentsInput = {
    update: XOR<ProductUpdateWithoutAdjustmentsInput, ProductUncheckedUpdateWithoutAdjustmentsInput>
    create: XOR<ProductCreateWithoutAdjustmentsInput, ProductUncheckedCreateWithoutAdjustmentsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAdjustmentsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAdjustmentsInput, ProductUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type ProductUpdateWithoutAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inventory?: ProductBranchUpdateManyWithoutProductNestedInput
    saleDetails?: SaleDetailUpdateManyWithoutProductNestedInput
    transferDetails?: StockTransferDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductBranchUncheckedUpdateManyWithoutProductNestedInput
    saleDetails?: SaleDetailUncheckedUpdateManyWithoutProductNestedInput
    transferDetails?: StockTransferDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutInventoryAdjustmentsInput = {
    update: XOR<UserUpdateWithoutInventoryAdjustmentsInput, UserUncheckedUpdateWithoutInventoryAdjustmentsInput>
    create: XOR<UserCreateWithoutInventoryAdjustmentsInput, UserUncheckedCreateWithoutInventoryAdjustmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryAdjustmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryAdjustmentsInput, UserUncheckedUpdateWithoutInventoryAdjustmentsInput>
  }

  export type UserUpdateWithoutInventoryAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutUserNestedInput
    sales?: SaleHeaderUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    cashMovements?: CashMovementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutUserNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSystemLogsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    shifts?: EmployeeShiftCreateNestedManyWithoutUserInput
    sales?: SaleHeaderCreateNestedManyWithoutUserInput
    inventoryAdjustments?: InventoryAdjustmentCreateNestedManyWithoutUserInput
    cashMovements?: CashMovementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSystemLogsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: string
    permissions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId?: string | null
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutUserInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutUserInput
    inventoryAdjustments?: InventoryAdjustmentUncheckedCreateNestedManyWithoutUserInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSystemLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSystemLogsInput, UserUncheckedCreateWithoutSystemLogsInput>
  }

  export type UserUpsertWithoutSystemLogsInput = {
    update: XOR<UserUpdateWithoutSystemLogsInput, UserUncheckedUpdateWithoutSystemLogsInput>
    create: XOR<UserCreateWithoutSystemLogsInput, UserUncheckedCreateWithoutSystemLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSystemLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSystemLogsInput, UserUncheckedUpdateWithoutSystemLogsInput>
  }

  export type UserUpdateWithoutSystemLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutUserNestedInput
    sales?: SaleHeaderUpdateManyWithoutUserNestedInput
    inventoryAdjustments?: InventoryAdjustmentUpdateManyWithoutUserNestedInput
    cashMovements?: CashMovementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSystemLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutUserNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutUserNestedInput
    inventoryAdjustments?: InventoryAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BranchCreateWithoutSentTransfersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    purchases?: PurchaseCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementCreateNestedManyWithoutBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    receivedTransfers?: StockTransferCreateNestedManyWithoutDestBranchInput
  }

  export type BranchUncheckedCreateWithoutSentTransfersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    receivedTransfers?: StockTransferUncheckedCreateNestedManyWithoutDestBranchInput
  }

  export type BranchCreateOrConnectWithoutSentTransfersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSentTransfersInput, BranchUncheckedCreateWithoutSentTransfersInput>
  }

  export type BranchCreateWithoutReceivedTransfersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    purchases?: PurchaseCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementCreateNestedManyWithoutBranchInput
    customers?: CustomerCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferCreateNestedManyWithoutSourceBranchInput
  }

  export type BranchUncheckedCreateWithoutReceivedTransfersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutBranchInput
    sales?: SaleHeaderUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutBranchInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutBranchInput
    customers?: CustomerUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    sentTransfers?: StockTransferUncheckedCreateNestedManyWithoutSourceBranchInput
  }

  export type BranchCreateOrConnectWithoutReceivedTransfersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutReceivedTransfersInput, BranchUncheckedCreateWithoutReceivedTransfersInput>
  }

  export type StockTransferDetailCreateWithoutTransferInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    product: ProductCreateNestedOneWithoutTransferDetailsInput
  }

  export type StockTransferDetailUncheckedCreateWithoutTransferInput = {
    id?: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
  }

  export type StockTransferDetailCreateOrConnectWithoutTransferInput = {
    where: StockTransferDetailWhereUniqueInput
    create: XOR<StockTransferDetailCreateWithoutTransferInput, StockTransferDetailUncheckedCreateWithoutTransferInput>
  }

  export type BranchUpsertWithoutSentTransfersInput = {
    update: XOR<BranchUpdateWithoutSentTransfersInput, BranchUncheckedUpdateWithoutSentTransfersInput>
    create: XOR<BranchCreateWithoutSentTransfersInput, BranchUncheckedCreateWithoutSentTransfersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSentTransfersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSentTransfersInput, BranchUncheckedUpdateWithoutSentTransfersInput>
  }

  export type BranchUpdateWithoutSentTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUpdateManyWithoutBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    receivedTransfers?: StockTransferUpdateManyWithoutDestBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSentTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUncheckedUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    receivedTransfers?: StockTransferUncheckedUpdateManyWithoutDestBranchNestedInput
  }

  export type BranchUpsertWithoutReceivedTransfersInput = {
    update: XOR<BranchUpdateWithoutReceivedTransfersInput, BranchUncheckedUpdateWithoutReceivedTransfersInput>
    create: XOR<BranchCreateWithoutReceivedTransfersInput, BranchUncheckedCreateWithoutReceivedTransfersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutReceivedTransfersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutReceivedTransfersInput, BranchUncheckedUpdateWithoutReceivedTransfersInput>
  }

  export type BranchUpdateWithoutReceivedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUpdateManyWithoutBranchNestedInput
    customers?: CustomerUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUpdateManyWithoutSourceBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutReceivedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: ProductBranchUncheckedUpdateManyWithoutBranchNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutBranchNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutBranchNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    sentTransfers?: StockTransferUncheckedUpdateManyWithoutSourceBranchNestedInput
  }

  export type StockTransferDetailUpsertWithWhereUniqueWithoutTransferInput = {
    where: StockTransferDetailWhereUniqueInput
    update: XOR<StockTransferDetailUpdateWithoutTransferInput, StockTransferDetailUncheckedUpdateWithoutTransferInput>
    create: XOR<StockTransferDetailCreateWithoutTransferInput, StockTransferDetailUncheckedCreateWithoutTransferInput>
  }

  export type StockTransferDetailUpdateWithWhereUniqueWithoutTransferInput = {
    where: StockTransferDetailWhereUniqueInput
    data: XOR<StockTransferDetailUpdateWithoutTransferInput, StockTransferDetailUncheckedUpdateWithoutTransferInput>
  }

  export type StockTransferDetailUpdateManyWithWhereWithoutTransferInput = {
    where: StockTransferDetailScalarWhereInput
    data: XOR<StockTransferDetailUpdateManyMutationInput, StockTransferDetailUncheckedUpdateManyWithoutTransferInput>
  }

  export type StockTransferCreateWithoutDetailsInput = {
    id?: string
    date?: Date | string
    status?: string
    sourceBranch: BranchCreateNestedOneWithoutSentTransfersInput
    destBranch: BranchCreateNestedOneWithoutReceivedTransfersInput
  }

  export type StockTransferUncheckedCreateWithoutDetailsInput = {
    id?: string
    date?: Date | string
    status?: string
    sourceBranchId: string
    destBranchId: string
  }

  export type StockTransferCreateOrConnectWithoutDetailsInput = {
    where: StockTransferWhereUniqueInput
    create: XOR<StockTransferCreateWithoutDetailsInput, StockTransferUncheckedCreateWithoutDetailsInput>
  }

  export type ProductCreateWithoutTransferDetailsInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider?: ProviderCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    inventory?: ProductBranchCreateNestedManyWithoutProductInput
    saleDetails?: SaleDetailCreateNestedManyWithoutProductInput
    adjustments?: InventoryAdjustmentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTransferDetailsInput = {
    id?: string
    name: string
    code?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    priceRetail?: Decimal | DecimalJsLike | number | string | null
    priceWholesale?: Decimal | DecimalJsLike | number | string | null
    unit: string
    isActive?: boolean
    minStock?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    providerId?: string | null
    categoryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductBranchUncheckedCreateNestedManyWithoutProductInput
    saleDetails?: SaleDetailUncheckedCreateNestedManyWithoutProductInput
    adjustments?: InventoryAdjustmentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTransferDetailsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTransferDetailsInput, ProductUncheckedCreateWithoutTransferDetailsInput>
  }

  export type StockTransferUpsertWithoutDetailsInput = {
    update: XOR<StockTransferUpdateWithoutDetailsInput, StockTransferUncheckedUpdateWithoutDetailsInput>
    create: XOR<StockTransferCreateWithoutDetailsInput, StockTransferUncheckedCreateWithoutDetailsInput>
    where?: StockTransferWhereInput
  }

  export type StockTransferUpdateToOneWithWhereWithoutDetailsInput = {
    where?: StockTransferWhereInput
    data: XOR<StockTransferUpdateWithoutDetailsInput, StockTransferUncheckedUpdateWithoutDetailsInput>
  }

  export type StockTransferUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sourceBranch?: BranchUpdateOneRequiredWithoutSentTransfersNestedInput
    destBranch?: BranchUpdateOneRequiredWithoutReceivedTransfersNestedInput
  }

  export type StockTransferUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sourceBranchId?: StringFieldUpdateOperationsInput | string
    destBranchId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpsertWithoutTransferDetailsInput = {
    update: XOR<ProductUpdateWithoutTransferDetailsInput, ProductUncheckedUpdateWithoutTransferDetailsInput>
    create: XOR<ProductCreateWithoutTransferDetailsInput, ProductUncheckedCreateWithoutTransferDetailsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTransferDetailsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTransferDetailsInput, ProductUncheckedUpdateWithoutTransferDetailsInput>
  }

  export type ProductUpdateWithoutTransferDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inventory?: ProductBranchUpdateManyWithoutProductNestedInput
    saleDetails?: SaleDetailUpdateManyWithoutProductNestedInput
    adjustments?: InventoryAdjustmentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTransferDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductBranchUncheckedUpdateManyWithoutProductNestedInput
    saleDetails?: SaleDetailUncheckedUpdateManyWithoutProductNestedInput
    adjustments?: InventoryAdjustmentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type EmployeeShiftUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalCashExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    difference?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cashCounts?: CashCountUpdateManyWithoutShiftNestedInput
    sales?: SaleHeaderUpdateManyWithoutShiftNestedInput
  }

  export type EmployeeShiftUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalCashExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    difference?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cashCounts?: CashCountUncheckedUpdateManyWithoutShiftNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type EmployeeShiftUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initialCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalCashExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCashActual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    difference?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type SaleHeaderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branch?: BranchUpdateOneRequiredWithoutSalesNestedInput
    shift?: EmployeeShiftUpdateOneWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    details?: SaleDetailUpdateManyWithoutSaleNestedInput
    creditPayment?: CreditPaymentUpdateManyWithoutSaleNestedInput
  }

  export type SaleHeaderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: SaleDetailUncheckedUpdateManyWithoutSaleNestedInput
    creditPayment?: CreditPaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleHeaderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryAdjustmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutAdjustmentsNestedInput
  }

  export type InventoryAdjustmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryAdjustmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type SystemLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashMovementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutCashMovementsNestedInput
  }

  export type CashMovementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: StringFieldUpdateOperationsInput | string
  }

  export type CashMovementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductBranchUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    branch?: BranchUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type ProductBranchUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductBranchUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleDetailUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale?: SaleHeaderUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type SaleDetailUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleDetailUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventoryAdjustmentUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutInventoryAdjustmentsNestedInput
  }

  export type InventoryAdjustmentUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryAdjustmentUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type StockTransferDetailUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transfer?: StockTransferUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type StockTransferDetailUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StockTransferDetailUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneWithoutProductsNestedInput
    inventory?: ProductBranchUpdateManyWithoutProductNestedInput
    saleDetails?: SaleDetailUpdateManyWithoutProductNestedInput
    adjustments?: InventoryAdjustmentUpdateManyWithoutProductNestedInput
    transferDetails?: StockTransferDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductBranchUncheckedUpdateManyWithoutProductNestedInput
    saleDetails?: SaleDetailUncheckedUpdateManyWithoutProductNestedInput
    adjustments?: InventoryAdjustmentUncheckedUpdateManyWithoutProductNestedInput
    transferDetails?: StockTransferDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inventory?: ProductBranchUpdateManyWithoutProductNestedInput
    saleDetails?: SaleDetailUpdateManyWithoutProductNestedInput
    adjustments?: InventoryAdjustmentUpdateManyWithoutProductNestedInput
    transferDetails?: StockTransferDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductBranchUncheckedUpdateManyWithoutProductNestedInput
    saleDetails?: SaleDetailUncheckedUpdateManyWithoutProductNestedInput
    adjustments?: InventoryAdjustmentUncheckedUpdateManyWithoutProductNestedInput
    transferDetails?: StockTransferDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceRetail?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceWholesale?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    branch?: BranchUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductBranchUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: ProductUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type ProductBranchUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductBranchUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleHeaderUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutSalesNestedInput
    shift?: EmployeeShiftUpdateOneWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    details?: SaleDetailUpdateManyWithoutSaleNestedInput
    creditPayment?: CreditPaymentUpdateManyWithoutSaleNestedInput
  }

  export type SaleHeaderUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: SaleDetailUncheckedUpdateManyWithoutSaleNestedInput
    creditPayment?: CreditPaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleHeaderUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: ProviderUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type CashMovementUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCashMovementsNestedInput
  }

  export type CashMovementUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CashMovementUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    taxRegime?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleHeaderUpdateManyWithoutCustomerNestedInput
    creditPayments?: CreditPaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    taxRegime?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleHeaderUncheckedUpdateManyWithoutCustomerNestedInput
    creditPayments?: CreditPaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    taxRegime?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: EmployeeShiftUpdateManyWithoutUserNestedInput
    sales?: SaleHeaderUpdateManyWithoutUserNestedInput
    inventoryAdjustments?: InventoryAdjustmentUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    cashMovements?: CashMovementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutUserNestedInput
    sales?: SaleHeaderUncheckedUpdateManyWithoutUserNestedInput
    inventoryAdjustments?: InventoryAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferUpdateWithoutSourceBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    destBranch?: BranchUpdateOneRequiredWithoutReceivedTransfersNestedInput
    details?: StockTransferDetailUpdateManyWithoutTransferNestedInput
  }

  export type StockTransferUncheckedUpdateWithoutSourceBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    destBranchId?: StringFieldUpdateOperationsInput | string
    details?: StockTransferDetailUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type StockTransferUncheckedUpdateManyWithoutSourceBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    destBranchId?: StringFieldUpdateOperationsInput | string
  }

  export type StockTransferUpdateWithoutDestBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sourceBranch?: BranchUpdateOneRequiredWithoutSentTransfersNestedInput
    details?: StockTransferDetailUpdateManyWithoutTransferNestedInput
  }

  export type StockTransferUncheckedUpdateWithoutDestBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sourceBranchId?: StringFieldUpdateOperationsInput | string
    details?: StockTransferDetailUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type StockTransferUncheckedUpdateManyWithoutDestBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sourceBranchId?: StringFieldUpdateOperationsInput | string
  }

  export type SaleHeaderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branch?: BranchUpdateOneRequiredWithoutSalesNestedInput
    user?: UserUpdateOneWithoutSalesNestedInput
    shift?: EmployeeShiftUpdateOneWithoutSalesNestedInput
    details?: SaleDetailUpdateManyWithoutSaleNestedInput
    creditPayment?: CreditPaymentUpdateManyWithoutSaleNestedInput
  }

  export type SaleHeaderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: SaleDetailUncheckedUpdateManyWithoutSaleNestedInput
    creditPayment?: CreditPaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleHeaderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditPaymentUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    sale?: SaleHeaderUpdateOneWithoutCreditPaymentNestedInput
  }

  export type CreditPaymentUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditPaymentUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SaleDetailUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: ProductUpdateOneRequiredWithoutSaleDetailsNestedInput
  }

  export type SaleDetailUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleDetailUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CreditPaymentUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneRequiredWithoutCreditPaymentsNestedInput
  }

  export type CreditPaymentUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type CreditPaymentUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type CashCountUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    denomination?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type CashCountUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    denomination?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type CashCountUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    denomination?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SaleHeaderUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branch?: BranchUpdateOneRequiredWithoutSalesNestedInput
    user?: UserUpdateOneWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    details?: SaleDetailUpdateManyWithoutSaleNestedInput
    creditPayment?: CreditPaymentUpdateManyWithoutSaleNestedInput
  }

  export type SaleHeaderUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: SaleDetailUncheckedUpdateManyWithoutSaleNestedInput
    creditPayment?: CreditPaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleHeaderUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockTransferDetailUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: ProductUpdateOneRequiredWithoutTransferDetailsNestedInput
  }

  export type StockTransferDetailUncheckedUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StockTransferDetailUncheckedUpdateManyWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProviderCountOutputTypeDefaultArgs instead
     */
    export type ProviderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProviderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchCountOutputTypeDefaultArgs instead
     */
    export type BranchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleHeaderCountOutputTypeDefaultArgs instead
     */
    export type SaleHeaderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleHeaderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeShiftCountOutputTypeDefaultArgs instead
     */
    export type EmployeeShiftCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeShiftCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockTransferCountOutputTypeDefaultArgs instead
     */
    export type StockTransferCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockTransferCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProviderDefaultArgs instead
     */
    export type ProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProviderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchDefaultArgs instead
     */
    export type BranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductBranchDefaultArgs instead
     */
    export type ProductBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleHeaderDefaultArgs instead
     */
    export type SaleHeaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleHeaderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleDetailDefaultArgs instead
     */
    export type SaleDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseDefaultArgs instead
     */
    export type ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseDefaultArgs instead
     */
    export type PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreditPaymentDefaultArgs instead
     */
    export type CreditPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreditPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeShiftDefaultArgs instead
     */
    export type EmployeeShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeShiftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashCountDefaultArgs instead
     */
    export type CashCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashCountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashMovementDefaultArgs instead
     */
    export type CashMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashMovementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryAdjustmentDefaultArgs instead
     */
    export type InventoryAdjustmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryAdjustmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemLogDefaultArgs instead
     */
    export type SystemLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockTransferDefaultArgs instead
     */
    export type StockTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockTransferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockTransferDetailDefaultArgs instead
     */
    export type StockTransferDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockTransferDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemSettingDefaultArgs instead
     */
    export type SystemSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemSettingDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}